{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n\tRactive.js v0.9.4\n\tBuild: bfb687b620991b7313ef17aea1092d1af98fc3bf\n\tDate: Sat Sep 30 2017 01:15:45 GMT+0000 (UTC)\n\tWebsite: http://ractivejs.org\n\tLicense: MIT\n*/\n\n/* istanbul ignore if */\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, 'find', {\n    value: function value(callback, thisArg) {\n      if (this === null || this === undefined) throw new TypeError('Array.prototype.find called on null or undefined');\n      if (typeof callback !== 'function') throw new TypeError(\"\".concat(callback, \" is not a function\"));\n      var array = Object(this);\n      var arrayLength = array.length >>> 0;\n\n      for (var index = 0; index < arrayLength; index++) {\n        if (!Object.hasOwnProperty.call(array, index)) continue;\n        if (!callback.call(thisArg, array[index], index, array)) continue;\n        return array[index];\n      }\n\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n} // NOTE: Node doesn't exist in IE8. Nothing can be done.\n\n/* istanbul ignore if */\n\n\nif (typeof window !== 'undefined' && window.Node && window.Node.prototype && !window.Node.prototype.contains) {\n  Node.prototype.contains = function (node) {\n    if (!node) throw new TypeError('node required');\n\n    do {\n      if (this === node) return true;\n    } while (node = node && node.parentNode);\n\n    return false;\n  };\n}\n/* istanbul ignore if */\n\n\nif (!Object.assign) {\n  Object.assign = function (target) {\n    if (target == null) throw new TypeError('Cannot convert undefined or null to object');\n    var to = Object(target);\n    var sourcesLength = arguments.length <= 1 ? 0 : arguments.length - 1;\n\n    for (var index = 0; index < sourcesLength; index++) {\n      var nextSource = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];\n\n      for (var nextKey in nextSource) {\n        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) continue;\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n\n    return to;\n  };\n}\n/* istanbul ignore if */\n\n\nif (typeof window !== 'undefined' && window.performance && !window.performance.now) {\n  window.performance = window.performance || {};\n  var nowOffset = Date.now();\n\n  window.performance.now = function () {\n    return Date.now() - nowOffset;\n  };\n}\n/* istanbul ignore if */\n\n\nif (typeof window !== 'undefined' && !window.Promise) {\n  var PENDING = {};\n  var FULFILLED = {};\n  var REJECTED = {};\n\n  var _Promise = window.Promise = function (callback) {\n    var fulfilledHandlers = [];\n    var rejectedHandlers = [];\n    var state = PENDING;\n    var result;\n    var dispatchHandlers;\n\n    var makeResolver = function makeResolver(newState) {\n      return function (value) {\n        if (state !== PENDING) return;\n        result = value;\n        state = newState;\n        dispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n        wait(dispatchHandlers);\n      };\n    };\n\n    var fulfill = makeResolver(FULFILLED);\n    var reject = makeResolver(REJECTED);\n\n    try {\n      callback(fulfill, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    return {\n      // `then()` returns a Promise - 2.2.7\n      then: function then(onFulfilled, onRejected) {\n        var promise2 = new _Promise(function (fulfill, reject) {\n          var processResolutionHandler = function processResolutionHandler(handler, handlers, forward) {\n            if (typeof handler === 'function') {\n              handlers.push(function (p1result) {\n                try {\n                  _resolve(promise2, handler(p1result), fulfill, reject);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            } else {\n              handlers.push(forward);\n            }\n          };\n\n          processResolutionHandler(onFulfilled, fulfilledHandlers, fulfill);\n          processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n          if (state !== PENDING) {\n            wait(dispatchHandlers);\n          }\n        });\n        return promise2;\n      },\n      'catch': function _catch(onRejected) {\n        return this.then(null, onRejected);\n      }\n    };\n  };\n\n  _Promise.all = function (promises) {\n    return new _Promise(function (fulfil, reject) {\n      var result = [];\n      var pending;\n      var i;\n\n      if (!promises.length) {\n        fulfil(result);\n        return;\n      }\n\n      var processPromise = function processPromise(promise, i) {\n        if (promise && typeof promise.then === 'function') {\n          promise.then(function (value) {\n            result[i] = value;\n            --pending || fulfil(result);\n          }, reject);\n        } else {\n          result[i] = promise;\n          --pending || fulfil(result);\n        }\n      };\n\n      pending = i = promises.length;\n\n      while (i--) {\n        processPromise(promises[i], i);\n      }\n    });\n  };\n\n  _Promise.resolve = function (value) {\n    return new _Promise(function (fulfill) {\n      fulfill(value);\n    });\n  };\n\n  _Promise.reject = function (reason) {\n    return new _Promise(function (fulfill, reject) {\n      reject(reason);\n    });\n  }; // TODO use MutationObservers or something to simulate setImmediate\n\n\n  var wait = function wait(callback) {\n    setTimeout(callback, 0);\n  };\n\n  var makeDispatcher = function makeDispatcher(handlers, result) {\n    return function () {\n      for (var _handler; _handler = handlers.shift();) {\n        _handler(result);\n      }\n    };\n  };\n\n  var _resolve = function _resolve(promise, x, fulfil, reject) {\n    var then;\n\n    if (x === promise) {\n      throw new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n    }\n\n    if (x instanceof _Promise) {\n      x.then(fulfil, reject);\n    } else if (x && (_typeof(x) === 'object' || typeof x === 'function')) {\n      try {\n        then = x.then;\n      } catch (e) {\n        reject(e);\n        return;\n      }\n\n      if (typeof then === 'function') {\n        var called;\n\n        var resolvePromise = function resolvePromise(y) {\n          if (called) return;\n          called = true;\n\n          _resolve(promise, y, fulfil, reject);\n        };\n\n        var rejectPromise = function rejectPromise(r) {\n          if (called) return;\n          called = true;\n          reject(r);\n        };\n\n        try {\n          then.call(x, resolvePromise, rejectPromise);\n        } catch (e) {\n          if (!called) {\n            reject(e);\n            called = true;\n            return;\n          }\n        }\n      } else {\n        fulfil(x);\n      }\n    } else {\n      fulfil(x);\n    }\n  };\n}\n/* istanbul ignore if */\n\n\nif (typeof window !== 'undefined' && !(window.requestAnimationFrame && window.cancelAnimationFrame)) {\n  var lastTime = 0;\n\n  window.requestAnimationFrame = function (callback) {\n    var currentTime = Date.now();\n    var timeToNextCall = Math.max(0, 16 - (currentTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currentTime + timeToNextCall);\n    }, timeToNextCall);\n    lastTime = currentTime + timeToNextCall;\n    return id;\n  };\n\n  window.cancelAnimationFrame = function (id) {\n    clearTimeout(id);\n  };\n}\n\nvar defaults = {\n  // render placement:\n  el: void 0,\n  append: false,\n  delegate: true,\n  // template:\n  template: null,\n  // parse:\n  delimiters: ['{{', '}}'],\n  tripleDelimiters: ['{{{', '}}}'],\n  staticDelimiters: ['[[', ']]'],\n  staticTripleDelimiters: ['[[[', ']]]'],\n  csp: true,\n  interpolate: false,\n  preserveWhitespace: false,\n  sanitize: false,\n  stripComments: true,\n  contextLines: 0,\n  parserTransforms: [],\n  // data & binding:\n  data: {},\n  computed: {},\n  syncComputedChildren: false,\n  resolveInstanceMembers: true,\n  warnAboutAmbiguity: false,\n  adapt: [],\n  isolated: true,\n  twoway: true,\n  lazy: false,\n  // transitions:\n  noIntro: false,\n  noOutro: false,\n  transitionsEnabled: true,\n  complete: void 0,\n  nestedTransitions: true,\n  // css:\n  css: null,\n  noCssTransform: false\n}; // These are a subset of the easing equations found at\n// https://raw.github.com/danro/easing-js - license info\n// follows:\n// --------------------------------------------------\n// easing.js v0.5.4\n// Generic set of easing functions with AMD support\n// https://github.com/danro/easing-js\n// This code may be freely distributed under the MIT license\n// http://danro.mit-license.org/\n// --------------------------------------------------\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\n// Easing Equations (c) 2003 Robert Penner, BSD license\n// https://raw.github.com/danro/easing-js/master/LICENSE\n// --------------------------------------------------\n// In that library, the functions named easeIn, easeOut, and\n// easeInOut below are named easeInCubic, easeOutCubic, and\n// (you guessed it) easeInOutCubic.\n//\n// You can add additional easing functions to this list, and they\n// will be globally available.\n\nvar easing = {\n  linear: function linear(pos) {\n    return pos;\n  },\n  easeIn: function easeIn(pos) {\n    /* istanbul ignore next */\n    return Math.pow(pos, 3);\n  },\n  easeOut: function easeOut(pos) {\n    return Math.pow(pos - 1, 3) + 1;\n  },\n  easeInOut: function easeInOut(pos) {\n    /* istanbul ignore next */\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n    /* istanbul ignore next */\n\n\n    return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  }\n};\nvar toString = Object.prototype.toString;\n\nfunction isEqual(a, b) {\n  if (a === null && b === null) {\n    return true;\n  }\n\n  if (_typeof(a) === 'object' || _typeof(b) === 'object') {\n    return false;\n  }\n\n  return a === b;\n} // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n\n\nfunction isNumeric(thing) {\n  return !isNaN(parseFloat(thing)) && isFinite(thing);\n}\n\nfunction isObject(thing) {\n  return thing && toString.call(thing) === '[object Object]';\n}\n\nfunction isObjectLike(thing) {\n  if (!thing) return false;\n\n  var type = _typeof(thing);\n\n  if (type === 'object' || type === 'function') return true;\n}\n/* eslint no-console:\"off\" */\n\n\nvar win = typeof window !== 'undefined' ? window : null;\nvar doc = win ? document : null;\nvar isClient = !!doc;\nvar hasConsole = typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function';\nvar svg = doc ? doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1') : false;\nvar vendors = ['o', 'ms', 'moz', 'webkit'];\n\nvar noop = function noop() {};\n/* global console */\n\n/* eslint no-console:\"off\" */\n\n\nvar alreadyWarned = {};\nvar log;\nvar printWarning;\n\nvar _welcome;\n\nif (hasConsole) {\n  var welcomeIntro = [\"%cRactive.js %c0.9.4 %cin debug mode, %cmore...\", 'color: rgb(114, 157, 52); font-weight: normal;', 'color: rgb(85, 85, 85); font-weight: normal;', 'color: rgb(85, 85, 85); font-weight: normal;', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'];\n  var welcomeMessage = \"You're running Ractive 0.9.4 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  _welcome = function welcome() {\n    if (Ractive.WELCOME_MESSAGE === false) {\n      _welcome = noop;\n      return;\n    }\n\n    var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n    var hasGroup = !!console.groupCollapsed;\n    if (hasGroup) console.groupCollapsed.apply(console, welcomeIntro);\n    console.log(message);\n\n    if (hasGroup) {\n      console.groupEnd(welcomeIntro);\n    }\n\n    _welcome = noop;\n  };\n\n  printWarning = function printWarning(message, args) {\n    _welcome(); // extract information about the instance this message pertains to, if applicable\n\n\n    if (_typeof(args[args.length - 1]) === 'object') {\n      var options = args.pop();\n      var ractive = options ? options.ractive : null;\n\n      if (ractive) {\n        // if this is an instance of a component that we know the name of, add\n        // it to the message\n        var _name;\n\n        if (ractive.component && (_name = ractive.component.name)) {\n          message = \"<\".concat(_name, \"> \").concat(message);\n        }\n\n        var node;\n\n        if (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find('*')) {\n          args.push(node);\n        }\n      }\n    }\n\n    console.warn.apply(console, ['%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);'].concat(args));\n  };\n\n  log = function log() {\n    console.log.apply(console, arguments);\n  };\n} else {\n  printWarning = log = _welcome = noop;\n}\n\nfunction format(message, args) {\n  return message.replace(/%s/g, function () {\n    return args.shift();\n  });\n}\n\nfunction fatal(message) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  message = format(message, args);\n  throw new Error(message);\n}\n\nfunction logIfDebug() {\n  if (Ractive.DEBUG) {\n    log.apply(null, arguments);\n  }\n}\n\nfunction warn(message) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  message = format(message, args);\n  printWarning(message, args);\n}\n\nfunction warnOnce(message) {\n  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  message = format(message, args);\n\n  if (alreadyWarned[message]) {\n    return;\n  }\n\n  alreadyWarned[message] = true;\n  printWarning(message, args);\n}\n\nfunction warnIfDebug() {\n  if (Ractive.DEBUG) {\n    warn.apply(null, arguments);\n  }\n}\n\nfunction warnOnceIfDebug() {\n  if (Ractive.DEBUG) {\n    warnOnce.apply(null, arguments);\n  }\n} // Error messages that are used (or could be) in multiple places\n\n\nvar badArguments = 'Bad arguments';\nvar noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\n\nvar missingPlugin = function missingPlugin(name, type) {\n  return \"Missing \\\"\".concat(name, \"\\\" \").concat(type, \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\").concat(type, \"s\");\n};\n\nfunction findInViewHierarchy(registryName, ractive, name) {\n  var instance = findInstance(registryName, ractive, name);\n  return instance ? instance[registryName][name] : null;\n}\n\nfunction findInstance(registryName, ractive, name) {\n  while (ractive) {\n    if (name in ractive[registryName]) {\n      return ractive;\n    }\n\n    if (ractive.isolated) {\n      return null;\n    }\n\n    ractive = ractive.parent;\n  }\n}\n\nfunction interpolate(from, to, ractive, type) {\n  if (from === to) return null;\n\n  if (type) {\n    var interpol = findInViewHierarchy('interpolators', ractive, type);\n    if (interpol) return interpol(from, to) || null;\n    fatal(missingPlugin(type, 'interpolator'));\n  }\n\n  return interpolators.number(from, to) || interpolators.array(from, to) || interpolators.object(from, to) || null;\n}\n\nvar interpolators = {\n  number: function number(from, to) {\n    if (!isNumeric(from) || !isNumeric(to)) {\n      return null;\n    }\n\n    from = +from;\n    to = +to;\n    var delta = to - from;\n\n    if (!delta) {\n      return function () {\n        return from;\n      };\n    }\n\n    return function (t) {\n      return from + t * delta;\n    };\n  },\n  array: function array(from, to) {\n    var len, i;\n\n    if (!Array.isArray(from) || !Array.isArray(to)) {\n      return null;\n    }\n\n    var intermediate = [];\n    var interpolators = [];\n    i = len = Math.min(from.length, to.length);\n\n    while (i--) {\n      interpolators[i] = interpolate(from[i], to[i]);\n    } // surplus values - don't interpolate, but don't exclude them either\n\n\n    for (i = len; i < from.length; i += 1) {\n      intermediate[i] = from[i];\n    }\n\n    for (i = len; i < to.length; i += 1) {\n      intermediate[i] = to[i];\n    }\n\n    return function (t) {\n      var i = len;\n\n      while (i--) {\n        intermediate[i] = interpolators[i](t);\n      }\n\n      return intermediate;\n    };\n  },\n  object: function object(from, to) {\n    if (!isObject(from) || !isObject(to)) {\n      return null;\n    }\n\n    var properties = [];\n    var intermediate = {};\n    var interpolators = {};\n\n    var _loop = function _loop(prop) {\n      if (from.hasOwnProperty(prop)) {\n        if (to.hasOwnProperty(prop)) {\n          properties.push(prop);\n\n          interpolators[prop] = interpolate(from[prop], to[prop]) || function () {\n            return to[prop];\n          };\n        } else {\n          intermediate[prop] = from[prop];\n        }\n      }\n    };\n\n    for (var prop in from) {\n      _loop(prop);\n    }\n\n    for (var prop in to) {\n      if (to.hasOwnProperty(prop) && !from.hasOwnProperty(prop)) {\n        intermediate[prop] = to[prop];\n      }\n    }\n\n    var len = properties.length;\n    return function (t) {\n      var i = len;\n\n      while (i--) {\n        var _prop = properties[i];\n        intermediate[_prop] = interpolators[_prop](t);\n      }\n\n      return intermediate;\n    };\n  }\n};\nvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\nvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\nvar escapeKeyPattern = /\\\\|\\./g;\nvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\nfunction escapeKey(key) {\n  if (typeof key === 'string') {\n    return key.replace(escapeKeyPattern, '\\\\$&');\n  }\n\n  return key;\n}\n\nfunction normalise(ref) {\n  return ref ? ref.replace(refPattern, '.$1') : '';\n}\n\nfunction splitKeypath(keypath) {\n  var result = [];\n  var match;\n  keypath = normalise(keypath);\n\n  while (match = splitPattern.exec(keypath)) {\n    var index = match.index + match[1].length;\n    result.push(keypath.substr(0, index));\n    keypath = keypath.substr(index + 1);\n  }\n\n  result.push(keypath);\n  return result;\n}\n\nfunction unescapeKey(key) {\n  if (typeof key === 'string') {\n    return key.replace(unescapeKeyPattern, '$1$2');\n  }\n\n  return key;\n}\n\nfunction addToArray(array, value) {\n  var index = array.indexOf(value);\n\n  if (index === -1) {\n    array.push(value);\n  }\n}\n\nfunction arrayContains(array, value) {\n  for (var _i = 0, c = array.length; _i < c; _i++) {\n    if (array[_i] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arrayContentsMatch(a, b) {\n  var i;\n\n  if (!Array.isArray(a) || !Array.isArray(b)) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  i = a.length;\n\n  while (i--) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureArray(x) {\n  if (typeof x === 'string') {\n    return [x];\n  }\n\n  if (x === undefined) {\n    return [];\n  }\n\n  return x;\n}\n\nfunction lastItem(array) {\n  return array[array.length - 1];\n}\n\nfunction removeFromArray(array, member) {\n  if (!array) {\n    return;\n  }\n\n  var index = array.indexOf(member);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nfunction combine() {\n  for (var _len4 = arguments.length, arrays = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    arrays[_key4] = arguments[_key4];\n  }\n\n  var res = arrays.concat.apply([], arrays);\n  var i = res.length;\n\n  while (i--) {\n    var idx = res.indexOf(res[i]);\n    if (~idx && idx < i) res.splice(i, 1);\n  }\n\n  return res;\n}\n\nfunction toArray(arrayLike) {\n  var array = [];\n  var i = arrayLike.length;\n\n  while (i--) {\n    array[i] = arrayLike[i];\n  }\n\n  return array;\n}\n\nfunction findMap(array, fn) {\n  var len = array.length;\n\n  for (var _i2 = 0; _i2 < len; _i2++) {\n    var result = fn(array[_i2]);\n    if (result) return result;\n  }\n}\n\nvar stack = [];\nvar captureGroup;\n\nfunction startCapturing() {\n  stack.push(captureGroup = []);\n}\n\nfunction stopCapturing() {\n  var dependencies = stack.pop();\n  captureGroup = stack[stack.length - 1];\n  return dependencies;\n}\n\nfunction capture(model) {\n  if (captureGroup) {\n    captureGroup.push(model);\n  }\n}\n\nvar KeyModel =\n/*#__PURE__*/\nfunction () {\n  function KeyModel(key, parent) {\n    _classCallCheck(this, KeyModel);\n\n    this.value = key;\n    this.isReadonly = this.isKey = true;\n    this.deps = [];\n    this.links = [];\n    this.parent = parent;\n  }\n\n  _createClass(KeyModel, [{\n    key: \"get\",\n    value: function get(shouldCapture) {\n      if (shouldCapture) capture(this);\n      return unescapeKey(this.value);\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return unescapeKey(this.value);\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous) {\n      var i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].rebind(next, previous, false);\n      }\n\n      i = this.links.length;\n\n      while (i--) {\n        this.links[i].relinking(next, false);\n      }\n    }\n  }, {\n    key: \"register\",\n    value: function register(dependant) {\n      this.deps.push(dependant);\n    }\n  }, {\n    key: \"registerLink\",\n    value: function registerLink(link) {\n      addToArray(this.links, link);\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(dependant) {\n      removeFromArray(this.deps, dependant);\n    }\n  }, {\n    key: \"unregisterLink\",\n    value: function unregisterLink(link) {\n      removeFromArray(this.links, link);\n    }\n  }]);\n\n  return KeyModel;\n}();\n\nKeyModel.prototype.reference = noop;\nKeyModel.prototype.unreference = noop;\n\nfunction _bind2(x) {\n  x.bind();\n}\n\nfunction cancel(x) {\n  x.cancel();\n}\n\nfunction _destroyed(x) {\n  x.destroyed();\n}\n\nfunction _handleChange(x) {\n  x.handleChange();\n}\n\nfunction _mark(x) {\n  x.mark();\n}\n\nfunction markForce(x) {\n  x.mark(true);\n}\n\nfunction _marked(x) {\n  x.marked();\n}\n\nfunction _markedAll(x) {\n  x.markedAll();\n}\n\nfunction _render(x) {\n  x.render();\n}\n\nfunction _shuffled(x) {\n  x.shuffled();\n}\n\nfunction _teardown(x) {\n  x.teardown();\n}\n\nfunction _unbind(x) {\n  x.unbind();\n}\n\nfunction _unrender(x) {\n  x.unrender();\n}\n\nfunction unrenderAndDestroy(x) {\n  x.unrender(true);\n}\n\nfunction _update(x) {\n  x.update();\n}\n\nfunction toString$1(x) {\n  return x.toString();\n}\n\nfunction toEscapedString(x) {\n  return x.toString(true);\n}\n\nvar KeypathModel =\n/*#__PURE__*/\nfunction () {\n  function KeypathModel(parent, ractive) {\n    _classCallCheck(this, KeypathModel);\n\n    this.parent = parent;\n    this.ractive = ractive;\n    this.value = ractive ? parent.getKeypath(ractive) : parent.getKeypath();\n    this.deps = [];\n    this.children = {};\n    this.isReadonly = this.isKeypath = true;\n  }\n\n  _createClass(KeypathModel, [{\n    key: \"get\",\n    value: function get(shouldCapture) {\n      if (shouldCapture) capture(this);\n      return this.value;\n    }\n  }, {\n    key: \"getChild\",\n    value: function getChild(ractive) {\n      if (!(ractive._guid in this.children)) {\n        var model = new KeypathModel(this.parent, ractive);\n        this.children[ractive._guid] = model;\n        model.owner = this;\n      }\n\n      return this.children[ractive._guid];\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return this.value;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      var keys = Object.keys(this.children);\n      var i = keys.length;\n\n      while (i--) {\n        this.children[keys[i]].handleChange();\n      }\n\n      this.deps.forEach(_handleChange);\n    }\n  }, {\n    key: \"rebindChildren\",\n    value: function rebindChildren(next) {\n      var keys = Object.keys(this.children);\n      var i = keys.length;\n\n      while (i--) {\n        var _child = this.children[keys[i]];\n        _child.value = next.getKeypath(_child.ractive);\n\n        _child.handleChange();\n      }\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous) {\n      var model = next ? next.getKeypathModel(this.ractive) : undefined;\n      var keys = Object.keys(this.children);\n      var i = keys.length;\n\n      while (i--) {\n        this.children[keys[i]].rebind(next, previous, false);\n      }\n\n      i = this.deps.length;\n\n      while (i--) {\n        this.deps[i].rebind(model, this, false);\n      }\n    }\n  }, {\n    key: \"register\",\n    value: function register(dep) {\n      this.deps.push(dep);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(model) {\n      if (model.ractive) delete this.children[model.ractive._guid];\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (this.owner) this.owner.removeChild(this);\n      var keys = Object.keys(this.children);\n      var i = keys.length;\n\n      while (i--) {\n        this.children[keys[i]].teardown();\n      }\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(dep) {\n      removeFromArray(this.deps, dep);\n      if (!this.deps.length) this.teardown();\n    }\n  }]);\n\n  return KeypathModel;\n}();\n\nKeypathModel.prototype.reference = noop;\nKeypathModel.prototype.unreference = noop;\nvar fnBind = Function.prototype.bind;\n\nfunction bind$1(fn, context) {\n  if (!/this/.test(fn.toString())) return fn;\n  var bound = fnBind.call(fn, context);\n\n  for (var prop in fn) {\n    bound[prop] = fn[prop];\n  }\n\n  return bound;\n}\n\nvar hasProp = Object.prototype.hasOwnProperty;\nvar shuffleTasks = {\n  early: [],\n  mark: []\n};\nvar registerQueue = {\n  early: [],\n  mark: []\n};\n\nvar ModelBase =\n/*#__PURE__*/\nfunction () {\n  function ModelBase(parent) {\n    _classCallCheck(this, ModelBase);\n\n    this.deps = [];\n    this.children = [];\n    this.childByKey = {};\n    this.links = [];\n    this.keyModels = {};\n    this.bindings = [];\n    this.patternObservers = [];\n\n    if (parent) {\n      this.parent = parent;\n      this.root = parent.root;\n    }\n  }\n\n  _createClass(ModelBase, [{\n    key: \"addShuffleTask\",\n    value: function addShuffleTask(task) {\n      var stage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'early';\n      shuffleTasks[stage].push(task);\n    }\n  }, {\n    key: \"addShuffleRegister\",\n    value: function addShuffleRegister(item) {\n      var stage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'early';\n      registerQueue[stage].push({\n        model: this,\n        item: item\n      });\n    }\n  }, {\n    key: \"downstreamChanged\",\n    value: function downstreamChanged() {}\n  }, {\n    key: \"findMatches\",\n    value: function findMatches(keys) {\n      var len = keys.length;\n      var existingMatches = [this];\n      var matches;\n      var i;\n\n      var _loop2 = function _loop2() {\n        var key = keys[i];\n\n        if (key === '*') {\n          matches = [];\n          existingMatches.forEach(function (model) {\n            matches.push.apply(matches, model.getValueChildren(model.get()));\n          });\n        } else {\n          matches = existingMatches.map(function (model) {\n            return model.joinKey(key);\n          });\n        }\n\n        existingMatches = matches;\n      };\n\n      for (i = 0; i < len; i += 1) {\n        _loop2();\n      }\n\n      return matches;\n    }\n  }, {\n    key: \"getKeyModel\",\n    value: function getKeyModel(key, skip) {\n      if (key !== undefined && !skip) return this.parent.getKeyModel(key, true);\n      if (!(key in this.keyModels)) this.keyModels[key] = new KeyModel(escapeKey(key), this);\n      return this.keyModels[key];\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath(ractive) {\n      if (ractive !== this.ractive && this._link) return this._link.target.getKeypath(ractive);\n\n      if (!this.keypath) {\n        var parent = this.parent && this.parent.getKeypath(ractive);\n        this.keypath = parent ? \"\".concat(this.parent.getKeypath(ractive), \".\").concat(escapeKey(this.key)) : escapeKey(this.key);\n      }\n\n      return this.keypath;\n    }\n  }, {\n    key: \"getValueChildren\",\n    value: function getValueChildren(value) {\n      var _this = this;\n\n      var children;\n\n      if (Array.isArray(value)) {\n        children = [];\n\n        if ('length' in this && this.length !== value.length) {\n          children.push(this.joinKey('length'));\n        }\n\n        value.forEach(function (m, i) {\n          children.push(_this.joinKey(i));\n        });\n      } else if (isObject(value) || typeof value === 'function') {\n        children = Object.keys(value).map(function (key) {\n          return _this.joinKey(key);\n        });\n      } else if (value != null) {\n        return [];\n      }\n\n      return children;\n    }\n  }, {\n    key: \"getVirtual\",\n    value: function getVirtual(shouldCapture) {\n      var value = this.get(shouldCapture, {\n        virtual: false\n      });\n\n      if (isObject(value)) {\n        var result = Array.isArray(value) ? [] : {};\n        var keys = Object.keys(value);\n        var _i3 = keys.length;\n\n        while (_i3--) {\n          var _child2 = this.childByKey[keys[_i3]];\n          if (!_child2) result[keys[_i3]] = value[keys[_i3]];else if (_child2._link) result[keys[_i3]] = _child2._link.getVirtual();else result[keys[_i3]] = _child2.getVirtual();\n        }\n\n        _i3 = this.children.length;\n\n        while (_i3--) {\n          var _child3 = this.children[_i3];\n\n          if (!(_child3.key in result) && _child3._link) {\n            result[_child3.key] = _child3._link.getVirtual();\n          }\n        }\n\n        return result;\n      } else return value;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      if (this._link) return this._link.has(key);\n      var value = this.get();\n      if (!value) return false;\n      key = unescapeKey(key);\n      if (hasProp.call(value, key)) return true; // We climb up the constructor chain to find if one of them contains the key\n\n      var constructor = value.constructor;\n\n      while (constructor !== Function && constructor !== Array && constructor !== Object) {\n        if (hasProp.call(constructor.prototype, key)) return true;\n        constructor = constructor.constructor;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"joinAll\",\n    value: function joinAll(keys, opts) {\n      var model = this;\n\n      for (var _i4 = 0; _i4 < keys.length; _i4 += 1) {\n        if (opts && opts.lastLink === false && _i4 + 1 === keys.length && model.childByKey[keys[_i4]] && model.childByKey[keys[_i4]]._link) return model.childByKey[keys[_i4]];\n        model = model.joinKey(keys[_i4], opts);\n      }\n\n      return model;\n    }\n  }, {\n    key: \"notifyUpstream\",\n    value: function notifyUpstream(startPath) {\n      var _this2 = this;\n\n      var parent = this.parent;\n      var path = startPath || [this.key];\n\n      while (parent) {\n        if (parent.patternObservers.length) parent.patternObservers.forEach(function (o) {\n          return o.notify(path.slice());\n        });\n        path.unshift(parent.key);\n        parent.links.forEach(function (l) {\n          return l.notifiedUpstream(path, _this2.root);\n        });\n        parent.deps.forEach(function (d) {\n          return d.handleChange(path);\n        });\n        parent.downstreamChanged(startPath);\n        parent = parent.parent;\n      }\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous, safe) {\n      if (this._link) {\n        this._link.rebind(next, previous, false);\n      } // tell the deps to move to the new target\n\n\n      var i = this.deps.length;\n\n      while (i--) {\n        if (this.deps[i].rebind) this.deps[i].rebind(next, previous, safe);\n      }\n\n      i = this.links.length;\n\n      while (i--) {\n        var _link = this.links[i]; // only relink the root of the link tree\n\n        if (_link.owner._link) _link.relinking(next, safe);\n      }\n\n      i = this.children.length;\n\n      while (i--) {\n        var _child4 = this.children[i];\n\n        _child4.rebind(next ? next.joinKey(_child4.key) : undefined, _child4, safe);\n      }\n\n      if (this.keypathModel) this.keypathModel.rebind(next, previous, false);\n      i = this.bindings.length;\n\n      while (i--) {\n        this.bindings[i].rebind(next, previous, safe);\n      }\n    }\n  }, {\n    key: \"reference\",\n    value: function reference() {\n      'refs' in this ? this.refs++ : this.refs = 1;\n    }\n  }, {\n    key: \"register\",\n    value: function register(dep) {\n      this.deps.push(dep);\n    }\n  }, {\n    key: \"registerLink\",\n    value: function registerLink(link) {\n      addToArray(this.links, link);\n    }\n  }, {\n    key: \"registerPatternObserver\",\n    value: function registerPatternObserver(observer) {\n      this.patternObservers.push(observer);\n      this.register(observer);\n    }\n  }, {\n    key: \"registerTwowayBinding\",\n    value: function registerTwowayBinding(binding) {\n      this.bindings.push(binding);\n    }\n  }, {\n    key: \"unreference\",\n    value: function unreference() {\n      if ('refs' in this) this.refs--;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(dep) {\n      removeFromArray(this.deps, dep);\n    }\n  }, {\n    key: \"unregisterLink\",\n    value: function unregisterLink(link) {\n      removeFromArray(this.links, link);\n    }\n  }, {\n    key: \"unregisterPatternObserver\",\n    value: function unregisterPatternObserver(observer) {\n      removeFromArray(this.patternObservers, observer);\n      this.unregister(observer);\n    }\n  }, {\n    key: \"unregisterTwowayBinding\",\n    value: function unregisterTwowayBinding(binding) {\n      removeFromArray(this.bindings, binding);\n    }\n  }, {\n    key: \"updateFromBindings\",\n    value: function updateFromBindings(cascade) {\n      var i = this.bindings.length;\n\n      while (i--) {\n        var _value = this.bindings[i].getValue();\n\n        if (_value !== this.value) this.set(_value);\n      } // check for one-way bindings if there are no two-ways\n\n\n      if (!this.bindings.length) {\n        var oneway = findBoundValue(this.deps);\n        if (oneway && oneway.value !== this.value) this.set(oneway.value);\n      }\n\n      if (cascade) {\n        this.children.forEach(_updateFromBindings);\n        this.links.forEach(_updateFromBindings);\n        if (this._link) this._link.updateFromBindings(cascade);\n      }\n    }\n  }]);\n\n  return ModelBase;\n}(); // TODO: this may be better handled by overreiding `get` on models with a parent that isRoot\n\n\nfunction maybeBind(model, value, shouldBind) {\n  if (shouldBind && typeof value === 'function' && model.parent && model.parent.isRoot) {\n    if (!model.boundValue) {\n      model.boundValue = bind$1(value._r_unbound || value, model.parent.ractive);\n    }\n\n    return model.boundValue;\n  }\n\n  return value;\n}\n\nfunction _updateFromBindings(model) {\n  model.updateFromBindings(true);\n}\n\nfunction findBoundValue(list) {\n  var i = list.length;\n\n  while (i--) {\n    if (list[i].bound) {\n      var owner = list[i].owner;\n\n      if (owner) {\n        var _value2 = owner.name === 'checked' ? owner.node.checked : owner.node.value;\n\n        return {\n          value: _value2\n        };\n      }\n    }\n  }\n}\n\nfunction fireShuffleTasks(stage) {\n  if (!stage) {\n    fireShuffleTasks('early');\n    fireShuffleTasks('mark');\n  } else {\n    var tasks = shuffleTasks[stage];\n    shuffleTasks[stage] = [];\n    var _i5 = tasks.length;\n\n    while (_i5--) {\n      tasks[_i5]();\n    }\n\n    var register = registerQueue[stage];\n    registerQueue[stage] = [];\n    _i5 = register.length;\n\n    while (_i5--) {\n      register[_i5].model.register(register[_i5].item);\n    }\n  }\n}\n\nfunction _shuffle(model, newIndices, link, unsafe) {\n  model.shuffling = true;\n  var i = newIndices.length;\n\n  while (i--) {\n    var idx = newIndices[i]; // nothing is actually changing, so move in the index and roll on\n\n    if (i === idx) {\n      continue;\n    } // rebind the children on i to idx\n\n\n    if (i in model.childByKey) model.childByKey[i].rebind(!~idx ? undefined : model.joinKey(idx), model.childByKey[i], !unsafe);\n\n    if (!~idx && model.keyModels[i]) {\n      model.keyModels[i].rebind(undefined, model.keyModels[i], false);\n    } else if (~idx && model.keyModels[i]) {\n      if (!model.keyModels[idx]) model.childByKey[idx].getKeyModel(idx);\n      model.keyModels[i].rebind(model.keyModels[idx], model.keyModels[i], false);\n    }\n  }\n\n  var upstream = model.source().length !== model.source().value.length;\n  model.links.forEach(function (l) {\n    return l.shuffle(newIndices);\n  });\n  if (!link) fireShuffleTasks('early');\n  i = model.deps.length;\n\n  while (i--) {\n    if (model.deps[i].shuffle) model.deps[i].shuffle(newIndices);\n  }\n\n  model[link ? 'marked' : 'mark']();\n  if (!link) fireShuffleTasks('mark');\n  if (upstream) model.notifyUpstream();\n  model.shuffling = false;\n}\n\nKeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\nKeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\nKeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\nKeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister; // this is the dry method of checking to see if a rebind applies to\n// a particular keypath because in some cases, a dep may be bound\n// directly to a particular keypath e.g. foo.bars.0.baz and need\n// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\n\nfunction rebindMatch(template, next, previous, fragment) {\n  var keypath = template.r || template; // no valid keypath, go with next\n\n  if (!keypath || typeof keypath !== 'string') return next; // completely contextual ref, go with next\n\n  if (keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath) return next;\n  var parts = keypath.split('/');\n  var keys = splitKeypath(parts[parts.length - 1]);\n  var last = keys[keys.length - 1]; // check the keypath against the model keypath to see if it matches\n\n  var model = next || previous; // check to see if this was an alias\n\n  if (model && keys.length === 1 && last !== model.key && fragment) {\n    keys = findAlias(last, fragment) || keys;\n  }\n\n  var i = keys.length;\n  var match = true;\n  var shuffling = false;\n\n  while (model && i--) {\n    if (model.shuffling) shuffling = true; // non-strict comparison to account for indices in keypaths\n\n    if (keys[i] != model.key) match = false;\n    model = model.parent;\n  } // next is undefined, but keypath is shuffling and previous matches\n\n\n  if (!next && match && shuffling) return previous; // next is defined, but doesn't match the keypath\n  else if (next && !match && shuffling) return previous;else return next;\n}\n\nfunction findAlias(name, fragment) {\n  while (fragment) {\n    var z = fragment.aliases;\n\n    if (z && z[name]) {\n      var aliases = (fragment.owner.iterations ? fragment.owner : fragment).owner.template.z;\n\n      for (var _i6 = 0; _i6 < aliases.length; _i6++) {\n        if (aliases[_i6].n === name) {\n          var alias = aliases[_i6].x;\n          if (!alias.r) return false;\n          var parts = alias.r.split('/');\n          return splitKeypath(parts[parts.length - 1]);\n        }\n      }\n\n      return;\n    }\n\n    fragment = fragment.componentParent || fragment.parent;\n  }\n} // temporary placeholder target for detached implicit links\n\n\nvar Missing = {\n  key: '@missing',\n  animate: noop,\n  applyValue: noop,\n  get: noop,\n  getKeypath: function getKeypath() {\n    return this.key;\n  },\n  joinAll: function joinAll() {\n    return this;\n  },\n  joinKey: function joinKey() {\n    return this;\n  },\n  mark: noop,\n  registerLink: noop,\n  shufle: noop,\n  set: noop,\n  unregisterLink: noop\n};\nMissing.parent = Missing;\n\nvar LinkModel =\n/*#__PURE__*/\nfunction (_ModelBase) {\n  _inherits(LinkModel, _ModelBase);\n\n  function LinkModel(parent, owner, target, key) {\n    var _this3;\n\n    _classCallCheck(this, LinkModel);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(LinkModel).call(this, parent));\n    _this3.owner = owner;\n    _this3.target = target;\n    _this3.key = key === undefined ? owner.key : key;\n    if (owner.isLink) _this3.sourcePath = \"\".concat(owner.sourcePath, \".\").concat(_this3.key);\n    target.registerLink(_assertThisInitialized(_this3));\n    if (parent) _this3.isReadonly = parent.isReadonly;\n    _this3.isLink = true;\n    return _this3;\n  }\n\n  _createClass(LinkModel, [{\n    key: \"animate\",\n    value: function animate(from, to, options, interpolator) {\n      return this.target.animate(from, to, options, interpolator);\n    }\n  }, {\n    key: \"applyValue\",\n    value: function applyValue(value) {\n      if (this.boundValue) this.boundValue = null;\n      this.target.applyValue(value);\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(fragment) {\n      var model = resolveReference(fragment, this.key);\n\n      if (model) {\n        this.relinking(model, false);\n      } else {\n        // if there is no link available, move everything here to real models\n        this.owner.unlink();\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.relinking(Missing, false);\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (shouldCapture) {\n        capture(this); // may need to tell the target to unwrap\n\n        opts.unwrap = true;\n      }\n\n      var bind$$1 = 'shouldBind' in opts ? opts.shouldBind : true;\n      opts.shouldBind = this.mapping && this.target.parent && this.target.parent.isRoot;\n      return maybeBind(this, this.target.get(false, opts), bind$$1);\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath(ractive) {\n      if (ractive && ractive !== this.root.ractive) return this.target.getKeypath(ractive);\n      return _get(_getPrototypeOf(LinkModel.prototype), \"getKeypath\", this).call(this, ractive);\n    }\n  }, {\n    key: \"getKeypathModel\",\n    value: function getKeypathModel(ractive) {\n      if (!this.keypathModel) this.keypathModel = new KeypathModel(this);\n      if (ractive && ractive !== this.root.ractive) return this.keypathModel.getChild(ractive);\n      return this.keypathModel;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.deps.forEach(_handleChange);\n      this.links.forEach(_handleChange);\n      this.notifyUpstream();\n    }\n  }, {\n    key: \"isDetached\",\n    value: function isDetached() {\n      return this.virtual && this.target === Missing;\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key) {\n      // TODO: handle nested links\n      if (key === undefined || key === '') return this;\n\n      if (!this.childByKey.hasOwnProperty(key)) {\n        var _child5 = new LinkModel(this, this, this.target.joinKey(key), key);\n\n        this.children.push(_child5);\n        this.childByKey[key] = _child5;\n      }\n\n      return this.childByKey[key];\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(force) {\n      this.target.mark(force);\n    }\n  }, {\n    key: \"marked\",\n    value: function marked() {\n      if (this.boundValue) this.boundValue = null;\n      this.links.forEach(_marked);\n      this.deps.forEach(_handleChange);\n    }\n  }, {\n    key: \"markedAll\",\n    value: function markedAll() {\n      this.children.forEach(_markedAll);\n      this.marked();\n    }\n  }, {\n    key: \"notifiedUpstream\",\n    value: function notifiedUpstream(startPath, root) {\n      var _this4 = this;\n\n      this.links.forEach(function (l) {\n        return l.notifiedUpstream(startPath, _this4.root);\n      });\n      this.deps.forEach(_handleChange);\n\n      if (startPath && this.rootLink && this.root !== root) {\n        var path = startPath.slice(1);\n        path.unshift(this.key);\n        this.notifyUpstream(path);\n      }\n    }\n  }, {\n    key: \"relinked\",\n    value: function relinked() {\n      this.target.registerLink(this);\n      this.children.forEach(function (c) {\n        return c.relinked();\n      });\n    }\n  }, {\n    key: \"relinking\",\n    value: function relinking(target, safe) {\n      var _this5 = this;\n\n      if (this.rootLink && this.sourcePath) target = rebindMatch(this.sourcePath, target, this.target);\n      if (!target || this.target === target) return;\n      this.target.unregisterLink(this);\n      if (this.keypathModel) this.keypathModel.rebindChildren(target);\n      this.target = target;\n      this.children.forEach(function (c) {\n        c.relinking(target.joinKey(c.key), safe);\n      });\n      if (this.rootLink) this.addShuffleTask(function () {\n        _this5.relinked();\n\n        if (!safe) {\n          _this5.markedAll();\n\n          _this5.notifyUpstream();\n        }\n      });\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      if (this.boundValue) this.boundValue = null;\n      this.target.set(value);\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices) {\n      // watch for extra shuffles caused by a shuffle in a downstream link\n      if (this.shuffling) return; // let the real model handle firing off shuffles\n\n      if (!this.target.shuffling) {\n        this.target.shuffle(newIndices);\n      } else {\n        _shuffle(this, newIndices, true);\n      }\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this.target.source) return this.target.source();else return this.target;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (this._link) this._link.teardown();\n      this.target.unregisterLink(this);\n      this.children.forEach(_teardown);\n    }\n  }]);\n\n  return LinkModel;\n}(ModelBase);\n\nModelBase.prototype.link = function link(model, keypath, options) {\n  var lnk = this._link || new LinkModel(this.parent, this, model, this.key);\n  lnk.implicit = options && options.implicit;\n  lnk.mapping = options && options.mapping;\n  lnk.sourcePath = keypath;\n  lnk.rootLink = true;\n  if (this._link) this._link.relinking(model, false);\n  this.rebind(lnk, this, false);\n  fireShuffleTasks();\n  this._link = lnk;\n  lnk.markedAll();\n  this.notifyUpstream();\n  return lnk;\n};\n\nModelBase.prototype.unlink = function unlink() {\n  if (this._link) {\n    var ln = this._link;\n    this._link = undefined;\n    ln.rebind(this, ln, false);\n    fireShuffleTasks();\n    ln.teardown();\n    this.notifyUpstream();\n  }\n};\n\nvar TransitionManager =\n/*#__PURE__*/\nfunction () {\n  function TransitionManager(callback, parent) {\n    _classCallCheck(this, TransitionManager);\n\n    this.callback = callback;\n    this.parent = parent;\n    this.intros = [];\n    this.outros = [];\n    this.children = [];\n    this.totalChildren = this.outroChildren = 0;\n    this.detachQueue = [];\n    this.outrosComplete = false;\n\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  _createClass(TransitionManager, [{\n    key: \"add\",\n    value: function add(transition) {\n      var list = transition.isIntro ? this.intros : this.outros;\n      transition.starting = true;\n      list.push(transition);\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      this.children.push(child);\n      this.totalChildren += 1;\n      this.outroChildren += 1;\n    }\n  }, {\n    key: \"decrementOutros\",\n    value: function decrementOutros() {\n      this.outroChildren -= 1;\n      check(this);\n    }\n  }, {\n    key: \"decrementTotal\",\n    value: function decrementTotal() {\n      this.totalChildren -= 1;\n      check(this);\n    }\n  }, {\n    key: \"detachNodes\",\n    value: function detachNodes() {\n      this.detachQueue.forEach(detach);\n      this.children.forEach(_detachNodes);\n      this.detachQueue = [];\n    }\n  }, {\n    key: \"ready\",\n    value: function ready() {\n      if (this.detachQueue.length) detachImmediate(this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(transition) {\n      var list = transition.isIntro ? this.intros : this.outros;\n      removeFromArray(list, transition);\n      check(this);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.children.forEach(function (c) {\n        return c.start();\n      });\n      this.intros.concat(this.outros).forEach(function (t) {\n        return t.start();\n      });\n      this.ready = true;\n      check(this);\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\nfunction detach(element) {\n  element.detach();\n}\n\nfunction _detachNodes(tm) {\n  // _ to avoid transpiler quirk\n  tm.detachNodes();\n}\n\nfunction check(tm) {\n  if (!tm.ready || tm.outros.length || tm.outroChildren) return; // If all outros are complete, and we haven't already done this,\n  // we notify the parent if there is one, otherwise\n  // start detaching nodes\n\n  if (!tm.outrosComplete) {\n    tm.outrosComplete = true;\n\n    if (tm.parent && !tm.parent.outrosComplete) {\n      tm.parent.decrementOutros(tm);\n    } else {\n      tm.detachNodes();\n    }\n  } // Once everything is done, we can notify parent transition\n  // manager and call the callback\n\n\n  if (!tm.intros.length && !tm.totalChildren) {\n    if (typeof tm.callback === 'function') {\n      tm.callback();\n    }\n\n    if (tm.parent && !tm.notifiedTotal) {\n      tm.notifiedTotal = true;\n      tm.parent.decrementTotal();\n    }\n  }\n} // check through the detach queue to see if a node is up or downstream from a\n// transition and if not, go ahead and detach it\n\n\nfunction detachImmediate(manager) {\n  var queue = manager.detachQueue;\n  var outros = collectAllOutros(manager);\n  var i = queue.length;\n  var j = 0;\n  var node, trans;\n\n  start: while (i--) {\n    node = queue[i].node;\n    j = outros.length;\n\n    while (j--) {\n      trans = outros[j].element.node; // check to see if the node is, contains, or is contained by the transitioning node\n\n      if (trans === node || trans.contains(node) || node.contains(trans)) continue start;\n    } // no match, we can drop it\n\n\n    queue[i].detach();\n    queue.splice(i, 1);\n  }\n}\n\nfunction collectAllOutros(manager, _list) {\n  var list = _list; // if there's no list, we're starting at the root to build one\n\n  if (!list) {\n    list = [];\n    var parent = manager;\n\n    while (parent.parent) {\n      parent = parent.parent;\n    }\n\n    return collectAllOutros(parent, list);\n  } else {\n    // grab all outros from child managers\n    var _i7 = manager.children.length;\n\n    while (_i7--) {\n      list = collectAllOutros(manager.children[_i7], list);\n    } // grab any from this manager if there are any\n\n\n    if (manager.outros.length) list = list.concat(manager.outros);\n    return list;\n  }\n}\n\nvar batch;\nvar runloop = {\n  start: function start() {\n    var fulfilPromise;\n    var promise = new Promise(function (f) {\n      return fulfilPromise = f;\n    });\n    batch = {\n      previousBatch: batch,\n      transitionManager: new TransitionManager(fulfilPromise, batch && batch.transitionManager),\n      fragments: [],\n      tasks: [],\n      immediateObservers: [],\n      deferredObservers: [],\n      promise: promise\n    };\n    return promise;\n  },\n  end: function end() {\n    flushChanges();\n    if (!batch.previousBatch) batch.transitionManager.start();\n    batch = batch.previousBatch;\n  },\n  addFragment: function addFragment(fragment) {\n    addToArray(batch.fragments, fragment);\n  },\n  // TODO: come up with a better way to handle fragments that trigger their own update\n  addFragmentToRoot: function addFragmentToRoot(fragment) {\n    if (!batch) return;\n    var b = batch;\n\n    while (b.previousBatch) {\n      b = b.previousBatch;\n    }\n\n    addToArray(b.fragments, fragment);\n  },\n  addObserver: function addObserver(observer, defer) {\n    if (!batch) {\n      observer.dispatch();\n    } else {\n      addToArray(defer ? batch.deferredObservers : batch.immediateObservers, observer);\n    }\n  },\n  registerTransition: function registerTransition(transition) {\n    transition._manager = batch.transitionManager;\n    batch.transitionManager.add(transition);\n  },\n  // synchronise node detachments with transition ends\n  detachWhenReady: function detachWhenReady(thing) {\n    batch.transitionManager.detachQueue.push(thing);\n  },\n  scheduleTask: function scheduleTask(task, postRender) {\n    var _batch;\n\n    if (!batch) {\n      task();\n    } else {\n      _batch = batch;\n\n      while (postRender && _batch.previousBatch) {\n        // this can't happen until the DOM has been fully updated\n        // otherwise in some situations (with components inside elements)\n        // transitions and decorators will initialise prematurely\n        _batch = _batch.previousBatch;\n      }\n\n      _batch.tasks.push(task);\n    }\n  },\n  promise: function promise() {\n    if (!batch) return Promise.resolve();\n    var target = batch;\n\n    while (target.previousBatch) {\n      target = target.previousBatch;\n    }\n\n    return target.promise || Promise.resolve();\n  }\n};\n\nfunction dispatch(observer) {\n  observer.dispatch();\n}\n\nfunction flushChanges() {\n  var which = batch.immediateObservers;\n  batch.immediateObservers = [];\n  which.forEach(dispatch); // Now that changes have been fully propagated, we can update the DOM\n  // and complete other tasks\n\n  var i = batch.fragments.length;\n  var fragment;\n  which = batch.fragments;\n  batch.fragments = [];\n\n  while (i--) {\n    fragment = which[i];\n    fragment.update();\n  }\n\n  batch.transitionManager.ready();\n  which = batch.deferredObservers;\n  batch.deferredObservers = [];\n  which.forEach(dispatch);\n  var tasks = batch.tasks;\n  batch.tasks = [];\n\n  for (i = 0; i < tasks.length; i += 1) {\n    tasks[i]();\n  } // If updating the view caused some model blowback - e.g. a triple\n  // containing <option> elements caused the binding on the <select>\n  // to update - then we start over\n\n\n  if (batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.tasks.length) return flushChanges();\n} // TODO what happens if a transition is aborted?\n\n\nvar tickers = [];\nvar running = false;\n\nfunction tick() {\n  runloop.start();\n  var now = performance.now();\n  var i;\n  var ticker;\n\n  for (i = 0; i < tickers.length; i += 1) {\n    ticker = tickers[i];\n\n    if (!ticker.tick(now)) {\n      // ticker is complete, remove it from the stack, and decrement i so we don't miss one\n      tickers.splice(i--, 1);\n    }\n  }\n\n  runloop.end();\n\n  if (tickers.length) {\n    requestAnimationFrame(tick);\n  } else {\n    running = false;\n  }\n}\n\nvar Ticker =\n/*#__PURE__*/\nfunction () {\n  function Ticker(options) {\n    _classCallCheck(this, Ticker);\n\n    this.duration = options.duration;\n    this.step = options.step;\n    this.complete = options.complete;\n    this.easing = options.easing;\n    this.start = performance.now();\n    this.end = this.start + this.duration;\n    this.running = true;\n    tickers.push(this);\n    if (!running) requestAnimationFrame(tick);\n  }\n\n  _createClass(Ticker, [{\n    key: \"tick\",\n    value: function tick(now) {\n      if (!this.running) return false;\n\n      if (now > this.end) {\n        if (this.step) this.step(1);\n        if (this.complete) this.complete(1);\n        return false;\n      }\n\n      var elapsed = now - this.start;\n      var eased = this.easing(elapsed / this.duration);\n      if (this.step) this.step(eased);\n      return true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.abort) this.abort();\n      this.running = false;\n    }\n  }]);\n\n  return Ticker;\n}();\n\nvar prefixers = {}; // TODO this is legacy. sooner we can replace the old adaptor API the better\n\n/* istanbul ignore next */\n\nfunction prefixKeypath(obj, prefix) {\n  var prefixed = {};\n\n  if (!prefix) {\n    return obj;\n  }\n\n  prefix += '.';\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      prefixed[prefix + key] = obj[key];\n    }\n  }\n\n  return prefixed;\n}\n\nfunction getPrefixer(rootKeypath) {\n  var rootDot;\n\n  if (!prefixers[rootKeypath]) {\n    rootDot = rootKeypath ? rootKeypath + '.' : '';\n    /* istanbul ignore next */\n\n    prefixers[rootKeypath] = function (relativeKeypath, value) {\n      var obj;\n\n      if (typeof relativeKeypath === 'string') {\n        obj = {};\n        obj[rootDot + relativeKeypath] = value;\n        return obj;\n      }\n\n      if (_typeof(relativeKeypath) === 'object') {\n        // 'relativeKeypath' is in fact a hash, not a keypath\n        return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n      }\n    };\n  }\n\n  return prefixers[rootKeypath];\n}\n\nvar Model =\n/*#__PURE__*/\nfunction (_ModelBase2) {\n  _inherits(Model, _ModelBase2);\n\n  function Model(parent, key) {\n    var _this6;\n\n    _classCallCheck(this, Model);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Model).call(this, parent));\n    _this6.ticker = null;\n\n    if (parent) {\n      _this6.key = unescapeKey(key);\n      _this6.isReadonly = parent.isReadonly;\n\n      if (parent.value) {\n        _this6.value = parent.value[_this6.key];\n        if (Array.isArray(_this6.value)) _this6.length = _this6.value.length;\n\n        _this6.adapt();\n      }\n    }\n\n    return _this6;\n  }\n\n  _createClass(Model, [{\n    key: \"adapt\",\n    value: function adapt() {\n      var adaptors = this.root.adaptors;\n      var len = adaptors.length;\n      this.rewrap = false; // Exit early if no adaptors\n\n      if (len === 0) return;\n      var value = this.wrapper ? 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue : this.value; // TODO remove this legacy nonsense\n\n      var ractive = this.root.ractive;\n      var keypath = this.getKeypath(); // tear previous adaptor down if present\n\n      if (this.wrapper) {\n        var shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset(value) === false;\n\n        if (shouldTeardown) {\n          this.wrapper.teardown();\n          this.wrapper = null; // don't branch for undefined values\n\n          if (this.value !== undefined) {\n            var parentValue = this.parent.value || this.parent.createBranch(this.key);\n            if (parentValue[this.key] !== value) parentValue[this.key] = value;\n          }\n        } else {\n          delete this.newWrapperValue;\n          this.wrapperValue = value;\n          this.value = this.wrapper.get();\n          return;\n        }\n      }\n\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        var adaptor = adaptors[i];\n\n        if (adaptor.filter(value, keypath, ractive)) {\n          this.wrapper = adaptor.wrap(ractive, value, keypath, getPrefixer(keypath));\n          this.wrapperValue = value;\n          this.wrapper.__model = this; // massive temporary hack to enable array adaptor\n\n          this.value = this.wrapper.get();\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(from, to, options, interpolator) {\n      var _this7 = this;\n\n      if (this.ticker) this.ticker.stop();\n      var fulfilPromise;\n      var promise = new Promise(function (fulfil) {\n        return fulfilPromise = fulfil;\n      });\n      this.ticker = new Ticker({\n        duration: options.duration,\n        easing: options.easing,\n        step: function step(t) {\n          var value = interpolator(t);\n\n          _this7.applyValue(value);\n\n          if (options.step) options.step(t, value);\n        },\n        complete: function complete() {\n          _this7.applyValue(to);\n\n          if (options.complete) options.complete(to);\n          _this7.ticker = null;\n          fulfilPromise(to);\n        }\n      });\n      promise.stop = this.ticker.stop;\n      return promise;\n    }\n  }, {\n    key: \"applyValue\",\n    value: function applyValue(value) {\n      var notify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (isEqual(value, this.value)) return;\n      if (this.boundValue) this.boundValue = null;\n\n      if (this.parent.wrapper && this.parent.wrapper.set) {\n        this.parent.wrapper.set(this.key, value);\n        this.parent.value = this.parent.wrapper.get();\n        this.value = this.parent.value[this.key];\n        if (this.wrapper) this.newWrapperValue = this.value;\n        this.adapt();\n      } else if (this.wrapper) {\n        this.newWrapperValue = value;\n        this.adapt();\n      } else {\n        var parentValue = this.parent.value || this.parent.createBranch(this.key);\n\n        if (isObjectLike(parentValue)) {\n          parentValue[this.key] = value;\n        } else {\n          warnIfDebug(\"Attempted to set a property of a non-object '\".concat(this.getKeypath(), \"'\"));\n          return;\n        }\n\n        this.value = value;\n        this.adapt();\n      } // keep track of array stuff\n\n\n      if (Array.isArray(value)) {\n        this.length = value.length;\n        this.isArray = true;\n      } else {\n        this.isArray = false;\n      } // notify dependants\n\n\n      this.links.forEach(_handleChange);\n      this.children.forEach(_mark);\n      this.deps.forEach(_handleChange);\n      if (notify) this.notifyUpstream();\n\n      if (this.parent.isArray) {\n        if (this.key === 'length') this.parent.length = value;else this.parent.joinKey('length').mark();\n      }\n    }\n  }, {\n    key: \"createBranch\",\n    value: function createBranch(key) {\n      var branch = isNumeric(key) ? [] : {};\n      this.applyValue(branch, false);\n      return branch;\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture, opts) {\n      if (this._link) return this._link.get(shouldCapture, opts);\n      if (shouldCapture) capture(this); // if capturing, this value needs to be unwrapped because it's for external use\n\n      if (opts && opts.virtual) return this.getVirtual(false);\n      return maybeBind(this, (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper ? this.wrapperValue : this.value, !opts || opts.shouldBind !== false);\n    }\n  }, {\n    key: \"getKeypathModel\",\n    value: function getKeypathModel() {\n      if (!this.keypathModel) this.keypathModel = new KeypathModel(this);\n      return this.keypathModel;\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key, opts) {\n      if (this._link) {\n        if (opts && opts.lastLink !== false && (key === undefined || key === '')) return this;\n        return this._link.joinKey(key);\n      }\n\n      if (key === undefined || key === '') return this;\n\n      if (!this.childByKey.hasOwnProperty(key)) {\n        var _child6 = new Model(this, key);\n\n        this.children.push(_child6);\n        this.childByKey[key] = _child6;\n      }\n\n      if (this.childByKey[key]._link && (!opts || opts.lastLink !== false)) return this.childByKey[key]._link;\n      return this.childByKey[key];\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(force) {\n      if (this._link) return this._link.mark(force);\n      var old = this.value;\n      var value = this.retrieve();\n\n      if (force || !isEqual(value, old)) {\n        this.value = value;\n        if (this.boundValue) this.boundValue = null; // make sure the wrapper stays in sync\n\n        if (old !== value || this.rewrap) {\n          if (this.wrapper) this.newWrapperValue = value;\n          this.adapt();\n        } // keep track of array stuff\n\n\n        if (Array.isArray(value)) {\n          this.length = value.length;\n          this.isArray = true;\n        } else {\n          this.isArray = false;\n        }\n\n        this.children.forEach(force ? markForce : _mark);\n        this.links.forEach(_marked);\n        this.deps.forEach(_handleChange);\n      }\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(array, comparator) {\n      var oldArray = this.value;\n      var newArray = array;\n      if (oldArray === newArray) oldArray = recreateArray(this);\n\n      if (comparator) {\n        oldArray = oldArray.map(comparator);\n        newArray = newArray.map(comparator);\n      }\n\n      var oldLength = oldArray.length;\n      var usedIndices = {};\n      var firstUnusedIndex = 0;\n      var newIndices = oldArray.map(function (item) {\n        var index;\n        var start = firstUnusedIndex;\n\n        do {\n          index = newArray.indexOf(item, start);\n\n          if (index === -1) {\n            return -1;\n          }\n\n          start = index + 1;\n        } while (usedIndices[index] === true && start < oldLength); // keep track of the first unused index, so we don't search\n        // the whole of newArray for each item in oldArray unnecessarily\n\n\n        if (index === firstUnusedIndex) {\n          firstUnusedIndex += 1;\n        } // allow next instance of next \"equal\" to be found item\n\n\n        usedIndices[index] = true;\n        return index;\n      });\n      this.parent.value[this.key] = array;\n      this.shuffle(newIndices, true);\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      return this.parent.value ? this.parent.value[this.key] : undefined;\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      if (this.ticker) this.ticker.stop();\n      this.applyValue(value);\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices, unsafe) {\n      _shuffle(this, newIndices, false, unsafe);\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      return this;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      if (this._link) this._link.teardown();\n      this.children.forEach(_teardown);\n      if (this.wrapper) this.wrapper.teardown();\n      if (this.keypathModel) this.keypathModel.teardown();\n    }\n  }]);\n\n  return Model;\n}(ModelBase);\n\nfunction recreateArray(model) {\n  var array = [];\n\n  for (var _i8 = 0; _i8 < model.length; _i8++) {\n    array[_i8] = (model.childByKey[_i8] || {}).value;\n  }\n\n  return array;\n}\n/* global global */\n\n\nvar data = {};\n\nvar SharedModel =\n/*#__PURE__*/\nfunction (_Model) {\n  _inherits(SharedModel, _Model);\n\n  function SharedModel(value, name) {\n    var _this8;\n\n    _classCallCheck(this, SharedModel);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(SharedModel).call(this, null, \"@\".concat(name)));\n    _this8.key = \"@\".concat(name);\n    _this8.value = value;\n    _this8.isRoot = true;\n    _this8.root = _assertThisInitialized(_this8);\n    _this8.adaptors = [];\n    return _this8;\n  }\n\n  _createClass(SharedModel, [{\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return this.key;\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      return this.value;\n    }\n  }]);\n\n  return SharedModel;\n}(Model);\n\nvar SharedModel$1 = new SharedModel(data, 'shared');\nvar GlobalModel = new SharedModel(typeof global !== 'undefined' ? global : window, 'global');\n\nfunction resolveReference(fragment, ref) {\n  var initialFragment = fragment; // current context ref\n\n  if (ref === '.') return fragment.findContext(); // ancestor references\n\n  if (ref[0] === '~') return fragment.ractive.viewmodel.joinAll(splitKeypath(ref.slice(2))); // scoped references\n\n  if (ref[0] === '.' || ref[0] === '^') {\n    var frag = fragment;\n    var parts = ref.split('/');\n    var explicitContext = parts[0] === '^^';\n\n    var _context = explicitContext ? null : fragment.findContext(); // account for the first context hop\n\n\n    if (explicitContext) parts.unshift('^^'); // walk up the context chain\n\n    while (parts[0] === '^^') {\n      parts.shift();\n      _context = null;\n\n      while (frag && !_context) {\n        _context = frag.context;\n        frag = frag.parent.component ? frag.parent.component.parentFragment : frag.parent;\n      }\n    }\n\n    if (!_context && explicitContext) {\n      throw new Error(\"Invalid context parent reference ('\".concat(ref, \"'). There is not context at that level.\"));\n    } // walk up the context path\n\n\n    while (parts[0] === '.' || parts[0] === '..') {\n      var part = parts.shift();\n\n      if (part === '..') {\n        _context = _context.parent;\n      }\n    }\n\n    ref = parts.join('/'); // special case - `{{.foo}}` means the same as `{{./foo}}`\n\n    if (ref[0] === '.') ref = ref.slice(1);\n    return _context.joinAll(splitKeypath(ref));\n  }\n\n  var keys = splitKeypath(ref);\n  if (!keys.length) return;\n  var base = keys.shift(); // special refs\n\n  if (base[0] === '@') {\n    // shorthand from outside the template\n    // @this referring to local ractive instance\n    if (base === '@this' || base === '@') {\n      return fragment.ractive.viewmodel.getRactiveModel().joinAll(keys);\n    } // @index or @key referring to the nearest repeating index or key\n    else if (base === '@index' || base === '@key') {\n        if (keys.length) badReference(base);\n        var repeater = fragment.findRepeatingFragment(); // make sure the found fragment is actually an iteration\n\n        if (!repeater.isIteration) return;\n        return repeater.context && repeater.context.getKeyModel(repeater[ref[1] === 'i' ? 'index' : 'key']);\n      } // @global referring to window or global\n      else if (base === '@global') {\n          return GlobalModel.joinAll(keys);\n        } // @global referring to window or global\n        else if (base === '@shared') {\n            return SharedModel$1.joinAll(keys);\n          } // @keypath or @rootpath, the current keypath string\n          else if (base === '@keypath' || base === '@rootpath') {\n              var root = ref[1] === 'r' ? fragment.ractive.root : null;\n\n              var _context2 = fragment.findContext(); // skip over component roots, which provide no context\n\n\n              while (root && _context2.isRoot && _context2.ractive.component) {\n                _context2 = _context2.ractive.component.parentFragment.findContext();\n              }\n\n              return _context2.getKeypathModel(root);\n            } else if (base === '@context') {\n              return new ContextModel(fragment.getContext());\n            } // @context-local data\n            else if (base === '@local') {\n                return fragment.getContext()._data.joinAll(keys);\n              } // @style shared model\n              else if (base === '@style') {\n                  return fragment.ractive.constructor._cssModel.joinAll(keys);\n                } // nope\n                else {\n                    throw new Error(\"Invalid special reference '\".concat(base, \"'\"));\n                  }\n  }\n\n  var context = fragment.findContext(); // check immediate context for a match\n\n  if (context.has(base)) {\n    return context.joinKey(base).joinAll(keys);\n  } // walk up the fragment hierarchy looking for a matching ref, alias, or key in a context\n\n\n  var createMapping = false;\n  var shouldWarn = fragment.ractive.warnAboutAmbiguity;\n\n  while (fragment) {\n    // repeated fragments\n    if (fragment.isIteration) {\n      if (base === fragment.parent.keyRef) {\n        if (keys.length) badReference(base);\n        return fragment.context.getKeyModel(fragment.key);\n      }\n\n      if (base === fragment.parent.indexRef) {\n        if (keys.length) badReference(base);\n        return fragment.context.getKeyModel(fragment.index);\n      }\n    } // alias node or iteration\n\n\n    if (fragment.aliases && fragment.aliases.hasOwnProperty(base)) {\n      var model = fragment.aliases[base];\n      if (keys.length === 0) return model;else if (typeof model.joinAll === 'function') {\n        return model.joinAll(keys);\n      }\n    } // check fragment context to see if it has the key we need\n\n\n    if (fragment.context && fragment.context.has(base)) {\n      // this is an implicit mapping\n      if (createMapping) {\n        if (shouldWarn) warnIfDebug(\"'\".concat(ref, \"' resolved but is ambiguous and will create a mapping to a parent component.\"));\n        return context.root.createLink(base, fragment.context.joinKey(base), base, {\n          implicit: true\n        }).joinAll(keys);\n      }\n\n      if (shouldWarn) warnIfDebug(\"'\".concat(ref, \"' resolved but is ambiguous.\"));\n      return fragment.context.joinKey(base).joinAll(keys);\n    }\n\n    if ((fragment.componentParent || !fragment.parent && fragment.ractive.component) && !fragment.ractive.isolated) {\n      // ascend through component boundary\n      fragment = fragment.componentParent || fragment.ractive.component.parentFragment;\n      createMapping = true;\n    } else {\n      fragment = fragment.parent;\n    }\n  } // if enabled, check the instance for a match\n\n\n  var instance = initialFragment.ractive;\n\n  if (instance.resolveInstanceMembers && base !== 'data' && base in instance) {\n    return instance.viewmodel.getRactiveModel().joinKey(base).joinAll(keys);\n  }\n\n  if (shouldWarn) {\n    warnIfDebug(\"'\".concat(ref, \"' is ambiguous and did not resolve.\"));\n  } // didn't find anything, so go ahead and create the key on the local model\n\n\n  return context.joinKey(base).joinAll(keys);\n}\n\nfunction badReference(key) {\n  throw new Error(\"An index or key reference (\".concat(key, \") cannot have child properties\"));\n}\n\nvar ContextModel =\n/*#__PURE__*/\nfunction () {\n  function ContextModel(context) {\n    _classCallCheck(this, ContextModel);\n\n    this.context = context;\n  }\n\n  _createClass(ContextModel, [{\n    key: \"get\",\n    value: function get() {\n      return this.context;\n    }\n  }]);\n\n  return ContextModel;\n}();\n\nvar extern = {};\n\nfunction getRactiveContext(ractive) {\n  var fragment = ractive.fragment || ractive._fakeFragment || (ractive._fakeFragment = new FakeFragment(ractive));\n\n  for (var _len5 = arguments.length, assigns = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    assigns[_key5 - 1] = arguments[_key5];\n  }\n\n  return fragment.getContext.apply(fragment, assigns);\n}\n\nfunction getContext() {\n  if (!this.ctx) this.ctx = new extern.Context(this);\n\n  for (var _len6 = arguments.length, assigns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    assigns[_key6] = arguments[_key6];\n  }\n\n  assigns.unshift(Object.create(this.ctx));\n  return Object.assign.apply(null, assigns);\n}\n\nvar FakeFragment =\n/*#__PURE__*/\nfunction () {\n  function FakeFragment(ractive) {\n    _classCallCheck(this, FakeFragment);\n\n    this.ractive = ractive;\n  }\n\n  _createClass(FakeFragment, [{\n    key: \"findContext\",\n    value: function findContext() {\n      return this.ractive.viewmodel;\n    }\n  }]);\n\n  return FakeFragment;\n}();\n\nvar proto$1 = FakeFragment.prototype;\nproto$1.getContext = getContext;\nproto$1.find = proto$1.findComponent = proto$1.findAll = proto$1.findAllComponents = noop;\n\nfunction findParentWithContext(fragment) {\n  var frag = fragment;\n\n  while (frag && !frag.context) {\n    frag = frag.parent;\n  }\n\n  if (!frag) return fragment && fragment.ractive.fragment;else return frag;\n}\n\nvar keep = false;\n\nfunction _set(pairs, options) {\n  var k = keep;\n  var deep = options && options.deep;\n  var shuffle = options && options.shuffle;\n  var promise = runloop.start();\n  if (options && 'keep' in options) keep = options.keep;\n  var i = pairs.length;\n\n  while (i--) {\n    var model = pairs[i][0];\n    var _value3 = pairs[i][1];\n    var keypath = pairs[i][2];\n\n    if (!model) {\n      runloop.end();\n      throw new Error(\"Failed to set invalid keypath '\".concat(keypath, \"'\"));\n    }\n\n    if (deep) deepSet(model, _value3);else if (shuffle) {\n      var array = _value3;\n      var target = model.get(); // shuffle target array with itself\n\n      if (!array) array = target; // if there's not an array there yet, go ahead and set\n\n      if (target === undefined) {\n        model.set(array);\n      } else {\n        if (!Array.isArray(target) || !Array.isArray(array)) {\n          runloop.end();\n          throw new Error('You cannot merge an array with a non-array');\n        }\n\n        var comparator = getComparator(shuffle);\n        model.merge(array, comparator);\n      }\n    } else model.set(_value3);\n  }\n\n  runloop.end();\n  keep = k;\n  return promise;\n}\n\nvar star = /\\*/;\n\nfunction gather(ractive, keypath, base, isolated) {\n  if (!base && (keypath[0] === '.' || keypath[1] === '^')) {\n    warnIfDebug(\"Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths.\");\n    return [];\n  }\n\n  var keys = splitKeypath(keypath);\n  var model = base || ractive.viewmodel;\n\n  if (star.test(keypath)) {\n    return model.findMatches(keys);\n  } else {\n    if (model === ractive.viewmodel) {\n      // allow implicit mappings\n      if (ractive.component && !ractive.isolated && !model.has(keys[0]) && keypath[0] !== '@' && keypath[0] && !isolated) {\n        return [resolveReference(ractive.fragment || new FakeFragment(ractive), keypath)];\n      } else {\n        return [model.joinAll(keys)];\n      }\n    } else {\n      return [model.joinAll(keys)];\n    }\n  }\n}\n\nfunction build(ractive, keypath, value, isolated) {\n  var sets = []; // set multiple keypaths in one go\n\n  if (isObject(keypath)) {\n    var _loop3 = function _loop3(k) {\n      if (keypath.hasOwnProperty(k)) {\n        sets.push.apply(sets, gather(ractive, k, null, isolated).map(function (m) {\n          return [m, keypath[k], k];\n        }));\n      }\n    };\n\n    for (var k in keypath) {\n      _loop3(k);\n    }\n  } // set a single keypath\n  else {\n      sets.push.apply(sets, gather(ractive, keypath, null, isolated).map(function (m) {\n        return [m, value, keypath];\n      }));\n    }\n\n  return sets;\n}\n\nvar deepOpts = {\n  virtual: false\n};\n\nfunction deepSet(model, value) {\n  var dest = model.get(false, deepOpts); // if dest doesn't exist, just set it\n\n  if (dest == null || _typeof(value) !== 'object') return model.set(value);\n  if (_typeof(dest) !== 'object') return model.set(value);\n\n  for (var k in value) {\n    if (value.hasOwnProperty(k)) {\n      deepSet(model.joinKey(k), value[k]);\n    }\n  }\n}\n\nvar comparators = {};\n\nfunction getComparator(option) {\n  if (option === true) return null; // use existing arrays\n\n  if (typeof option === 'function') return option;\n\n  if (typeof option === 'string') {\n    return comparators[option] || (comparators[option] = function (thing) {\n      return thing[option];\n    });\n  }\n\n  throw new Error('If supplied, options.compare must be a string, function, or true'); // TODO link to docs\n}\n\nvar errorMessage = 'Cannot add to a non-numeric value';\n\nfunction add(ractive, keypath, d, options) {\n  if (typeof keypath !== 'string' || !isNumeric(d)) {\n    throw new Error('Bad arguments');\n  }\n\n  var sets = build(ractive, keypath, d, options && options.isolated);\n  return _set(sets.map(function (pair) {\n    var _pair = _slicedToArray(pair, 2),\n        model = _pair[0],\n        add = _pair[1];\n\n    var value = model.get();\n    if (!isNumeric(add) || !isNumeric(value)) throw new Error(errorMessage);\n    return [model, value + add];\n  }));\n}\n\nfunction Ractive$add(keypath, d, options) {\n  var num = typeof d === 'number' ? d : 1;\n  var opts = _typeof(d) === 'object' ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction immediate(value) {\n  var promise = Promise.resolve(value);\n  Object.defineProperty(promise, 'stop', {\n    value: noop\n  });\n  return promise;\n}\n\nvar linear = easing.linear;\n\nfunction getOptions(options, instance) {\n  options = options || {};\n  var easing$$1;\n\n  if (options.easing) {\n    easing$$1 = typeof options.easing === 'function' ? options.easing : instance.easing[options.easing];\n  }\n\n  return {\n    easing: easing$$1 || linear,\n    duration: 'duration' in options ? options.duration : 400,\n    complete: options.complete || noop,\n    step: options.step || noop,\n    interpolator: options.interpolator\n  };\n}\n\nfunction _animate(ractive, model, to, options) {\n  options = getOptions(options, ractive);\n  var from = model.get(); // don't bother animating values that stay the same\n\n  if (isEqual(from, to)) {\n    options.complete(options.to);\n    return immediate(to);\n  }\n\n  var interpolator = interpolate(from, to, ractive, options.interpolator); // if we can't interpolate the value, set it immediately\n\n  if (!interpolator) {\n    runloop.start();\n    model.set(to);\n    runloop.end();\n    return immediate(to);\n  }\n\n  return model.animate(from, to, options, interpolator);\n}\n\nfunction Ractive$animate(keypath, to, options) {\n  if (_typeof(keypath) === 'object') {\n    var keys = Object.keys(keypath);\n    throw new Error(\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \".concat(keys.map(function (key) {\n      return \"'\".concat(key, \"': \").concat(keypath[key]);\n    }).join('\\n  '), \"\\n}, {...}), do\\n\\n\").concat(keys.map(function (key) {\n      return \"ractive.animate('\".concat(key, \"', \").concat(keypath[key], \", {...});\");\n    }).join('\\n'), \"\\n\"));\n  }\n\n  return _animate(this, this.viewmodel.joinAll(splitKeypath(keypath)), to, options);\n}\n\nfunction enqueue(ractive, event) {\n  if (ractive.event) {\n    ractive._eventQueue.push(ractive.event);\n  }\n\n  ractive.event = event;\n}\n\nfunction dequeue(ractive) {\n  if (ractive._eventQueue.length) {\n    ractive.event = ractive._eventQueue.pop();\n  } else {\n    ractive.event = null;\n  }\n}\n\nvar initStars = {};\nvar bubbleStars = {}; // cartesian product of name parts and stars\n// adjusted appropriately for special cases\n\nfunction variants(name, initial) {\n  var map = initial ? initStars : bubbleStars;\n  if (map[name]) return map[name];\n  var parts = name.split('.');\n  var result = [];\n  var base = false; // initial events the implicit namespace of 'this'\n\n  if (initial) {\n    parts.unshift('this');\n    base = true;\n  } // use max - 1 bits as a bitmap to pick a part or a *\n  // need to skip the full star case if the namespace is synthetic\n\n\n  var max = Math.pow(2, parts.length) - (initial ? 1 : 0);\n\n  for (var _i9 = 0; _i9 < max; _i9++) {\n    var join = [];\n\n    for (var _j = 0; _j < parts.length; _j++) {\n      join.push(1 & _i9 >> _j ? '*' : parts[_j]);\n    }\n\n    result.unshift(join.join('.'));\n  }\n\n  if (base) {\n    // include non-this-namespaced versions\n    if (parts.length > 2) {\n      result.push.apply(result, variants(name, false));\n    } else {\n      result.push('*');\n      result.push(name);\n    }\n  }\n\n  map[name] = result;\n  return result;\n}\n\nfunction fireEvent(ractive, eventName, context) {\n  var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  if (!eventName) {\n    return;\n  }\n\n  context.name = eventName;\n  args.unshift(context);\n  var eventNames = ractive._nsSubs ? variants(eventName, true) : ['*', eventName];\n  return fireEventAs(ractive, eventNames, context, args, true);\n}\n\nfunction fireEventAs(ractive, eventNames, context, args) {\n  var initialFire = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var bubble = true;\n\n  if (initialFire || ractive._nsSubs) {\n    enqueue(ractive, context);\n    var _i10 = eventNames.length;\n\n    while (_i10--) {\n      if (eventNames[_i10] in ractive._subs) {\n        bubble = notifySubscribers(ractive, ractive._subs[eventNames[_i10]], context, args) && bubble;\n      }\n    }\n\n    dequeue(ractive);\n  }\n\n  if (ractive.parent && bubble) {\n    if (initialFire && ractive.component) {\n      var fullName = ractive.component.name + '.' + eventNames[eventNames.length - 1];\n      eventNames = variants(fullName, false);\n\n      if (context && !context.component) {\n        context.component = ractive;\n      }\n    }\n\n    bubble = fireEventAs(ractive.parent, eventNames, context, args);\n  }\n\n  return bubble;\n}\n\nfunction notifySubscribers(ractive, subscribers, context, args) {\n  var originalEvent = null;\n  var stopEvent = false; // subscribers can be modified inflight, e.g. \"once\" functionality\n  // so we need to copy to make sure everyone gets called\n\n  subscribers = subscribers.slice();\n\n  for (var _i11 = 0, len = subscribers.length; _i11 < len; _i11 += 1) {\n    if (!subscribers[_i11].off && subscribers[_i11].handler.apply(ractive, args) === false) {\n      stopEvent = true;\n    }\n  }\n\n  if (context && stopEvent && (originalEvent = context.event)) {\n    originalEvent.preventDefault && originalEvent.preventDefault();\n    originalEvent.stopPropagation && originalEvent.stopPropagation();\n  }\n\n  return !stopEvent;\n}\n\nvar Hook =\n/*#__PURE__*/\nfunction () {\n  function Hook(event) {\n    _classCallCheck(this, Hook);\n\n    this.event = event;\n    this.method = 'on' + event;\n  }\n\n  _createClass(Hook, [{\n    key: \"fire\",\n    value: function fire(ractive, arg) {\n      var context = getRactiveContext(ractive);\n\n      if (ractive[this.method]) {\n        arg ? ractive[this.method](context, arg) : ractive[this.method](context);\n      }\n\n      fireEvent(ractive, this.event, context, arg ? [arg, ractive] : [ractive]);\n    }\n  }]);\n\n  return Hook;\n}();\n\nfunction findAnchors(fragment) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var res = [];\n  findAnchorsIn(fragment, name, res);\n  return res;\n}\n\nfunction findAnchorsIn(item, name, result) {\n  if (item.isAnchor) {\n    if (!name || item.name === name) {\n      result.push(item);\n    }\n  } else if (item.items) {\n    item.items.forEach(function (i) {\n      return findAnchorsIn(i, name, result);\n    });\n  } else if (item.iterations) {\n    item.iterations.forEach(function (i) {\n      return findAnchorsIn(i, name, result);\n    });\n  } else if (item.fragment && !item.component) {\n    findAnchorsIn(item.fragment, name, result);\n  }\n}\n\nfunction updateAnchors(instance) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var anchors = findAnchors(instance.fragment, name);\n  var idxs = {};\n  var children = instance._children.byName;\n  anchors.forEach(function (a) {\n    var name = a.name;\n    if (!(name in idxs)) idxs[name] = 0;\n    var idx = idxs[name];\n    var child = (children[name] || [])[idx];\n\n    if (child && child.lastBound !== a) {\n      if (child.lastBound) child.lastBound.removeChild(child);\n      a.addChild(child);\n    }\n\n    idxs[name]++;\n  });\n}\n\nfunction unrenderChild(meta) {\n  if (meta.instance.fragment.rendered) {\n    meta.shouldDestroy = true;\n    meta.instance.unrender();\n  }\n\n  meta.instance.el = null;\n}\n\nvar attachHook = new Hook('attachchild');\n\nfunction attachChild(child) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var children = this._children;\n  var idx;\n  if (child.parent && child.parent !== this) throw new Error(\"Instance \".concat(child._guid, \" is already attached to a different instance \").concat(child.parent._guid, \". Please detach it from the other instance using detachChild first.\"));else if (child.parent) throw new Error(\"Instance \".concat(child._guid, \" is already attached to this instance.\"));\n  var meta = {\n    instance: child,\n    ractive: this,\n    name: options.name || child.constructor.name || 'Ractive',\n    target: options.target || false,\n    bubble: bubble,\n    findNextNode: findNextNode\n  };\n  meta.nameOption = options.name; // child is managing itself\n\n  if (!meta.target) {\n    meta.parentFragment = this.fragment;\n    meta.external = true;\n  } else {\n    var list;\n\n    if (!(list = children.byName[meta.target])) {\n      list = [];\n      this.set(\"@this.children.byName.\".concat(meta.target), list);\n    }\n\n    idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;\n  }\n\n  child.set({\n    '@this.parent': this,\n    '@this.root': this.root\n  });\n  child.component = meta;\n  children.push(meta);\n  attachHook.fire(child);\n  var promise = runloop.start();\n\n  if (meta.target) {\n    unrenderChild(meta);\n    this.splice(\"@this.children.byName.\".concat(meta.target), idx, 0, meta);\n    updateAnchors(this, meta.target);\n  } else {\n    if (!child.isolated) child.viewmodel.attached(this.fragment);\n  }\n\n  runloop.end();\n  promise.ractive = child;\n  return promise.then(function () {\n    return child;\n  });\n}\n\nfunction bubble() {\n  runloop.addFragment(this.instance.fragment);\n}\n\nfunction findNextNode() {\n  if (this.anchor) return this.anchor.findNextNode();\n}\n\nvar detachHook = new Hook('detach');\n\nfunction Ractive$detach() {\n  if (this.isDetached) {\n    return this.el;\n  }\n\n  if (this.el) {\n    removeFromArray(this.el.__ractive_instances__, this);\n  }\n\n  this.el = this.fragment.detach();\n  this.isDetached = true;\n  detachHook.fire(this);\n  return this.el;\n}\n\nvar detachHook$1 = new Hook('detachchild');\n\nfunction detachChild(child) {\n  var children = this._children;\n  var meta, index;\n  var i = children.length;\n\n  while (i--) {\n    if (children[i].instance === child) {\n      index = i;\n      meta = children[i];\n      break;\n    }\n  }\n\n  if (!meta || child.parent !== this) throw new Error(\"Instance \".concat(child._guid, \" is not attached to this instance.\"));\n  var promise = runloop.start();\n  if (meta.anchor) meta.anchor.removeChild(meta);\n  if (!child.isolated) child.viewmodel.detached();\n  runloop.end();\n  children.splice(index, 1);\n\n  if (meta.target) {\n    this.splice(\"@this.children.byName.\".concat(meta.target), children.byName[meta.target].indexOf(meta), 1);\n    updateAnchors(this, meta.target);\n  }\n\n  child.set({\n    '@this.parent': undefined,\n    '@this.root': child\n  });\n  child.component = null;\n  detachHook$1.fire(child);\n  promise.ractive = child;\n  return promise.then(function () {\n    return child;\n  });\n}\n\nfunction Ractive$find(selector) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!this.el) throw new Error(\"Cannot call ractive.find('\".concat(selector, \"') unless instance is rendered to the DOM\"));\n  var node = this.fragment.find(selector, options);\n  if (node) return node;\n\n  if (options.remote) {\n    for (var _i12 = 0; _i12 < this._children.length; _i12++) {\n      if (!this._children[_i12].instance.fragment.rendered) continue;\n      node = this._children[_i12].instance.find(selector, options);\n      if (node) return node;\n    }\n  }\n}\n\nfunction Ractive$findAll(selector) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!this.el) throw new Error(\"Cannot call ractive.findAll('\".concat(selector, \"', ...) unless instance is rendered to the DOM\"));\n  if (!Array.isArray(options.result)) options.result = [];\n  this.fragment.findAll(selector, options);\n\n  if (options.remote) {\n    // seach non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        c.instance.findAll(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findAllComponents(selector, options) {\n  if (!options && _typeof(selector) === 'object') {\n    options = selector;\n    selector = '';\n  }\n\n  options = options || {};\n  if (!Array.isArray(options.result)) options.result = [];\n  this.fragment.findAllComponents(selector, options);\n\n  if (options.remote) {\n    // search non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        if (!selector || c.name === selector) {\n          options.result.push(c.instance);\n        }\n\n        c.instance.findAllComponents(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findComponent(selector) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (_typeof(selector) === 'object') {\n    options = selector;\n    selector = '';\n  }\n\n  var child = this.fragment.findComponent(selector, options);\n  if (child) return child;\n\n  if (options.remote) {\n    if (!selector && this._children.length) return this._children[0].instance;\n\n    for (var _i13 = 0; _i13 < this._children.length; _i13++) {\n      // skip children that are or should be in an anchor\n      if (this._children[_i13].target) continue;\n      if (this._children[_i13].name === selector) return this._children[_i13].instance;\n      child = this._children[_i13].instance.findComponent(selector, options);\n      if (child) return child;\n    }\n  }\n}\n\nfunction Ractive$findContainer(selector) {\n  if (this.container) {\n    if (this.container.component && this.container.component.name === selector) {\n      return this.container;\n    } else {\n      return this.container.findContainer(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction Ractive$findParent(selector) {\n  if (this.parent) {\n    if (this.parent.component && this.parent.component.name === selector) {\n      return this.parent;\n    } else {\n      return this.parent.findParent(selector);\n    }\n  }\n\n  return null;\n}\n\nvar TEXT = 1;\nvar INTERPOLATOR = 2;\nvar TRIPLE = 3;\nvar SECTION = 4;\nvar INVERTED = 5;\nvar CLOSING = 6;\nvar ELEMENT = 7;\nvar PARTIAL = 8;\nvar COMMENT = 9;\nvar DELIMCHANGE = 10;\nvar ANCHOR = 11;\nvar ATTRIBUTE = 13;\nvar CLOSING_TAG = 14;\nvar COMPONENT = 15;\nvar YIELDER = 16;\nvar INLINE_PARTIAL = 17;\nvar DOCTYPE = 18;\nvar ALIAS = 19;\nvar NUMBER_LITERAL = 20;\nvar STRING_LITERAL = 21;\nvar ARRAY_LITERAL = 22;\nvar OBJECT_LITERAL = 23;\nvar BOOLEAN_LITERAL = 24;\nvar REGEXP_LITERAL = 25;\nvar GLOBAL = 26;\nvar KEY_VALUE_PAIR = 27;\nvar REFERENCE = 30;\nvar REFINEMENT = 31;\nvar MEMBER = 32;\nvar PREFIX_OPERATOR = 33;\nvar BRACKETED = 34;\nvar CONDITIONAL = 35;\nvar INFIX_OPERATOR = 36;\nvar INVOCATION = 40;\nvar SECTION_IF = 50;\nvar SECTION_UNLESS = 51;\nvar SECTION_EACH = 52;\nvar SECTION_WITH = 53;\nvar SECTION_IF_WITH = 54;\nvar ELSE = 60;\nvar ELSEIF = 61;\nvar EVENT = 70;\nvar DECORATOR = 71;\nvar TRANSITION = 72;\nvar BINDING_FLAG = 73;\nvar DELEGATE_FLAG = 74;\n\nfunction findElement(start) {\n  var orComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var name = arguments.length > 2 ? arguments[2] : undefined;\n\n  while (start && (start.type !== ELEMENT || name && start.name !== name) && (!orComponent || start.type !== COMPONENT && start.type !== ANCHOR)) {\n    // start is a fragment - look at the owner\n    if (start.owner) start = start.owner; // start is a component or yielder - look at the container\n    else if (start.component) start = start.containerFragment || start.component.parentFragment; // start is an item - look at the parent\n      else if (start.parent) start = start.parent; // start is an item without a parent - look at the parent fragment\n        else if (start.parentFragment) start = start.parentFragment;else start = undefined;\n  }\n\n  return start;\n} // This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n\nfunction getNewIndices(length, methodName, args) {\n  var newIndices = [];\n  var spliceArguments = getSpliceEquivalent(length, methodName, args);\n\n  if (!spliceArguments) {\n    return null; // TODO support reverse and sort?\n  }\n\n  var balance = spliceArguments.length - 2 - spliceArguments[1];\n  var removeStart = Math.min(length, spliceArguments[0]);\n  var removeEnd = removeStart + spliceArguments[1];\n  newIndices.startIndex = removeStart;\n  var i;\n\n  for (i = 0; i < removeStart; i += 1) {\n    newIndices.push(i);\n  }\n\n  for (; i < removeEnd; i += 1) {\n    newIndices.push(-1);\n  }\n\n  for (; i < length; i += 1) {\n    newIndices.push(i + balance);\n  } // there is a net shift for the rest of the array starting with index + balance\n\n\n  if (balance !== 0) {\n    newIndices.touchedFrom = spliceArguments[0];\n  } else {\n    newIndices.touchedFrom = length;\n  }\n\n  return newIndices;\n} // The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\n\n\nfunction getSpliceEquivalent(length, methodName, args) {\n  switch (methodName) {\n    case 'splice':\n      if (args[0] !== undefined && args[0] < 0) {\n        args[0] = length + Math.max(args[0], -length);\n      }\n\n      if (args[0] === undefined) args[0] = 0;\n\n      while (args.length < 2) {\n        args.push(length - args[0]);\n      }\n\n      if (typeof args[1] !== 'number') {\n        args[1] = length - args[0];\n      } // ensure we only remove elements that exist\n\n\n      args[1] = Math.min(args[1], length - args[0]);\n      return args;\n\n    case 'sort':\n    case 'reverse':\n      return null;\n\n    case 'pop':\n      if (length) {\n        return [length - 1, 1];\n      }\n\n      return [0, 0];\n\n    case 'push':\n      return [length, 0].concat(args);\n\n    case 'shift':\n      return [0, length ? 1 : 0];\n\n    case 'unshift':\n      return [0, 0].concat(args);\n  }\n}\n\nvar arrayProto = Array.prototype;\n\nvar makeArrayMethod = function makeArrayMethod(methodName) {\n  function path(keypath) {\n    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      args[_key7 - 1] = arguments[_key7];\n    }\n\n    return model(this.viewmodel.joinAll(splitKeypath(keypath)), args);\n  }\n\n  function model(mdl, args) {\n    var array = mdl.get();\n\n    if (!Array.isArray(array)) {\n      if (array === undefined) {\n        array = [];\n\n        var _result = arrayProto[methodName].apply(array, args);\n\n        var _promise = runloop.start().then(function () {\n          return _result;\n        });\n\n        mdl.set(array);\n        runloop.end();\n        return _promise;\n      } else {\n        throw new Error(\"shuffle array method \".concat(methodName, \" called on non-array at \").concat(mdl.getKeypath()));\n      }\n    }\n\n    var newIndices = getNewIndices(array.length, methodName, args);\n    var result = arrayProto[methodName].apply(array, args);\n    var promise = runloop.start().then(function () {\n      return result;\n    });\n    promise.result = result;\n\n    if (newIndices) {\n      mdl.shuffle(newIndices);\n    } else {\n      mdl.set(result);\n    }\n\n    runloop.end();\n    return promise;\n  }\n\n  return {\n    path: path,\n    model: model\n  };\n};\n\nvar updateHook = new Hook('update');\n\nfunction update$1(ractive, model, options) {\n  // if the parent is wrapped, the adaptor will need to be updated before\n  // updating on this keypath\n  if (model.parent && model.parent.wrapper) {\n    model.parent.adapt();\n  }\n\n  var promise = runloop.start();\n  model.mark(options && options.force); // notify upstream of changes\n\n  model.notifyUpstream();\n  runloop.end();\n  updateHook.fire(ractive, model);\n  return promise;\n}\n\nfunction Ractive$update(keypath, options) {\n  var opts, path;\n\n  if (typeof keypath === 'string') {\n    path = splitKeypath(keypath);\n    opts = options;\n  } else {\n    opts = keypath;\n  }\n\n  return update$1(this, path ? this.viewmodel.joinAll(path) : this.viewmodel, opts);\n}\n\nvar modelPush = makeArrayMethod('push').model;\nvar modelPop = makeArrayMethod('pop').model;\nvar modelShift = makeArrayMethod('shift').model;\nvar modelUnshift = makeArrayMethod('unshift').model;\nvar modelSort = makeArrayMethod('sort').model;\nvar modelSplice = makeArrayMethod('splice').model;\nvar modelReverse = makeArrayMethod('reverse').model;\n\nvar ContextData =\n/*#__PURE__*/\nfunction (_Model2) {\n  _inherits(ContextData, _Model2);\n\n  function ContextData(options) {\n    var _this9;\n\n    _classCallCheck(this, ContextData);\n\n    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(ContextData).call(this, null, null));\n    _this9.isRoot = true;\n    _this9.root = _assertThisInitialized(_this9);\n    _this9.value = {};\n    _this9.ractive = options.ractive;\n    _this9.adaptors = [];\n    _this9.context = options.context;\n    return _this9;\n  }\n\n  _createClass(ContextData, [{\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return '@context.data';\n    }\n  }]);\n\n  return ContextData;\n}(Model);\n\nvar Context =\n/*#__PURE__*/\nfunction () {\n  function Context(fragment, element) {\n    _classCallCheck(this, Context);\n\n    this.fragment = fragment;\n    this.element = element || findElement(fragment);\n    this.node = this.element && this.element.node;\n    this.ractive = fragment.ractive;\n    this.root = this;\n  }\n\n  _createClass(Context, [{\n    key: \"add\",\n    // the usual mutation suspects\n    value: function add(keypath, d, options) {\n      var num = typeof d === 'number' ? +d : 1;\n      var opts = _typeof(d) === 'object' ? d : options;\n      return _set(build$1(this, keypath, num).map(function (pair) {\n        var _pair2 = _slicedToArray(pair, 2),\n            model = _pair2[0],\n            val = _pair2[1];\n\n        var value = model.get();\n        if (!isNumeric(val) || !isNumeric(value)) throw new Error('Cannot add non-numeric value');\n        return [model, value + val];\n      }), opts);\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(keypath, value, options) {\n      var model = findModel(this, keypath).model;\n      return _animate(this.ractive, model, value, options);\n    } // get relative keypaths and values\n\n  }, {\n    key: \"get\",\n    value: function get(keypath) {\n      if (!keypath) return this.fragment.findContext().get(true);\n\n      var _findModel = findModel(this, keypath),\n          model = _findModel.model;\n\n      return model ? model.get(true) : undefined;\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent(component) {\n      var fragment = this.fragment;\n      if (fragment.context) fragment = findParentWithContext(fragment.parent || component && fragment.componentParent);else {\n        fragment = findParentWithContext(fragment.parent || component && fragment.componentParent);\n        if (fragment) fragment = findParentWithContext(fragment.parent || component && fragment.componentParent);\n      }\n      if (!fragment || fragment === this.fragment) return;else return fragment.getContext();\n    }\n  }, {\n    key: \"link\",\n    value: function link(source, dest) {\n      var there = findModel(this, source).model;\n      var here = findModel(this, dest).model;\n      var promise = runloop.start();\n      here.link(there, source);\n      runloop.end();\n      return promise;\n    }\n  }, {\n    key: \"listen\",\n    value: function listen(event, handler) {\n      var el = this.element;\n      el.on(event, handler);\n      return {\n        cancel: function cancel() {\n          el.off(event, handler);\n        }\n      };\n    }\n  }, {\n    key: \"observe\",\n    value: function observe(keypath, callback) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (isObject(keypath)) options = callback || {};\n      options.fragment = this.fragment;\n      return this.ractive.observe(keypath, callback, options);\n    }\n  }, {\n    key: \"observeOnce\",\n    value: function observeOnce(keypath, callback) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (isObject(keypath)) options = callback || {};\n      options.fragment = this.fragment;\n      return this.ractive.observeOnce(keypath, callback, options);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(keypath) {\n      return modelPop(findModel(this, keypath).model, []);\n    }\n  }, {\n    key: \"push\",\n    value: function push(keypath) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        values[_key8 - 1] = arguments[_key8];\n      }\n\n      return modelPush(findModel(this, keypath).model, values);\n    }\n  }, {\n    key: \"raise\",\n    value: function raise(name, event) {\n      var element = this.element;\n      var events, len, i;\n\n      for (var _len9 = arguments.length, args = new Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {\n        args[_key9 - 2] = arguments[_key9];\n      }\n\n      while (element) {\n        events = element.events;\n        len = events && events.length;\n\n        for (i = 0; i < len; i++) {\n          var ev = events[i];\n\n          if (~ev.template.n.indexOf(name)) {\n            var ctx = !event || !('original' in event) ? ev.element.getContext(event || {}, {\n              original: {}\n            }) : ev.element.getContext(event || {});\n            return ev.fire(ctx, args);\n          }\n        }\n\n        element = element.parent;\n      }\n    }\n  }, {\n    key: \"readLink\",\n    value: function readLink(keypath, options) {\n      return this.ractive.readLink(this.resolve(keypath), options);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(path, ractive) {\n      var _findModel2 = findModel(this, path),\n          model = _findModel2.model,\n          instance = _findModel2.instance;\n\n      return model ? model.getKeypath(ractive || instance) : path;\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse(keypath) {\n      return modelReverse(findModel(this, keypath).model, []);\n    }\n  }, {\n    key: \"set\",\n    value: function set(keypath, value, options) {\n      return _set(build$1(this, keypath, value), options);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(keypath) {\n      return modelShift(findModel(this, keypath).model, []);\n    }\n  }, {\n    key: \"splice\",\n    value: function splice(keypath, index, drop) {\n      for (var _len10 = arguments.length, add = new Array(_len10 > 3 ? _len10 - 3 : 0), _key10 = 3; _key10 < _len10; _key10++) {\n        add[_key10 - 3] = arguments[_key10];\n      }\n\n      add.unshift(index, drop);\n      return modelSplice(findModel(this, keypath).model, add);\n    }\n  }, {\n    key: \"sort\",\n    value: function sort(keypath) {\n      return modelSort(findModel(this, keypath).model, []);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(keypath, d, options) {\n      var num = typeof d === 'number' ? d : 1;\n      var opts = _typeof(d) === 'object' ? d : options;\n      return _set(build$1(this, keypath, num).map(function (pair) {\n        var _pair3 = _slicedToArray(pair, 2),\n            model = _pair3[0],\n            val = _pair3[1];\n\n        var value = model.get();\n        if (!isNumeric(val) || !isNumeric(value)) throw new Error('Cannot add non-numeric value');\n        return [model, value - val];\n      }), opts);\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle(keypath, options) {\n      var _findModel3 = findModel(this, keypath),\n          model = _findModel3.model;\n\n      return _set([[model, !model.get()]], options);\n    }\n  }, {\n    key: \"unlink\",\n    value: function unlink(dest) {\n      var here = findModel(this, dest).model;\n      var promise = runloop.start();\n      if (here.owner && here.owner._link) here.owner.unlink();\n      runloop.end();\n      return promise;\n    }\n  }, {\n    key: \"unlisten\",\n    value: function unlisten(event, handler) {\n      this.element.off(event, handler);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(keypath) {\n      for (var _len11 = arguments.length, add = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        add[_key11 - 1] = arguments[_key11];\n      }\n\n      return modelUnshift(findModel(this, keypath).model, add);\n    }\n  }, {\n    key: \"update\",\n    value: function update(keypath, options) {\n      return update$1(this.ractive, findModel(this, keypath).model, options);\n    }\n  }, {\n    key: \"updateModel\",\n    value: function updateModel(keypath, cascade) {\n      var _findModel4 = findModel(this, keypath),\n          model = _findModel4.model;\n\n      var promise = runloop.start();\n      model.updateFromBindings(cascade);\n      runloop.end();\n      return promise;\n    } // two-way binding related helpers\n\n  }, {\n    key: \"isBound\",\n    value: function isBound() {\n      var _this$getBindingModel = this.getBindingModel(this),\n          model = _this$getBindingModel.model;\n\n      return !!model;\n    }\n  }, {\n    key: \"getBindingPath\",\n    value: function getBindingPath(ractive) {\n      var _this$getBindingModel2 = this.getBindingModel(this),\n          model = _this$getBindingModel2.model,\n          instance = _this$getBindingModel2.instance;\n\n      if (model) return model.getKeypath(ractive || instance);\n    }\n  }, {\n    key: \"getBinding\",\n    value: function getBinding() {\n      var _this$getBindingModel3 = this.getBindingModel(this),\n          model = _this$getBindingModel3.model;\n\n      if (model) return model.get(true);\n    }\n  }, {\n    key: \"getBindingModel\",\n    value: function getBindingModel(ctx) {\n      var el = ctx.element;\n      return {\n        model: el.binding && el.binding.model,\n        instance: el.parentFragment.ractive\n      };\n    }\n  }, {\n    key: \"setBinding\",\n    value: function setBinding(value) {\n      var _this$getBindingModel4 = this.getBindingModel(this),\n          model = _this$getBindingModel4.model;\n\n      return _set([[model, value]]);\n    }\n  }, {\n    key: \"decorators\",\n    get: function get() {\n      var items = {};\n      if (!this.element) return items;\n      this.element.decorators.forEach(function (d) {\n        return items[d.name] = d.handle;\n      });\n      return items;\n    }\n  }, {\n    key: \"_data\",\n    get: function get() {\n      return this.model || (this.root.model = new ContextData({\n        ractive: this.ractive,\n        context: this.root\n      }));\n    }\n  }]);\n\n  return Context;\n}();\n\nContext.forRactive = getRactiveContext; // circular deps are fun\n\nextern.Context = Context; // TODO: at some point perhaps this could support relative * keypaths?\n\nfunction build$1(ctx, keypath, value) {\n  var sets = []; // set multiple keypaths in one go\n\n  if (isObject(keypath)) {\n    for (var k in keypath) {\n      if (keypath.hasOwnProperty(k)) {\n        sets.push([findModel(ctx, k).model, keypath[k]]);\n      }\n    }\n  } // set a single keypath\n  else {\n      sets.push([findModel(ctx, keypath).model, value]);\n    }\n\n  return sets;\n}\n\nfunction findModel(ctx, path) {\n  var frag = ctx.fragment;\n\n  if (typeof path !== 'string') {\n    return {\n      model: frag.findContext(),\n      instance: path\n    };\n  }\n\n  return {\n    model: resolveReference(frag, path),\n    instance: frag.ractive\n  };\n}\n\nfunction Ractive$fire(eventName) {\n  var ctx; // watch for reproxy\n\n  for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    args[_key12 - 1] = arguments[_key12];\n  }\n\n  if (args[0] instanceof Context) {\n    var _proto = args.shift();\n\n    ctx = Object.create(_proto);\n    Object.assign(ctx, _proto);\n  } else if (_typeof(args[0]) === 'object' && (args[0] === null || args[0].constructor === Object)) {\n    ctx = Context.forRactive(this, args.shift());\n  } else {\n    ctx = Context.forRactive(this);\n  }\n\n  return fireEvent(this, eventName, ctx, args);\n}\n\nfunction Ractive$get(keypath, opts) {\n  if (typeof keypath !== 'string') return this.viewmodel.get(true, keypath);\n  var keys = splitKeypath(keypath);\n  var key = keys[0];\n  var model;\n\n  if (!this.viewmodel.has(key)) {\n    // if this is an inline component, we may need to create\n    // an implicit mapping\n    if (this.component && !this.isolated) {\n      model = resolveReference(this.fragment || new FakeFragment(this), key);\n    }\n  }\n\n  model = this.viewmodel.joinAll(keys);\n  return model.get(true, opts);\n}\n\nvar query = doc && doc.querySelector;\n\nfunction getContext$2(node) {\n  if (typeof node === 'string' && query) {\n    node = query.call(document, node);\n  }\n\n  var instances;\n\n  if (node) {\n    if (node._ractive) {\n      return node._ractive.proxy.getContext();\n    } else if ((instances = node.__ractive_instances__) && instances.length === 1) {\n      return getRactiveContext(instances[0]);\n    }\n  }\n}\n\nfunction getNodeInfo$1(node) {\n  warnOnceIfDebug(\"getNodeInfo has been renamed to getContext, and the getNodeInfo alias will be removed in a future release.\");\n  return getContext$2(node);\n}\n\nfunction getContext$1(node, options) {\n  if (typeof node === 'string') {\n    node = this.find(node, options);\n  }\n\n  return getContext$2(node);\n}\n\nfunction getNodeInfo$$1(node, options) {\n  if (typeof node === 'string') {\n    node = this.find(node, options);\n  }\n\n  return getNodeInfo$1(node);\n}\n\nvar html = 'http://www.w3.org/1999/xhtml';\nvar mathml = 'http://www.w3.org/1998/Math/MathML';\nvar svg$1 = 'http://www.w3.org/2000/svg';\nvar xlink = 'http://www.w3.org/1999/xlink';\nvar xml = 'http://www.w3.org/XML/1998/namespace';\nvar xmlns = 'http://www.w3.org/2000/xmlns';\nvar namespaces = {\n  html: html,\n  mathml: mathml,\n  svg: svg$1,\n  xlink: xlink,\n  xml: xml,\n  xmlns: xmlns\n};\nvar createElement;\nvar matches;\nvar div;\nvar methodNames;\nvar unprefixed;\nvar prefixed;\nvar i;\nvar j;\nvar makeFunction; // Test for SVG support\n\nif (!svg) {\n  /* istanbul ignore next */\n  createElement = function createElement(type, ns, extend) {\n    if (ns && ns !== html) {\n      throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n    }\n\n    return extend ? doc.createElement(type, extend) : doc.createElement(type);\n  };\n} else {\n  createElement = function createElement(type, ns, extend) {\n    if (!ns || ns === html) {\n      return extend ? doc.createElement(type, extend) : doc.createElement(type);\n    }\n\n    return extend ? doc.createElementNS(ns, type, extend) : doc.createElementNS(ns, type);\n  };\n}\n\nfunction createDocumentFragment() {\n  return doc.createDocumentFragment();\n}\n\nfunction getElement(input) {\n  var output;\n\n  if (!input || typeof input === 'boolean') {\n    return;\n  }\n  /* istanbul ignore next */\n\n\n  if (!win || !doc || !input) {\n    return null;\n  } // We already have a DOM node - no work to do. (Duck typing alert!)\n\n\n  if (input.nodeType) {\n    return input;\n  } // Get node from string\n\n\n  if (typeof input === 'string') {\n    // try ID first\n    output = doc.getElementById(input); // then as selector, if possible\n\n    if (!output && doc.querySelector) {\n      try {\n        output = doc.querySelector(input);\n      } catch (e) {\n        /* this space intentionally left blank */\n      }\n    } // did it work?\n\n\n    if (output && output.nodeType) {\n      return output;\n    }\n  } // If we've been given a collection (jQuery, Zepto etc), extract the first item\n\n\n  if (input[0] && input[0].nodeType) {\n    return input[0];\n  }\n\n  return null;\n}\n\nif (!isClient) {\n  matches = null;\n} else {\n  div = createElement('div');\n  methodNames = ['matches', 'matchesSelector'];\n\n  makeFunction = function makeFunction(methodName) {\n    return function (node, selector) {\n      return node[methodName](selector);\n    };\n  };\n\n  i = methodNames.length;\n\n  while (i-- && !matches) {\n    unprefixed = methodNames[i];\n\n    if (div[unprefixed]) {\n      matches = makeFunction(unprefixed);\n    } else {\n      j = vendors.length;\n\n      while (j--) {\n        prefixed = vendors[i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n        if (div[prefixed]) {\n          matches = makeFunction(prefixed);\n          break;\n        }\n      }\n    }\n  } // IE8... and apparently phantom some?\n\n  /* istanbul ignore next */\n\n\n  if (!matches) {\n    matches = function matches(node, selector) {\n      var parentNode, i;\n      parentNode = node.parentNode;\n\n      if (!parentNode) {\n        // empty dummy <div>\n        div.innerHTML = '';\n        parentNode = div;\n        node = node.cloneNode();\n        div.appendChild(node);\n      }\n\n      var nodes = parentNode.querySelectorAll(selector);\n      i = nodes.length;\n\n      while (i--) {\n        if (nodes[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n}\n\nfunction detachNode(node) {\n  // stupid ie\n  if (node && typeof node.parentNode !== 'unknown' && node.parentNode) {\n    // eslint-disable-line valid-typeof\n    node.parentNode.removeChild(node);\n  }\n\n  return node;\n}\n\nfunction safeToStringValue(value) {\n  return value == null || typeof value === 'number' && isNaN(value) || !value.toString ? '' : '' + value;\n}\n\nfunction safeAttributeString(string) {\n  return safeToStringValue(string).replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#39;');\n}\n\nvar insertHook = new Hook('insert');\n\nfunction Ractive$insert(target, anchor) {\n  if (!this.fragment.rendered) {\n    // TODO create, and link to, documentation explaining this\n    throw new Error('The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.');\n  }\n\n  target = getElement(target);\n  anchor = getElement(anchor) || null;\n\n  if (!target) {\n    throw new Error('You must specify a valid target to insert into');\n  }\n\n  target.insertBefore(this.detach(), anchor);\n  this.el = target;\n  (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  this.isDetached = false;\n  fireInsertHook(this);\n}\n\nfunction fireInsertHook(ractive) {\n  insertHook.fire(ractive);\n  ractive.findAllComponents('*').forEach(function (child) {\n    fireInsertHook(child.instance);\n  });\n}\n\nfunction link(there, here, options) {\n  var model;\n  var target = options && (options.ractive || options.instance) || this; // may need to allow a mapping to resolve implicitly\n\n  var sourcePath = splitKeypath(there);\n\n  if (!target.viewmodel.has(sourcePath[0]) && target.component) {\n    model = resolveReference(target.component.parentFragment, sourcePath[0]);\n    model = model.joinAll(sourcePath.slice(1));\n  }\n\n  var src = model || target.viewmodel.joinAll(sourcePath);\n  var dest = this.viewmodel.joinAll(splitKeypath(here), {\n    lastLink: false\n  });\n\n  if (isUpstream(src, dest) || isUpstream(dest, src)) {\n    throw new Error('A keypath cannot be linked to itself.');\n  }\n\n  var promise = runloop.start();\n  dest.link(src, options && options.keypath || there);\n  runloop.end();\n  return promise;\n}\n\nfunction isUpstream(check, start) {\n  var model = start;\n\n  while (model) {\n    if (model === check) return true;\n    model = model.target || model.parent;\n  }\n}\n\nvar Observer =\n/*#__PURE__*/\nfunction () {\n  function Observer(ractive, model, callback, options) {\n    _classCallCheck(this, Observer);\n\n    this.context = options.context || ractive;\n    this.callback = callback;\n    this.ractive = ractive;\n    this.keypath = options.keypath;\n    this.options = options;\n    if (model) this.resolved(model);\n\n    if (typeof options.old === 'function') {\n      this.oldContext = Object.create(ractive);\n      this.old = options.old;\n    } else {\n      this.old = old;\n    }\n\n    if (options.init !== false) {\n      this.dirty = true;\n      this.dispatch();\n    } else {\n      this.oldValue = this.old.call(this.oldContext, undefined, this.newValue);\n    }\n\n    this.dirty = false;\n  }\n\n  _createClass(Observer, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.cancelled = true;\n\n      if (this.model) {\n        this.model.unregister(this);\n      } else {\n        this.resolver.unbind();\n      }\n\n      removeFromArray(this.ractive._observers, this);\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch() {\n      if (!this.cancelled) {\n        this.callback.call(this.context, this.newValue, this.oldValue, this.keypath);\n        this.oldValue = this.old.call(this.oldContext, this.oldValue, this.model ? this.model.get() : this.newValue);\n        this.dirty = false;\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      var _this10 = this;\n\n      if (!this.dirty) {\n        var newValue = this.model.get();\n        if (isEqual(newValue, this.oldValue)) return;\n        this.newValue = newValue;\n        if (this.options.strict && this.newValue === this.oldValue) return;\n        runloop.addObserver(this, this.options.defer);\n        this.dirty = true;\n        if (this.options.once) runloop.scheduleTask(function () {\n          return _this10.cancel();\n        });\n      }\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous) {\n      var _this11 = this;\n\n      next = rebindMatch(this.keypath, next, previous); // TODO: set up a resolver if next is undefined?\n\n      if (next === this.model) return false;\n      if (this.model) this.model.unregister(this);\n      if (next) next.addShuffleTask(function () {\n        return _this11.resolved(next);\n      });\n    }\n  }, {\n    key: \"resolved\",\n    value: function resolved(model) {\n      this.model = model;\n      this.oldValue = undefined;\n      this.newValue = model.get();\n      model.register(this);\n    }\n  }]);\n\n  return Observer;\n}();\n\nfunction old(previous, next) {\n  return next;\n}\n\nvar star$1 = /\\*+/g;\n\nvar PatternObserver =\n/*#__PURE__*/\nfunction () {\n  function PatternObserver(ractive, baseModel, keys, callback, options) {\n    var _this12 = this;\n\n    _classCallCheck(this, PatternObserver);\n\n    this.context = options.context || ractive;\n    this.ractive = ractive;\n    this.baseModel = baseModel;\n    this.keys = keys;\n    this.callback = callback;\n    var pattern = keys.join('\\\\.').replace(star$1, '(.+)');\n    var baseKeypath = this.baseKeypath = baseModel.getKeypath(ractive);\n    this.pattern = new RegExp(\"^\".concat(baseKeypath ? baseKeypath + '\\\\.' : '').concat(pattern, \"$\"));\n    this.recursive = keys.length === 1 && keys[0] === '**';\n    if (this.recursive) this.keys = ['*'];\n    this.oldValues = {};\n    this.newValues = {};\n    this.defer = options.defer;\n    this.once = options.once;\n    this.strict = options.strict;\n    this.dirty = false;\n    this.changed = [];\n    this.partial = false;\n    this.links = options.links;\n    var models = baseModel.findMatches(this.keys);\n    models.forEach(function (model) {\n      _this12.newValues[model.getKeypath(_this12.ractive)] = model.get();\n    });\n\n    if (options.init !== false) {\n      this.dispatch();\n    } else {\n      this.oldValues = this.newValues;\n    }\n\n    baseModel.registerPatternObserver(this);\n  }\n\n  _createClass(PatternObserver, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.baseModel.unregisterPatternObserver(this);\n      removeFromArray(this.ractive._observers, this);\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch() {\n      var _this13 = this;\n\n      var newValues = this.newValues;\n      this.newValues = {};\n      Object.keys(newValues).forEach(function (keypath) {\n        var newValue = newValues[keypath];\n        var oldValue = _this13.oldValues[keypath];\n        if (_this13.strict && newValue === oldValue) return;\n        if (isEqual(newValue, oldValue)) return;\n        var args = [newValue, oldValue, keypath];\n\n        if (keypath) {\n          var wildcards = _this13.pattern.exec(keypath);\n\n          if (wildcards) {\n            args = args.concat(wildcards.slice(1));\n          }\n        }\n\n        _this13.callback.apply(_this13.context, args);\n      });\n\n      if (this.partial) {\n        for (var k in newValues) {\n          this.oldValues[k] = newValues[k];\n        }\n      } else {\n        this.oldValues = newValues;\n      }\n\n      this.dirty = false;\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(key) {\n      this.changed.push(key);\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices) {\n      if (!Array.isArray(this.baseModel.value)) return;\n      var max = this.baseModel.value.length;\n\n      for (var _i14 = 0; _i14 < newIndices.length; _i14++) {\n        if (newIndices[_i14] === -1 || newIndices[_i14] === _i14) continue;\n        this.changed.push([_i14]);\n      }\n\n      for (var _i15 = newIndices.touchedFrom; _i15 < max; _i15++) {\n        this.changed.push([_i15]);\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      var _this14 = this;\n\n      if (!this.dirty || this.changed.length) {\n        if (!this.dirty) this.newValues = {};\n\n        if (!this.changed.length) {\n          this.baseModel.findMatches(this.keys).forEach(function (model) {\n            var keypath = model.getKeypath(_this14.ractive);\n            _this14.newValues[keypath] = model.get();\n          });\n          this.partial = false;\n        } else {\n          var count = 0;\n\n          if (this.recursive) {\n            this.changed.forEach(function (keys) {\n              var model = _this14.baseModel.joinAll(keys);\n\n              if (model.isLink && !_this14.links) return;\n              count++;\n              _this14.newValues[model.getKeypath(_this14.ractive)] = model.get();\n            });\n          } else {\n            var ok = this.baseModel.isRoot ? this.changed.map(function (keys) {\n              return keys.map(escapeKey).join('.');\n            }) : this.changed.map(function (keys) {\n              return _this14.baseKeypath + '.' + keys.map(escapeKey).join('.');\n            });\n            this.baseModel.findMatches(this.keys).forEach(function (model) {\n              var keypath = model.getKeypath(_this14.ractive);\n\n              var check = function check(k) {\n                return k.indexOf(keypath) === 0 && (k.length === keypath.length || k[keypath.length] === '.') || keypath.indexOf(k) === 0 && (k.length === keypath.length || keypath[k.length] === '.');\n              }; // is this model on a changed keypath?\n\n\n              if (ok.filter(check).length) {\n                count++;\n                _this14.newValues[keypath] = model.get();\n              }\n            });\n          } // no valid change triggered, so bail to avoid breakage\n\n\n          if (!count) return;\n          this.partial = true;\n        }\n\n        runloop.addObserver(this, this.defer);\n        this.dirty = true;\n        this.changed.length = 0;\n        if (this.once) this.cancel();\n      }\n    }\n  }]);\n\n  return PatternObserver;\n}();\n\nfunction negativeOne() {\n  return -1;\n}\n\nvar ArrayObserver =\n/*#__PURE__*/\nfunction () {\n  function ArrayObserver(ractive, model, callback, options) {\n    _classCallCheck(this, ArrayObserver);\n\n    this.ractive = ractive;\n    this.model = model;\n    this.keypath = model.getKeypath();\n    this.callback = callback;\n    this.options = options;\n    this.pending = null;\n    model.register(this);\n\n    if (options.init !== false) {\n      this.sliced = [];\n      this.shuffle([]);\n      this.dispatch();\n    } else {\n      this.sliced = this.slice();\n    }\n  }\n\n  _createClass(ArrayObserver, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.model.unregister(this);\n      removeFromArray(this.ractive._observers, this);\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch() {\n      this.callback(this.pending);\n      this.pending = null;\n      if (this.options.once) this.cancel();\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(path) {\n      if (this.pending) {\n        // post-shuffle\n        runloop.addObserver(this, this.options.defer);\n      } else if (!path) {\n        // entire array changed\n        this.shuffle(this.sliced.map(negativeOne));\n        this.handleChange();\n      }\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices) {\n      var _this15 = this;\n\n      var newValue = this.slice();\n      var inserted = [];\n      var deleted = [];\n      var start;\n      var hadIndex = {};\n      newIndices.forEach(function (newIndex, oldIndex) {\n        hadIndex[newIndex] = true;\n\n        if (newIndex !== oldIndex && start === undefined) {\n          start = oldIndex;\n        }\n\n        if (newIndex === -1) {\n          deleted.push(_this15.sliced[oldIndex]);\n        }\n      });\n      if (start === undefined) start = newIndices.length;\n      var len = newValue.length;\n\n      for (var _i16 = 0; _i16 < len; _i16 += 1) {\n        if (!hadIndex[_i16]) inserted.push(newValue[_i16]);\n      }\n\n      this.pending = {\n        inserted: inserted,\n        deleted: deleted,\n        start: start\n      };\n      this.sliced = newValue;\n    }\n  }, {\n    key: \"slice\",\n    value: function slice() {\n      var value = this.model.get();\n      return Array.isArray(value) ? value.slice() : [];\n    }\n  }]);\n\n  return ArrayObserver;\n}();\n\nfunction observe(keypath, callback, options) {\n  var _this16 = this;\n\n  var observers = [];\n  var map;\n  var opts;\n\n  if (isObject(keypath)) {\n    map = keypath;\n    opts = callback || {};\n  } else {\n    if (typeof keypath === 'function') {\n      map = {\n        '': keypath\n      };\n      opts = callback || {};\n    } else {\n      map = {};\n      map[keypath] = callback;\n      opts = options || {};\n    }\n  }\n\n  var silent = false;\n  Object.keys(map).forEach(function (keypath) {\n    var callback = map[keypath];\n\n    var caller = function caller() {\n      if (silent) return;\n\n      for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        args[_key13] = arguments[_key13];\n      }\n\n      return callback.apply(this, args);\n    };\n\n    var keypaths = keypath.split(' ');\n    if (keypaths.length > 1) keypaths = keypaths.filter(function (k) {\n      return k;\n    });\n    keypaths.forEach(function (keypath) {\n      opts.keypath = keypath;\n      var observer = createObserver(_this16, keypath, caller, opts);\n      if (observer) observers.push(observer);\n    });\n  }); // add observers to the Ractive instance, so they can be\n  // cancelled on ractive.teardown()\n\n  this._observers.push.apply(this._observers, observers);\n\n  return {\n    cancel: function cancel() {\n      return observers.forEach(function (o) {\n        return o.cancel();\n      });\n    },\n    isSilenced: function isSilenced() {\n      return silent;\n    },\n    silence: function silence() {\n      return silent = true;\n    },\n    resume: function resume() {\n      return silent = false;\n    }\n  };\n}\n\nfunction createObserver(ractive, keypath, callback, options) {\n  var keys = splitKeypath(keypath);\n  var wildcardIndex = keys.indexOf('*');\n  if (!~wildcardIndex) wildcardIndex = keys.indexOf('**');\n  options.fragment = options.fragment || ractive.fragment;\n  var model;\n\n  if (!options.fragment) {\n    model = ractive.viewmodel.joinKey(keys[0]);\n  } else {\n    // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .\n    if (~keys[0].indexOf('.*')) {\n      model = options.fragment.findContext();\n      wildcardIndex = 0;\n      keys[0] = keys[0].slice(1);\n    } else {\n      model = wildcardIndex === 0 ? options.fragment.findContext() : resolveReference(options.fragment, keys[0]);\n    }\n  } // the model may not exist key\n\n\n  if (!model) model = ractive.viewmodel.joinKey(keys[0]);\n\n  if (!~wildcardIndex) {\n    model = model.joinAll(keys.slice(1));\n\n    if (options.array) {\n      return new ArrayObserver(ractive, model, callback, options);\n    } else {\n      return new Observer(ractive, model, callback, options);\n    }\n  } else {\n    var _double = keys.indexOf('**');\n\n    if (~_double) {\n      if (_double + 1 !== keys.length || ~keys.indexOf('*')) {\n        warnOnceIfDebug(\"Recursive observers may only specify a single '**' at the end of the path.\");\n        return;\n      }\n    }\n\n    model = model.joinAll(keys.slice(1, wildcardIndex));\n    return new PatternObserver(ractive, model, keys.slice(wildcardIndex), callback, options);\n  }\n}\n\nvar onceOptions = {\n  init: false,\n  once: true\n};\n\nfunction observeOnce(keypath, callback, options) {\n  if (isObject(keypath) || typeof keypath === 'function') {\n    options = Object.assign(callback || {}, onceOptions);\n    return this.observe(keypath, options);\n  }\n\n  options = Object.assign(options || {}, onceOptions);\n  return this.observe(keypath, callback, options);\n}\n\nvar trim = function trim(str) {\n  return str.trim();\n};\n\nvar notEmptyString = function notEmptyString(str) {\n  return str !== '';\n};\n\nfunction Ractive$off(eventName, callback) {\n  var _this17 = this;\n\n  // if no event is specified, remove _all_ event listeners\n  if (!eventName) {\n    this._subs = {};\n  } else {\n    // Handle multiple space-separated event names\n    var eventNames = eventName.split(' ').map(trim).filter(notEmptyString);\n    eventNames.forEach(function (event) {\n      var subs = _this17._subs[event]; // if given a specific callback to remove, remove only it\n\n      if (subs && callback) {\n        var entry = subs.find(function (s) {\n          return s.callback === callback;\n        });\n\n        if (entry) {\n          removeFromArray(subs, entry);\n          entry.off = true;\n          if (event.indexOf('.')) _this17._nsSubs--;\n        }\n      } // otherwise, remove all listeners for this event\n      else if (subs) {\n          if (event.indexOf('.')) _this17._nsSubs -= subs.length;\n          subs.length = 0;\n        }\n    });\n  }\n\n  return this;\n}\n\nfunction Ractive$on(eventName, callback) {\n  var _this18 = this;\n\n  // eventName may already be a map\n  var map = _typeof(eventName) === 'object' ? eventName : {}; // or it may be a string along with a callback\n\n  if (typeof eventName === 'string') map[eventName] = callback;\n  var silent = false;\n  var events = [];\n\n  var _loop4 = function _loop4(k) {\n    var callback = map[k];\n\n    var caller = function caller() {\n      for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        args[_key14] = arguments[_key14];\n      }\n\n      if (!silent) return callback.apply(this, args);\n    };\n\n    var entry = {\n      callback: callback,\n      handler: caller\n    };\n\n    if (map.hasOwnProperty(k)) {\n      var _names = k.split(' ').map(trim).filter(notEmptyString);\n\n      _names.forEach(function (n) {\n        (_this18._subs[n] || (_this18._subs[n] = [])).push(entry);\n        if (n.indexOf('.')) _this18._nsSubs++;\n        events.push([n, entry]);\n      });\n    }\n  };\n\n  for (var k in map) {\n    _loop4(k);\n  }\n\n  return {\n    cancel: function cancel() {\n      return events.forEach(function (e) {\n        return _this18.off(e[0], e[1].callback);\n      });\n    },\n    isSilenced: function isSilenced() {\n      return silent;\n    },\n    silence: function silence() {\n      return silent = true;\n    },\n    resume: function resume() {\n      return silent = false;\n    }\n  };\n}\n\nfunction Ractive$once(eventName, handler) {\n  var listener = this.on(eventName, function () {\n    handler.apply(this, arguments);\n    listener.cancel();\n  }); // so we can still do listener.cancel() manually\n\n  return listener;\n}\n\nvar pop = makeArrayMethod('pop').path;\nvar push = makeArrayMethod('push').path;\n\nfunction readLink(keypath) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var path = splitKeypath(keypath);\n\n  if (this.viewmodel.has(path[0])) {\n    var model = this.viewmodel.joinAll(path);\n    if (!model.isLink) return;\n\n    while ((model = model.target) && options.canonical !== false) {\n      if (!model.isLink) break;\n    }\n\n    if (model) return {\n      ractive: model.root.ractive,\n      keypath: model.getKeypath()\n    };\n  }\n}\n\nvar PREFIX = '/* Ractive.js component styles */'; // Holds current definitions of styles.\n\nvar styleDefinitions = []; // Flag to tell if we need to update the CSS\n\nvar isDirty = false; // These only make sense on the browser. See additional setup below.\n\nvar styleElement = null;\nvar useCssText = null;\n\nfunction addCSS(styleDefinition) {\n  styleDefinitions.push(styleDefinition);\n  isDirty = true;\n}\n\nfunction applyCSS(force) {\n  var styleElement = style(); // Apply only seems to make sense when we're in the DOM. Server-side renders\n  // can call toCSS to get the updated CSS.\n\n  if (!styleElement || !force && !isDirty) return;\n\n  if (useCssText) {\n    styleElement.styleSheet.cssText = getCSS(null);\n  } else {\n    styleElement.innerHTML = getCSS(null);\n  }\n\n  isDirty = false;\n}\n\nfunction getCSS(cssIds) {\n  var filteredStyleDefinitions = cssIds ? styleDefinitions.filter(function (style) {\n    return ~cssIds.indexOf(style.id);\n  }) : styleDefinitions;\n  filteredStyleDefinitions.forEach(function (d) {\n    return d.applied = true;\n  });\n  return filteredStyleDefinitions.reduce(function (styles, style) {\n    return \"\".concat(styles ? \"\".concat(styles, \"\\n\\n/* {\").concat(style.id, \"} */\\n\").concat(style.styles) : '');\n  }, PREFIX);\n}\n\nfunction style() {\n  // If we're on the browser, additional setup needed.\n  if (doc && !styleElement) {\n    styleElement = doc.createElement('style');\n    styleElement.type = 'text/css';\n    doc.getElementsByTagName('head')[0].appendChild(styleElement);\n    useCssText = !!styleElement.styleSheet;\n  }\n\n  return styleElement;\n}\n\nvar adaptConfigurator = {\n  extend: function extend(Parent, proto, options) {\n    proto.adapt = combine(proto.adapt, ensureArray(options.adapt));\n  },\n  init: function init() {}\n};\nvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\nvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\2).)*\\2/gi;\nvar value = /\\0(\\d+)/g; // Removes comments and strings from the given CSS to make it easier to parse.\n// Callback receives the cleaned CSS and a function which can be used to put\n// the removed strings back in place after parsing is done.\n\nvar cleanCss = function cleanCss(css, callback) {\n  var additionalReplaceRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var values = [];\n\n  var reconstruct = function reconstruct(css) {\n    return css.replace(value, function (match, n) {\n      return values[n];\n    });\n  };\n\n  css = css.replace(escape, function (match) {\n    return \"\\0\".concat(values.push(match) - 1);\n  }).replace(remove, '');\n  additionalReplaceRules.forEach(function (pattern) {\n    css = css.replace(pattern, function (match) {\n      return \"\\0\".concat(values.push(match) - 1);\n    });\n  });\n  return callback(css, reconstruct);\n};\n\nvar selectorsPattern = /(?:^|\\}|\\{)\\s*([^\\{\\}\\0]+)\\s*(?=\\{)/g;\nvar keyframesDeclarationPattern = /@keyframes\\s+[^\\{\\}]+\\s*\\{(?:[^{}]+|\\{[^{}]+})*}/gi;\nvar selectorUnitPattern = /((?:(?:\\[[^\\]]+\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\nvar excludePattern = /^(?:@|\\d+%)/;\nvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\nfunction trim$1(str) {\n  return str.trim();\n}\n\nfunction extractString(unit) {\n  return unit.str;\n}\n\nfunction transformSelector(selector, parent) {\n  var selectorUnits = [];\n  var match;\n\n  while (match = selectorUnitPattern.exec(selector)) {\n    selectorUnits.push({\n      str: match[0],\n      base: match[1],\n      modifiers: match[2]\n    });\n  } // For each simple selector within the selector, we need to create a version\n  // that a) combines with the id, and b) is inside the id\n\n\n  var base = selectorUnits.map(extractString);\n  var transformed = [];\n  var i = selectorUnits.length;\n\n  while (i--) {\n    var appended = base.slice(); // Pseudo-selectors should go after the attribute selector\n\n    var unit = selectorUnits[i];\n    appended[i] = unit.base + parent + unit.modifiers || '';\n    var prepended = base.slice();\n    prepended[i] = parent + ' ' + prepended[i];\n    transformed.push(appended.join(' '), prepended.join(' '));\n  }\n\n  return transformed.join(', ');\n}\n\nfunction transformCss(css, id) {\n  var dataAttr = \"[data-ractive-css~=\\\"{\".concat(id, \"}\\\"]\");\n  var transformed;\n\n  if (dataRvcGuidPattern.test(css)) {\n    transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  } else {\n    transformed = cleanCss(css, function (css, reconstruct) {\n      css = css.replace(selectorsPattern, function (match, $1) {\n        // don't transform at-rules and keyframe declarations\n        if (excludePattern.test($1)) return match;\n        var selectors = $1.split(',').map(trim$1);\n        var transformed = selectors.map(function (selector) {\n          return transformSelector(selector, dataAttr);\n        }).join(', ') + ' ';\n        return match.replace($1, transformed);\n      });\n      return reconstruct(css);\n    }, [keyframesDeclarationPattern]);\n  }\n\n  return transformed;\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n}\n\nfunction uuid() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nfunction setCSSData(keypath, value, options) {\n  var opts = _typeof(keypath) === 'object' ? value : options;\n  var model = this._cssModel;\n  model.locked = true;\n\n  var promise = _set(build({\n    viewmodel: model\n  }, keypath, value, true), opts);\n\n  model.locked = false;\n  var cascade = runloop.start();\n  this.extensions.forEach(function (e) {\n    var model = e._cssModel;\n    model.mark();\n    model.downstreamChanged('', 1);\n  });\n  runloop.end();\n  applyChanges(this, !opts || opts.apply !== false);\n  return promise.then(function () {\n    return cascade;\n  });\n}\n\nfunction applyChanges(component, apply) {\n  var local = recomputeCSS(component);\n  var child = component.extensions.map(function (e) {\n    return applyChanges(e, false);\n  }).reduce(function (a, c) {\n    return c || a;\n  }, false);\n\n  if (apply && (local || child)) {\n    var def = component._cssDef;\n    if (!def || def && def.applied) applyCSS(true);\n  }\n\n  return local || child;\n}\n\nfunction recomputeCSS(component) {\n  var css = component._css;\n  if (typeof css !== 'function') return;\n  var def = component._cssDef;\n  var result = evalCSS(component, css);\n  var styles = def.transform ? transformCss(result, def.id) : result;\n  if (def.styles === styles) return;\n  def.styles = styles;\n  return true;\n}\n\nvar CSSModel =\n/*#__PURE__*/\nfunction (_SharedModel) {\n  _inherits(CSSModel, _SharedModel);\n\n  function CSSModel(component) {\n    var _this19;\n\n    _classCallCheck(this, CSSModel);\n\n    _this19 = _possibleConstructorReturn(this, _getPrototypeOf(CSSModel).call(this, component.cssData, '@style'));\n    _this19.component = component;\n    return _this19;\n  }\n\n  _createClass(CSSModel, [{\n    key: \"downstreamChanged\",\n    value: function downstreamChanged(path, depth) {\n      if (this.locked) return;\n      var component = this.component;\n      component.extensions.forEach(function (e) {\n        var model = e._cssModel;\n        model.mark();\n        model.downstreamChanged(path, depth || 1);\n      });\n\n      if (!depth) {\n        applyChanges(component, true);\n      }\n    }\n  }]);\n\n  return CSSModel;\n}(SharedModel);\n\nvar hasCurly = /\\{/;\nvar cssConfigurator = {\n  name: 'css',\n  // Called when creating a new component definition\n  extend: function extend(Parent, proto, options, Child) {\n    Child._cssIds = gatherIds(Parent);\n    Object.defineProperty(Child, 'cssData', {\n      configurable: true,\n      value: Object.assign(Object.create(Parent.cssData), options.cssData || {})\n    });\n    Object.defineProperty(Child, '_cssModel', {\n      configurable: true,\n      value: new CSSModel(Child)\n    });\n    if (!options.css) return;\n    var css = typeof options.css === 'string' && !hasCurly.test(options.css) ? getElement(options.css) || options.css : options.css;\n    var id = options.cssId || uuid();\n\n    if (_typeof(css) === 'object') {\n      css = 'textContent' in css ? css.textContent : css.innerHTML;\n    } else if (typeof css === 'function') {\n      Child._css = options.css;\n      css = evalCSS(Child, css);\n    }\n\n    var def = Child._cssDef = {\n      transform: !options.noCssTransform\n    };\n    def.styles = def.transform ? transformCss(css, id) : css;\n    def.id = proto.cssId = id;\n\n    Child._cssIds.push(id);\n\n    addCSS(Child._cssDef);\n  },\n  // Called when creating a new component instance\n  init: function init(Parent, target, options) {\n    if (!options.css) return;\n    warnIfDebug(\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\");\n  }\n};\n\nfunction gatherIds(start) {\n  var cmp = start;\n  var ids = [];\n\n  while (cmp) {\n    if (cmp.prototype.cssId) ids.push(cmp.prototype.cssId);\n    cmp = cmp.Parent;\n  }\n\n  return ids;\n}\n\nfunction evalCSS(component, css) {\n  var cssData = component.cssData;\n  var model = component._cssModel;\n\n  var data = function data(path) {\n    return model.joinAll(splitKeypath(path)).get();\n  };\n\n  data.__proto__ = cssData;\n  var result = css.call(component, data);\n  return typeof result === 'string' ? result : '';\n}\n\nfunction validate(data) {\n  // Warn if userOptions.data is a non-POJO\n  if (data && data.constructor !== Object) {\n    if (typeof data === 'function') {// TODO do we need to support this in the new Ractive() case?\n    } else if (_typeof(data) !== 'object') {\n      fatal(\"data option must be an object or a function, `\".concat(data, \"` is not valid\"));\n    } else {\n      warnIfDebug('If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged');\n    }\n  }\n}\n\nvar dataConfigurator = {\n  name: 'data',\n  extend: function extend(Parent, proto, options) {\n    var key;\n    var value; // check for non-primitives, which could cause mutation-related bugs\n\n    if (options.data && isObject(options.data)) {\n      for (key in options.data) {\n        value = options.data[key];\n\n        if (value && _typeof(value) === 'object') {\n          if (isObject(value) || Array.isArray(value)) {\n            warnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n          }\n        }\n      }\n    }\n\n    proto.data = combine$1(proto.data, options.data);\n  },\n  init: function init(Parent, ractive, options) {\n    var result = combine$1(Parent.prototype.data, options.data);\n    if (typeof result === 'function') result = result.call(ractive); // bind functions to the ractive instance at the top level,\n    // unless it's a non-POJO (in which case alarm bells should ring)\n\n    if (result && result.constructor === Object) {\n      for (var prop in result) {\n        if (typeof result[prop] === 'function') {\n          var _value4 = result[prop];\n          result[prop] = bind$1(_value4, ractive);\n          result[prop]._r_unbound = _value4;\n        }\n      }\n    }\n\n    return result || {};\n  },\n  reset: function reset(ractive) {\n    var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n    ractive.viewmodel.root.set(result);\n    return true;\n  }\n};\n\nfunction combine$1(parentValue, childValue) {\n  validate(childValue);\n  var parentIsFn = typeof parentValue === 'function';\n  var childIsFn = typeof childValue === 'function'; // Very important, otherwise child instance can become\n  // the default data object on Ractive or a component.\n  // then ractive.set() ends up setting on the prototype!\n\n  if (!childValue && !parentIsFn) {\n    childValue = {};\n  } // Fast path, where we just need to copy properties from\n  // parent to child\n\n\n  if (!parentIsFn && !childIsFn) {\n    return fromProperties(childValue, parentValue);\n  }\n\n  return function () {\n    var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n    var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n    return fromProperties(child, parent);\n  };\n}\n\nfunction callDataFunction(fn, context) {\n  var data = fn.call(context);\n  if (!data) return;\n\n  if (_typeof(data) !== 'object') {\n    fatal('Data function must return an object');\n  }\n\n  if (data.constructor !== Object) {\n    warnOnceIfDebug('Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged');\n  }\n\n  return data;\n}\n\nfunction fromProperties(primary, secondary) {\n  if (primary && secondary) {\n    for (var key in secondary) {\n      if (!(key in primary)) {\n        primary[key] = secondary[key];\n      }\n    }\n\n    return primary;\n  }\n\n  return primary || secondary;\n}\n\nvar TEMPLATE_VERSION = 4;\nvar pattern = /\\$\\{([^\\}]+)\\}/g;\n\nfunction fromExpression(body) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var args = new Array(length);\n\n  while (length--) {\n    args[length] = \"_\".concat(length);\n  } // Functions created directly with new Function() look like this:\n  //     function anonymous (_0 /**/) { return _0*2 }\n  //\n  // With this workaround, we get a little more compact:\n  //     function (_0){return _0*2}\n\n\n  return new Function([], \"return function (\".concat(args.join(','), \"){return(\").concat(body, \");};\"))();\n}\n\nfunction fromComputationString(str, bindTo) {\n  var hasThis;\n  var functionBody = 'return (' + str.replace(pattern, function (match, keypath) {\n    hasThis = true;\n    return \"__ractive.get(\\\"\".concat(keypath, \"\\\")\");\n  }) + ');';\n  if (hasThis) functionBody = \"var __ractive = this; \".concat(functionBody);\n  var fn = new Function(functionBody);\n  return hasThis ? fn.bind(bindTo) : fn;\n}\n\nvar leadingWhitespace = /^\\s+/;\n\nvar ParseError = function ParseError(message) {\n  this.name = 'ParseError';\n  this.message = message;\n\n  try {\n    throw new Error(message);\n  } catch (e) {\n    this.stack = e.stack;\n  }\n};\n\nParseError.prototype = Error.prototype;\n\nvar Parser = function Parser(str, options) {\n  var item;\n  var lineStart = 0;\n  this.str = str;\n  this.options = options || {};\n  this.pos = 0;\n  this.lines = this.str.split('\\n');\n  this.lineEnds = this.lines.map(function (line) {\n    var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n    lineStart = lineEnd;\n    return lineEnd;\n  }, 0); // Custom init logic\n\n  if (this.init) this.init(str, options);\n  var items = [];\n\n  while (this.pos < this.str.length && (item = this.read())) {\n    items.push(item);\n  }\n\n  this.leftover = this.remaining();\n  this.result = this.postProcess ? this.postProcess(items, options) : items;\n};\n\nParser.prototype = {\n  read: function read(converters) {\n    var i, item;\n    if (!converters) converters = this.converters;\n    var pos = this.pos;\n    var len = converters.length;\n\n    for (i = 0; i < len; i += 1) {\n      this.pos = pos; // reset for each attempt\n\n      if (item = converters[i](this)) {\n        return item;\n      }\n    }\n\n    return null;\n  },\n  getContextMessage: function getContextMessage(pos, message) {\n    var _this$getLinePos = this.getLinePos(pos),\n        _this$getLinePos2 = _slicedToArray(_this$getLinePos, 2),\n        lineNum = _this$getLinePos2[0],\n        columnNum = _this$getLinePos2[1];\n\n    if (this.options.contextLines === -1) {\n      return [lineNum, columnNum, \"\".concat(message, \" at line \").concat(lineNum, \" character \").concat(columnNum)];\n    }\n\n    var line = this.lines[lineNum - 1];\n    var contextUp = '';\n    var contextDown = '';\n\n    if (this.options.contextLines) {\n      var start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n      contextUp = this.lines.slice(start, lineNum - 1 - start).join('\\n').replace(/\\t/g, '  ');\n      contextDown = this.lines.slice(lineNum, lineNum + this.options.contextLines).join('\\n').replace(/\\t/g, '  ');\n\n      if (contextUp) {\n        contextUp += '\\n';\n      }\n\n      if (contextDown) {\n        contextDown = '\\n' + contextDown;\n      }\n    }\n\n    var numTabs = 0;\n    var annotation = contextUp + line.replace(/\\t/g, function (match, _char) {\n      if (_char < columnNum) {\n        numTabs += 1;\n      }\n\n      return '  ';\n    }) + '\\n' + new Array(columnNum + numTabs).join(' ') + '^----' + contextDown;\n    return [lineNum, columnNum, \"\".concat(message, \" at line \").concat(lineNum, \" character \").concat(columnNum, \":\\n\").concat(annotation)];\n  },\n  getLinePos: function getLinePos(_char2) {\n    var lineNum = 0;\n    var lineStart = 0;\n\n    while (_char2 >= this.lineEnds[lineNum]) {\n      lineStart = this.lineEnds[lineNum];\n      lineNum += 1;\n    }\n\n    var columnNum = _char2 - lineStart;\n    return [lineNum + 1, columnNum + 1, _char2]; // line/col should be one-based, not zero-based!\n  },\n  error: function error(message) {\n    var _this$getContextMessa = this.getContextMessage(this.pos, message),\n        _this$getContextMessa2 = _slicedToArray(_this$getContextMessa, 3),\n        lineNum = _this$getContextMessa2[0],\n        columnNum = _this$getContextMessa2[1],\n        msg = _this$getContextMessa2[2];\n\n    var error = new ParseError(msg);\n    error.line = lineNum;\n    error.character = columnNum;\n    error.shortMessage = message;\n    throw error;\n  },\n  matchString: function matchString(string) {\n    if (this.str.substr(this.pos, string.length) === string) {\n      this.pos += string.length;\n      return string;\n    }\n  },\n  matchPattern: function matchPattern(pattern) {\n    var match;\n\n    if (match = pattern.exec(this.remaining())) {\n      this.pos += match[0].length;\n      return match[1] || match[0];\n    }\n  },\n  allowWhitespace: function allowWhitespace() {\n    this.matchPattern(leadingWhitespace);\n  },\n  remaining: function remaining() {\n    return this.str.substring(this.pos);\n  },\n  nextChar: function nextChar() {\n    return this.str.charAt(this.pos);\n  },\n  warn: function warn(message) {\n    var msg = this.getContextMessage(this.pos, message)[2];\n    warnIfDebug(msg);\n  }\n};\n\nParser.extend = function (proto) {\n  var Parent = this;\n\n  var Child = function Child(str, options) {\n    Parser.call(this, str, options);\n  };\n\n  Child.prototype = Object.create(Parent.prototype);\n\n  for (var key in proto) {\n    if (proto.hasOwnProperty(key)) {\n      Child.prototype[key] = proto[key];\n    }\n  }\n\n  Child.extend = Parser.extend;\n  return Child;\n};\n\nvar delimiterChangePattern = /^[^\\s=]+/;\nvar whitespacePattern = /^\\s+/;\n\nfunction readDelimiterChange(parser) {\n  if (!parser.matchString('=')) {\n    return null;\n  }\n\n  var start = parser.pos; // allow whitespace before new opening delimiter\n\n  parser.allowWhitespace();\n  var opening = parser.matchPattern(delimiterChangePattern);\n\n  if (!opening) {\n    parser.pos = start;\n    return null;\n  } // allow whitespace (in fact, it's necessary...)\n\n\n  if (!parser.matchPattern(whitespacePattern)) {\n    return null;\n  }\n\n  var closing = parser.matchPattern(delimiterChangePattern);\n\n  if (!closing) {\n    parser.pos = start;\n    return null;\n  } // allow whitespace before closing '='\n\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return [opening, closing];\n}\n\nvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\nfunction readNumberLiteral(parser) {\n  var result;\n\n  if (result = parser.matchPattern(regexpPattern)) {\n    return {\n      t: REGEXP_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nvar pattern$1 = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(str) {\n  return str.replace(pattern$1, '\\\\$&');\n}\n\nvar regExpCache = {};\n\nvar getLowestIndex = function getLowestIndex(haystack, needles) {\n  return haystack.search(regExpCache[needles.join()] || (regExpCache[needles.join()] = new RegExp(needles.map(escapeRegExp).join('|'))));\n}; // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\n\nvar booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvar voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\nvar htmlEntities = {\n  quot: 34,\n  amp: 38,\n  apos: 39,\n  lt: 60,\n  gt: 62,\n  nbsp: 160,\n  iexcl: 161,\n  cent: 162,\n  pound: 163,\n  curren: 164,\n  yen: 165,\n  brvbar: 166,\n  sect: 167,\n  uml: 168,\n  copy: 169,\n  ordf: 170,\n  laquo: 171,\n  not: 172,\n  shy: 173,\n  reg: 174,\n  macr: 175,\n  deg: 176,\n  plusmn: 177,\n  sup2: 178,\n  sup3: 179,\n  acute: 180,\n  micro: 181,\n  para: 182,\n  middot: 183,\n  cedil: 184,\n  sup1: 185,\n  ordm: 186,\n  raquo: 187,\n  frac14: 188,\n  frac12: 189,\n  frac34: 190,\n  iquest: 191,\n  Agrave: 192,\n  Aacute: 193,\n  Acirc: 194,\n  Atilde: 195,\n  Auml: 196,\n  Aring: 197,\n  AElig: 198,\n  Ccedil: 199,\n  Egrave: 200,\n  Eacute: 201,\n  Ecirc: 202,\n  Euml: 203,\n  Igrave: 204,\n  Iacute: 205,\n  Icirc: 206,\n  Iuml: 207,\n  ETH: 208,\n  Ntilde: 209,\n  Ograve: 210,\n  Oacute: 211,\n  Ocirc: 212,\n  Otilde: 213,\n  Ouml: 214,\n  times: 215,\n  Oslash: 216,\n  Ugrave: 217,\n  Uacute: 218,\n  Ucirc: 219,\n  Uuml: 220,\n  Yacute: 221,\n  THORN: 222,\n  szlig: 223,\n  agrave: 224,\n  aacute: 225,\n  acirc: 226,\n  atilde: 227,\n  auml: 228,\n  aring: 229,\n  aelig: 230,\n  ccedil: 231,\n  egrave: 232,\n  eacute: 233,\n  ecirc: 234,\n  euml: 235,\n  igrave: 236,\n  iacute: 237,\n  icirc: 238,\n  iuml: 239,\n  eth: 240,\n  ntilde: 241,\n  ograve: 242,\n  oacute: 243,\n  ocirc: 244,\n  otilde: 245,\n  ouml: 246,\n  divide: 247,\n  oslash: 248,\n  ugrave: 249,\n  uacute: 250,\n  ucirc: 251,\n  uuml: 252,\n  yacute: 253,\n  thorn: 254,\n  yuml: 255,\n  OElig: 338,\n  oelig: 339,\n  Scaron: 352,\n  scaron: 353,\n  Yuml: 376,\n  fnof: 402,\n  circ: 710,\n  tilde: 732,\n  Alpha: 913,\n  Beta: 914,\n  Gamma: 915,\n  Delta: 916,\n  Epsilon: 917,\n  Zeta: 918,\n  Eta: 919,\n  Theta: 920,\n  Iota: 921,\n  Kappa: 922,\n  Lambda: 923,\n  Mu: 924,\n  Nu: 925,\n  Xi: 926,\n  Omicron: 927,\n  Pi: 928,\n  Rho: 929,\n  Sigma: 931,\n  Tau: 932,\n  Upsilon: 933,\n  Phi: 934,\n  Chi: 935,\n  Psi: 936,\n  Omega: 937,\n  alpha: 945,\n  beta: 946,\n  gamma: 947,\n  delta: 948,\n  epsilon: 949,\n  zeta: 950,\n  eta: 951,\n  theta: 952,\n  iota: 953,\n  kappa: 954,\n  lambda: 955,\n  mu: 956,\n  nu: 957,\n  xi: 958,\n  omicron: 959,\n  pi: 960,\n  rho: 961,\n  sigmaf: 962,\n  sigma: 963,\n  tau: 964,\n  upsilon: 965,\n  phi: 966,\n  chi: 967,\n  psi: 968,\n  omega: 969,\n  thetasym: 977,\n  upsih: 978,\n  piv: 982,\n  ensp: 8194,\n  emsp: 8195,\n  thinsp: 8201,\n  zwnj: 8204,\n  zwj: 8205,\n  lrm: 8206,\n  rlm: 8207,\n  ndash: 8211,\n  mdash: 8212,\n  lsquo: 8216,\n  rsquo: 8217,\n  sbquo: 8218,\n  ldquo: 8220,\n  rdquo: 8221,\n  bdquo: 8222,\n  dagger: 8224,\n  Dagger: 8225,\n  bull: 8226,\n  hellip: 8230,\n  permil: 8240,\n  prime: 8242,\n  Prime: 8243,\n  lsaquo: 8249,\n  rsaquo: 8250,\n  oline: 8254,\n  frasl: 8260,\n  euro: 8364,\n  image: 8465,\n  weierp: 8472,\n  real: 8476,\n  trade: 8482,\n  alefsym: 8501,\n  larr: 8592,\n  uarr: 8593,\n  rarr: 8594,\n  darr: 8595,\n  harr: 8596,\n  crarr: 8629,\n  lArr: 8656,\n  uArr: 8657,\n  rArr: 8658,\n  dArr: 8659,\n  hArr: 8660,\n  forall: 8704,\n  part: 8706,\n  exist: 8707,\n  empty: 8709,\n  nabla: 8711,\n  isin: 8712,\n  notin: 8713,\n  ni: 8715,\n  prod: 8719,\n  sum: 8721,\n  minus: 8722,\n  lowast: 8727,\n  radic: 8730,\n  prop: 8733,\n  infin: 8734,\n  ang: 8736,\n  and: 8743,\n  or: 8744,\n  cap: 8745,\n  cup: 8746,\n  \"int\": 8747,\n  there4: 8756,\n  sim: 8764,\n  cong: 8773,\n  asymp: 8776,\n  ne: 8800,\n  equiv: 8801,\n  le: 8804,\n  ge: 8805,\n  sub: 8834,\n  sup: 8835,\n  nsub: 8836,\n  sube: 8838,\n  supe: 8839,\n  oplus: 8853,\n  otimes: 8855,\n  perp: 8869,\n  sdot: 8901,\n  lceil: 8968,\n  rceil: 8969,\n  lfloor: 8970,\n  rfloor: 8971,\n  lang: 9001,\n  rang: 9002,\n  loz: 9674,\n  spades: 9824,\n  clubs: 9827,\n  hearts: 9829,\n  diams: 9830\n};\nvar controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\nvar entityPattern = new RegExp('&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys(htmlEntities).join('|') + '));?', 'g');\nvar codePointSupport = typeof String.fromCodePoint === 'function';\nvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\nfunction decodeCharacterReferences(html) {\n  return html.replace(entityPattern, function (match, entity) {\n    var code; // Handle named entities\n\n    if (entity[0] !== '#') {\n      code = htmlEntities[entity];\n    } else if (entity[1] === 'x') {\n      code = parseInt(entity.substring(2), 16);\n    } else {\n      code = parseInt(entity.substring(1), 10);\n    }\n\n    if (!code) {\n      return match;\n    }\n\n    return codeToChar(validateCode(code));\n  });\n}\n\nvar lessThan = /</g;\nvar greaterThan = />/g;\nvar amp = /&/g;\nvar invalid = 65533;\n\nfunction escapeHtml(str) {\n  return str.replace(amp, '&amp;').replace(lessThan, '&lt;').replace(greaterThan, '&gt;');\n} // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\n/* istanbul ignore next */\n\n\nfunction validateCode(code) {\n  if (!code) {\n    return invalid;\n  } // line feed becomes generic whitespace\n\n\n  if (code === 10) {\n    return 32;\n  } // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\n\n  if (code < 128) {\n    return code;\n  } // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  // to correct the mistake or we'll end up with missing € signs and so on\n\n\n  if (code <= 159) {\n    return controlCharacters[code - 128];\n  } // basic multilingual plane\n\n\n  if (code < 55296) {\n    return code;\n  } // UTF-16 surrogate halves\n\n\n  if (code <= 57343) {\n    return invalid;\n  } // rest of the basic multilingual plane\n\n\n  if (code <= 65535) {\n    return code;\n  } else if (!codePointSupport) {\n    return invalid;\n  } // supplementary multilingual plane 0x10000 - 0x1ffff\n\n\n  if (code >= 65536 && code <= 131071) {\n    return code;\n  } // supplementary ideographic plane 0x20000 - 0x2ffff\n\n\n  if (code >= 131072 && code <= 196607) {\n    return code;\n  }\n\n  return invalid;\n}\n\nvar expectedExpression = 'Expected a JavaScript expression';\nvar expectedParen = 'Expected closing paren'; // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\n\nvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nfunction readNumberLiteral$1(parser) {\n  var result;\n\n  if (result = parser.matchPattern(numberPattern)) {\n    return {\n      t: NUMBER_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nfunction readBooleanLiteral(parser) {\n  var remaining = parser.remaining();\n\n  if (remaining.substr(0, 4) === 'true') {\n    parser.pos += 4;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'true'\n    };\n  }\n\n  if (remaining.substr(0, 5) === 'false') {\n    parser.pos += 5;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'false'\n    };\n  }\n\n  return null;\n} // Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\n\nvar stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/; // Match one escape sequence, including the backslash.\n\nvar escapeSequencePattern = /^\\\\(?:[`'\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/; // Match one ES5 line continuation (backslash + line terminator).\n\nvar lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/; // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\nvar makeQuotedStringMatcher = function makeQuotedStringMatcher(okQuote) {\n  return function (parser) {\n    var literal = '\"';\n    var done = false;\n    var next;\n\n    while (!done) {\n      next = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n\n      if (next) {\n        if (next === \"\\\"\") {\n          literal += \"\\\\\\\"\";\n        } else if (next === \"\\\\'\") {\n          literal += \"'\";\n        } else {\n          literal += next;\n        }\n      } else {\n        next = parser.matchPattern(lineContinuationPattern);\n\n        if (next) {\n          // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n          literal += \"\\\\u\" + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    literal += '\"'; // use JSON.parse to interpret escapes\n\n    return JSON.parse(literal);\n  };\n};\n\nvar singleMatcher = makeQuotedStringMatcher(\"\\\"\");\nvar doubleMatcher = makeQuotedStringMatcher(\"'\");\n\nvar readStringLiteral = function readStringLiteral(parser) {\n  var start = parser.pos;\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n\n  if (quote) {\n    var string = (quote === \"'\" ? singleMatcher : doubleMatcher)(parser);\n\n    if (!parser.matchString(quote)) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: STRING_LITERAL,\n      v: string\n    };\n  }\n\n  return null;\n}; // Match one or more characters until: \", ', or \\\n\n\nvar stringMiddlePattern$1 = /^[^`\"\\\\\\$]+?(?:(?=[`\"\\\\\\$]))/;\nvar escapes = /[\\r\\n\\t\\b\\f]/g;\n\nfunction getString(literal) {\n  return JSON.parse(\"\\\"\".concat(literal.replace(escapes, escapeChar), \"\\\"\"));\n}\n\nfunction escapeChar(c) {\n  switch (c) {\n    case '\\n':\n      return '\\\\n';\n\n    case '\\r':\n      return '\\\\r';\n\n    case '\\t':\n      return '\\\\t';\n\n    case '\\b':\n      return '\\\\b';\n\n    case '\\f':\n      return '\\\\f';\n  }\n}\n\nfunction readTemplateStringLiteral(parser) {\n  if (!parser.matchString('`')) return null;\n  var literal = '';\n  var done = false;\n  var next;\n  var parts = [];\n\n  while (!done) {\n    next = parser.matchPattern(stringMiddlePattern$1) || parser.matchPattern(escapeSequencePattern) || parser.matchString('$') || parser.matchString('\"');\n\n    if (next) {\n      if (next === \"\\\"\") {\n        literal += \"\\\\\\\"\";\n      } else if (next === '\\\\`') {\n        literal += '`';\n      } else if (next === '$') {\n        if (parser.matchString('{')) {\n          parts.push({\n            t: STRING_LITERAL,\n            v: getString(literal)\n          });\n          literal = '';\n          parser.allowWhitespace();\n          var expr = readExpression(parser);\n          if (!expr) parser.error('Expected valid expression');\n          parts.push({\n            t: BRACKETED,\n            x: expr\n          });\n          parser.allowWhitespace();\n          if (!parser.matchString('}')) parser.error(\"Expected closing '}' after interpolated expression\");\n        } else {\n          literal += '$';\n        }\n      } else {\n        literal += next;\n      }\n    } else {\n      next = parser.matchPattern(lineContinuationPattern);\n\n      if (next) {\n        // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n        literal += \"\\\\u\" + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n      } else {\n        done = true;\n      }\n    }\n  }\n\n  if (literal.length) parts.push({\n    t: STRING_LITERAL,\n    v: getString(literal)\n  });\n  if (!parser.matchString('`')) parser.error(\"Expected closing '`'\");\n\n  if (parts.length === 1) {\n    return parts[0];\n  } else {\n    var result = parts.pop();\n    var part;\n\n    while (part = parts.pop()) {\n      result = {\n        t: INFIX_OPERATOR,\n        s: '+',\n        o: [part, result]\n      };\n    }\n\n    return {\n      t: BRACKETED,\n      x: result\n    };\n  }\n}\n\nvar name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\nvar spreadPattern = /^\\s*\\.{3}/;\nvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*(?:\\.(?:[a-zA-Z_$][-\\/a-zA-Z_$0-9]*))*/;\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/; // http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\n\nfunction readKey(parser) {\n  var token;\n\n  if (token = readStringLiteral(parser)) {\n    return identifier.test(token.v) ? token.v : '\"' + token.v.replace(/\"/g, '\\\\\"') + '\"';\n  }\n\n  if (token = readNumberLiteral$1(parser)) {\n    return token.v;\n  }\n\n  if (token = parser.matchPattern(name)) {\n    return token;\n  }\n\n  return null;\n}\n\nfunction readKeyValuePair(parser) {\n  var spread;\n  var start = parser.pos; // allow whitespace between '{' and key\n\n  parser.allowWhitespace();\n  var refKey = parser.nextChar() !== '\\'' && parser.nextChar() !== '\"';\n  if (refKey) spread = parser.matchPattern(spreadPattern);\n  var key = spread ? readExpression(parser) : readKey(parser);\n\n  if (key === null) {\n    parser.pos = start;\n    return null;\n  } // allow whitespace between key and ':'\n\n\n  parser.allowWhitespace(); // es2015 shorthand property\n\n  if (refKey && (parser.nextChar() === ',' || parser.nextChar() === '}')) {\n    if (!spread && !name.test(key)) {\n      parser.error(\"Expected a valid reference, but found '\".concat(key, \"' instead.\"));\n    }\n\n    var pair = {\n      t: KEY_VALUE_PAIR,\n      k: key,\n      v: {\n        t: REFERENCE,\n        n: key\n      }\n    };\n\n    if (spread) {\n      pair.p = true;\n    }\n\n    return pair;\n  } // next character must be ':'\n\n\n  if (!parser.matchString(':')) {\n    parser.pos = start;\n    return null;\n  } // allow whitespace between ':' and value\n\n\n  parser.allowWhitespace(); // next expression must be a, well... expression\n\n  var value = readExpression(parser);\n\n  if (value === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: KEY_VALUE_PAIR,\n    k: key,\n    v: value\n  };\n}\n\nfunction readKeyValuePairs(parser) {\n  var start = parser.pos;\n  var pair = readKeyValuePair(parser);\n\n  if (pair === null) {\n    return null;\n  }\n\n  var pairs = [pair];\n\n  if (parser.matchString(',')) {\n    var keyValuePairs = readKeyValuePairs(parser);\n\n    if (!keyValuePairs) {\n      parser.pos = start;\n      return null;\n    }\n\n    return pairs.concat(keyValuePairs);\n  }\n\n  return pairs;\n}\n\nvar readObjectLiteral = function readObjectLiteral(parser) {\n  var start = parser.pos; // allow whitespace\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('{')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var keyValuePairs = readKeyValuePairs(parser); // allow whitespace between final value and '}'\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('}')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: OBJECT_LITERAL,\n    m: keyValuePairs\n  };\n};\n\nvar readArrayLiteral = function readArrayLiteral(parser) {\n  var start = parser.pos; // allow whitespace before '['\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('[')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var expressionList = readExpressionList(parser, true);\n\n  if (!parser.matchString(']')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: ARRAY_LITERAL,\n    m: expressionList\n  };\n};\n\nfunction readLiteral(parser) {\n  return readNumberLiteral$1(parser) || readBooleanLiteral(parser) || readStringLiteral(parser) || readTemplateStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readNumberLiteral(parser);\n} // if a reference is a browser global, we don't deference it later, so it needs special treatment\n\n\nvar globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/; // keywords are not valid references, with the exception of `this`\n\nvar keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\nvar prefixPattern = /^(?:\\@\\.|\\@|~\\/|(?:\\^\\^\\/(?:\\^\\^\\/)*(?:\\.\\.\\/)*)|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\nvar specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style)/;\n\nfunction readReference(parser) {\n  var prefix, name$$1, global, reference, lastDotIndex;\n  var startPos = parser.pos;\n  prefix = parser.matchPattern(prefixPattern) || '';\n  name$$1 = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n  var actual = prefix.length + (name$$1 && name$$1.length || 0);\n\n  if (prefix === '@.') {\n    prefix = '@';\n    if (name$$1) name$$1 = 'this.' + name$$1;else name$$1 = 'this';\n  }\n\n  if (!name$$1 && prefix) {\n    name$$1 = prefix;\n    prefix = '';\n  }\n\n  if (!name$$1) {\n    return null;\n  }\n\n  if (prefix === '@') {\n    if (!specials.test(name$$1)) {\n      parser.error(\"Unrecognized special reference @\".concat(name$$1));\n    } else if ((~name$$1.indexOf('event') || ~name$$1.indexOf('node')) && !parser.inEvent) {\n      parser.error(\"@event and @node are only valid references within an event directive\");\n    } else if (~name$$1.indexOf('context')) {\n      parser.pos = parser.pos - (name$$1.length - 7);\n      return {\n        t: BRACKETED,\n        x: {\n          t: REFERENCE,\n          n: '@context'\n        }\n      };\n    }\n  } // bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\n\n  if (!prefix && !parser.relaxedNames && keywords.test(name$$1)) {\n    parser.pos = startPos;\n    return null;\n  } // if this is a browser global, stop here\n\n\n  if (!prefix && globals.test(name$$1)) {\n    global = globals.exec(name$$1)[0];\n    parser.pos = startPos + global.length;\n    return {\n      t: GLOBAL,\n      v: global\n    };\n  }\n\n  reference = (prefix || '') + normalise(name$$1);\n\n  if (parser.matchString('(')) {\n    // if this is a method invocation (as opposed to a function) we need\n    // to strip the method name from the reference combo, else the context\n    // will be wrong\n    // but only if the reference was actually a member and not a refinement\n    lastDotIndex = reference.lastIndexOf('.');\n\n    if (lastDotIndex !== -1 && name$$1[name$$1.length - 1] !== ']') {\n      if (lastDotIndex === 0) {\n        reference = '.';\n        parser.pos = startPos;\n      } else {\n        var refLength = reference.length;\n        reference = reference.substr(0, lastDotIndex);\n        parser.pos = startPos + (actual - (refLength - lastDotIndex));\n      }\n    } else {\n      parser.pos -= 1;\n    }\n  }\n\n  return {\n    t: REFERENCE,\n    n: reference.replace(/^this\\./, './').replace(/^this$/, '.')\n  };\n}\n\nfunction readBracketedExpression(parser) {\n  if (!parser.matchString('(')) return null;\n  parser.allowWhitespace();\n  var expr = readExpression(parser);\n  if (!expr) parser.error(expectedExpression);\n  parser.allowWhitespace();\n  if (!parser.matchString(')')) parser.error(expectedParen);\n  return {\n    t: BRACKETED,\n    x: expr\n  };\n}\n\nvar readPrimary = function readPrimary(parser) {\n  return readLiteral(parser) || readReference(parser) || readBracketedExpression(parser);\n};\n\nfunction readRefinement(parser) {\n  // some things call for strict refinement (partial names), meaning no space between reference and refinement\n  if (!parser.strictRefinement) {\n    parser.allowWhitespace();\n  } // \".\" name\n\n\n  if (parser.matchString('.')) {\n    parser.allowWhitespace();\n    var name$$1 = parser.matchPattern(name);\n\n    if (name$$1) {\n      return {\n        t: REFINEMENT,\n        n: name$$1\n      };\n    }\n\n    parser.error('Expected a property name');\n  } // \"[\" expression \"]\"\n\n\n  if (parser.matchString('[')) {\n    parser.allowWhitespace();\n    var expr = readExpression(parser);\n    if (!expr) parser.error(expectedExpression);\n    parser.allowWhitespace();\n    if (!parser.matchString(']')) parser.error(\"Expected ']'\");\n    return {\n      t: REFINEMENT,\n      x: expr\n    };\n  }\n\n  return null;\n}\n\nvar readMemberOrInvocation = function readMemberOrInvocation(parser) {\n  var expression = readPrimary(parser);\n  if (!expression) return null;\n\n  while (expression) {\n    var refinement = readRefinement(parser);\n\n    if (refinement) {\n      expression = {\n        t: MEMBER,\n        x: expression,\n        r: refinement\n      };\n    } else if (parser.matchString('(')) {\n      parser.allowWhitespace();\n      var expressionList = readExpressionList(parser, true);\n      parser.allowWhitespace();\n\n      if (!parser.matchString(')')) {\n        parser.error(expectedParen);\n      }\n\n      expression = {\n        t: INVOCATION,\n        x: expression\n      };\n      if (expressionList) expression.o = expressionList;\n    } else {\n      break;\n    }\n  }\n\n  return expression;\n};\n\nvar readTypeOf;\n\nvar makePrefixSequenceMatcher = function makePrefixSequenceMatcher(symbol, fallthrough) {\n  return function (parser) {\n    var expression;\n\n    if (expression = fallthrough(parser)) {\n      return expression;\n    }\n\n    if (!parser.matchString(symbol)) {\n      return null;\n    }\n\n    parser.allowWhitespace();\n    expression = readExpression(parser);\n\n    if (!expression) {\n      parser.error(expectedExpression);\n    }\n\n    return {\n      s: symbol,\n      o: expression,\n      t: PREFIX_OPERATOR\n    };\n  };\n}; // create all prefix sequence matchers, return readTypeOf\n\n\n(function () {\n  var i, len, matcher, fallthrough;\n  var prefixOperators = '! ~ + - typeof'.split(' ');\n  fallthrough = readMemberOrInvocation;\n\n  for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n    matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n    fallthrough = matcher;\n  } // typeof operator is higher precedence than multiplication, so provides the\n  // fallthrough for the multiplication sequence matcher we're about to create\n  // (we're skipping void and delete)\n\n\n  readTypeOf = fallthrough;\n})();\n\nvar readTypeof = readTypeOf;\nvar readLogicalOr;\n\nvar makeInfixSequenceMatcher = function makeInfixSequenceMatcher(symbol, fallthrough) {\n  return function (parser) {\n    // > and / have to be quoted\n    if (parser.inUnquotedAttribute && (symbol === '>' || symbol === '/')) return fallthrough(parser);\n    var start, left, right;\n    left = fallthrough(parser);\n\n    if (!left) {\n      return null;\n    } // Loop to handle left-recursion in a case like `a * b * c` and produce\n    // left association, i.e. `(a * b) * c`.  The matcher can't call itself\n    // to parse `left` because that would be infinite regress.\n\n\n    while (true) {\n      start = parser.pos;\n      parser.allowWhitespace();\n\n      if (!parser.matchString(symbol)) {\n        parser.pos = start;\n        return left;\n      } // special case - in operator must not be followed by [a-zA-Z_$0-9]\n\n\n      if (symbol === 'in' && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n        parser.pos = start;\n        return left;\n      }\n\n      parser.allowWhitespace(); // right operand must also consist of only higher-precedence operators\n\n      right = fallthrough(parser);\n\n      if (!right) {\n        parser.pos = start;\n        return left;\n      }\n\n      left = {\n        t: INFIX_OPERATOR,\n        s: symbol,\n        o: [left, right]\n      }; // Loop back around.  If we don't see another occurrence of the symbol,\n      // we'll return left.\n    }\n  };\n}; // create all infix sequence matchers, and return readLogicalOr\n\n\n(function () {\n  var i, len, matcher, fallthrough; // All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  // Each sequence matcher will initially fall through to its higher precedence\n  // neighbour, and only attempt to match if one of the higher precedence operators\n  // (or, ultimately, a literal, reference, or bracketed expression) already matched\n\n  var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split(' '); // A typeof operator is higher precedence than multiplication\n\n  fallthrough = readTypeof;\n\n  for (i = 0, len = infixOperators.length; i < len; i += 1) {\n    matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n    fallthrough = matcher;\n  } // Logical OR is the fallthrough for the conditional matcher\n\n\n  readLogicalOr = fallthrough;\n})();\n\nvar readLogicalOr$1 = readLogicalOr; // The conditional operator is the lowest precedence operator, so we start here\n\nfunction getConditional(parser) {\n  var expression = readLogicalOr$1(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  var start = parser.pos;\n  parser.allowWhitespace();\n\n  if (!parser.matchString('?')) {\n    parser.pos = start;\n    return expression;\n  }\n\n  parser.allowWhitespace();\n  var ifTrue = readExpression(parser);\n\n  if (!ifTrue) {\n    parser.error(expectedExpression);\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString(':')) {\n    parser.error('Expected \":\"');\n  }\n\n  parser.allowWhitespace();\n  var ifFalse = readExpression(parser);\n\n  if (!ifFalse) {\n    parser.error(expectedExpression);\n  }\n\n  return {\n    t: CONDITIONAL,\n    o: [expression, ifTrue, ifFalse]\n  };\n}\n\nfunction readExpression(parser) {\n  // The conditional operator is the lowest precedence operator (except yield,\n  // assignment operators, and commas, none of which are supported), so we\n  // start there. If it doesn't match, it 'falls through' to progressively\n  // higher precedence operators, until it eventually matches (or fails to\n  // match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  return getConditional(parser);\n}\n\nfunction readExpressionList(parser, spread) {\n  var isSpread;\n  var expressions = [];\n  var pos = parser.pos;\n\n  do {\n    parser.allowWhitespace();\n\n    if (spread) {\n      isSpread = parser.matchPattern(spreadPattern);\n    }\n\n    var expr = readExpression(parser);\n\n    if (expr === null && expressions.length) {\n      parser.error(expectedExpression);\n    } else if (expr === null) {\n      parser.pos = pos;\n      return null;\n    }\n\n    if (isSpread) {\n      expr.p = true;\n    }\n\n    expressions.push(expr);\n    parser.allowWhitespace();\n  } while (parser.matchString(','));\n\n  return expressions;\n}\n\nfunction readExpressionOrReference(parser, expectedFollowers) {\n  var start = parser.pos;\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    // valid reference but invalid expression e.g. `{{new}}`?\n    var ref = parser.matchPattern(/^(\\w+)/);\n\n    if (ref) {\n      return {\n        t: REFERENCE,\n        n: ref\n      };\n    }\n\n    return null;\n  }\n\n  for (var _i17 = 0; _i17 < expectedFollowers.length; _i17 += 1) {\n    if (parser.remaining().substr(0, expectedFollowers[_i17].length) === expectedFollowers[_i17]) {\n      return expression;\n    }\n  }\n\n  parser.pos = start;\n  return readReference(parser);\n}\n\nfunction flattenExpression(expression) {\n  var refs;\n  var count = 0;\n  extractRefs(expression, refs = []);\n  var stringified = stringify(expression);\n  return {\n    r: refs,\n    s: getVars(stringified)\n  };\n\n  function getVars(expr) {\n    var vars = [];\n\n    for (var _i18 = count - 1; _i18 >= 0; _i18--) {\n      vars.push(\"x$\".concat(_i18));\n    }\n\n    return vars.length ? \"(function(){var \".concat(vars.join(','), \";return(\").concat(expr, \");})()\") : expr;\n  }\n\n  function stringify(node) {\n    if (typeof node === 'string') {\n      return node;\n    }\n\n    switch (node.t) {\n      case BOOLEAN_LITERAL:\n      case GLOBAL:\n      case NUMBER_LITERAL:\n      case REGEXP_LITERAL:\n        return node.v;\n\n      case STRING_LITERAL:\n        return JSON.stringify(String(node.v));\n\n      case ARRAY_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return \"[].concat(\".concat(makeSpread(node.m, '[', ']', stringify), \")\");\n        } else {\n          return '[' + (node.m ? node.m.map(stringify).join(',') : '') + ']';\n        }\n\n      case OBJECT_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return \"Object.assign({},\".concat(makeSpread(node.m, '{', '}', stringifyPair), \")\");\n        } else {\n          return '{' + (node.m ? node.m.map(function (n) {\n            return \"\".concat(n.k, \":\").concat(stringify(n.v));\n          }).join(',') : '') + '}';\n        }\n\n      case PREFIX_OPERATOR:\n        return (node.s === 'typeof' ? 'typeof ' : node.s) + stringify(node.o);\n\n      case INFIX_OPERATOR:\n        return stringify(node.o[0]) + (node.s.substr(0, 2) === 'in' ? ' ' + node.s + ' ' : node.s) + stringify(node.o[1]);\n\n      case INVOCATION:\n        if (node.o && hasSpread(node.o)) {\n          var id = count++;\n          return \"(x$\".concat(id, \"=\").concat(stringify(node.x), \").apply(x$\").concat(id, \",\").concat(stringify({\n            t: ARRAY_LITERAL,\n            m: node.o\n          }), \")\");\n        } else {\n          return stringify(node.x) + '(' + (node.o ? node.o.map(stringify).join(',') : '') + ')';\n        }\n\n      case BRACKETED:\n        return '(' + stringify(node.x) + ')';\n\n      case MEMBER:\n        return stringify(node.x) + stringify(node.r);\n\n      case REFINEMENT:\n        return node.n ? '.' + node.n : '[' + stringify(node.x) + ']';\n\n      case CONDITIONAL:\n        return stringify(node.o[0]) + '?' + stringify(node.o[1]) + ':' + stringify(node.o[2]);\n\n      case REFERENCE:\n        return '_' + refs.indexOf(node.n);\n\n      default:\n        throw new Error('Expected legal JavaScript');\n    }\n  }\n\n  function stringifyPair(node) {\n    return node.p ? stringify(node.k) : \"\".concat(node.k, \":\").concat(stringify(node.v));\n  }\n\n  function makeSpread(list, open, close, fn) {\n    var out = list.reduce(function (a, c) {\n      if (c.p) {\n        a.str += \"\".concat(a.open ? close + ',' : a.str.length ? ',' : '').concat(fn(c));\n      } else {\n        a.str += \"\".concat(!a.str.length ? open : !a.open ? ',' + open : ',').concat(fn(c));\n      }\n\n      a.open = !c.p;\n      return a;\n    }, {\n      open: false,\n      str: ''\n    });\n    if (out.open) out.str += close;\n    return out.str;\n  }\n}\n\nfunction hasSpread(list) {\n  for (var _i19 = 0; _i19 < list.length; _i19++) {\n    if (list[_i19].p) return true;\n  }\n\n  return false;\n} // TODO maybe refactor this?\n\n\nfunction extractRefs(node, refs) {\n  if (node.t === REFERENCE && typeof node.n === 'string') {\n    if (!~refs.indexOf(node.n)) {\n      refs.unshift(node.n);\n    }\n  }\n\n  var list = node.o || node.m;\n\n  if (list) {\n    if (isObject(list)) {\n      extractRefs(list, refs);\n    } else {\n      var _i20 = list.length;\n\n      while (_i20--) {\n        extractRefs(list[_i20], refs);\n      }\n    }\n  }\n\n  if (node.k && node.t === KEY_VALUE_PAIR && typeof node.k !== 'string') {\n    extractRefs(node.k, refs);\n  }\n\n  if (node.x) {\n    extractRefs(node.x, refs);\n  }\n\n  if (node.r) {\n    extractRefs(node.r, refs);\n  }\n\n  if (node.v) {\n    extractRefs(node.v, refs);\n  }\n}\n\nfunction refineExpression(expression, mustache) {\n  var referenceExpression;\n\n  if (expression) {\n    while (expression.t === BRACKETED && expression.x) {\n      expression = expression.x;\n    }\n\n    if (expression.t === REFERENCE) {\n      var n = expression.n;\n\n      if (!~n.indexOf('@context')) {\n        mustache.r = expression.n;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    } else {\n      if (referenceExpression = getReferenceExpression(expression)) {\n        mustache.rx = referenceExpression;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    }\n\n    return mustache;\n  }\n} // TODO refactor this! it's bewildering\n\n\nfunction getReferenceExpression(expression) {\n  var members = [];\n  var refinement;\n\n  while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n    refinement = expression.r;\n\n    if (refinement.x) {\n      if (refinement.x.t === REFERENCE) {\n        members.unshift(refinement.x);\n      } else {\n        members.unshift(flattenExpression(refinement.x));\n      }\n    } else {\n      members.unshift(refinement.n);\n    }\n\n    expression = expression.x;\n  }\n\n  if (expression.t !== REFERENCE) {\n    return null;\n  }\n\n  return {\n    r: expression.n,\n    m: members\n  };\n}\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=]+/;\nvar onPattern = /^on/;\nvar eventPattern = /^on-([a-zA-Z\\*\\.$_]((?:[a-zA-Z\\*\\.$_0-9\\-]|\\\\-)+))$/;\nvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;\nvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\nvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\nvar boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;\nvar directives = {\n  lazy: {\n    t: BINDING_FLAG,\n    v: 'l'\n  },\n  twoway: {\n    t: BINDING_FLAG,\n    v: 't'\n  },\n  'no-delegation': {\n    t: DELEGATE_FLAG\n  }\n};\nvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\nvar proxyEvent = /^[^\\s\"'=<>@\\[\\]()]*/;\nvar whitespace = /^\\s+/;\nvar slashes = /\\\\/g;\n\nfunction splitEvent(str) {\n  var result = [];\n  var s = 0;\n\n  for (var _i21 = 0; _i21 < str.length; _i21++) {\n    if (str[_i21] === '-' && str[_i21 - 1] !== '\\\\') {\n      result.push(str.substring(s, _i21).replace(slashes, ''));\n      s = _i21 + 1;\n    }\n  }\n\n  result.push(str.substring(s).replace(slashes, ''));\n  return result;\n}\n\nfunction readAttribute(parser) {\n  var name, i, nearest, idx;\n  parser.allowWhitespace();\n  name = parser.matchPattern(attributeNamePattern);\n\n  if (!name) {\n    return null;\n  } // check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n\n\n  nearest = name.length;\n\n  for (i = 0; i < parser.tags.length; i++) {\n    if (~(idx = name.indexOf(parser.tags[i].open))) {\n      if (idx < nearest) nearest = idx;\n    }\n  }\n\n  if (nearest < name.length) {\n    parser.pos -= name.length - nearest;\n    name = name.substr(0, nearest);\n    if (!name) return null;\n  }\n\n  return {\n    n: name\n  };\n}\n\nfunction readAttributeValue(parser) {\n  var start = parser.pos; // next character must be `=`, `/`, `>` or whitespace\n\n  if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n    parser.error('Expected `=`, `/`, `>` or whitespace');\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.allowWhitespace();\n  var valueStart = parser.pos;\n  var startDepth = parser.sectionDepth;\n  var value = readQuotedAttributeValue(parser, \"'\") || readQuotedAttributeValue(parser, \"\\\"\") || readUnquotedAttributeValue(parser);\n\n  if (value === null) {\n    parser.error('Expected valid attribute value');\n  }\n\n  if (parser.sectionDepth !== startDepth) {\n    parser.pos = valueStart;\n    parser.error('An attribute value must contain as many opening section tags as closing section tags');\n  }\n\n  if (!value.length) {\n    return '';\n  }\n\n  if (value.length === 1 && typeof value[0] === 'string') {\n    return decodeCharacterReferences(value[0]);\n  }\n\n  return value;\n}\n\nfunction readUnquotedAttributeValueToken(parser) {\n  var text, index;\n  var start = parser.pos;\n  text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  if (!text) {\n    return null;\n  }\n\n  var haystack = text;\n  var needles = parser.tags.map(function (t) {\n    return t.open;\n  }); // TODO refactor... we do this in readText.js as well\n\n  if ((index = getLowestIndex(haystack, needles)) !== -1) {\n    text = text.substr(0, index);\n    parser.pos = start + text.length;\n  }\n\n  return text;\n}\n\nfunction readUnquotedAttributeValue(parser) {\n  parser.inAttribute = true;\n  var tokens = [];\n  var token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n\n  while (token) {\n    tokens.push(token);\n    token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  }\n\n  if (!tokens.length) {\n    return null;\n  }\n\n  parser.inAttribute = false;\n  return tokens;\n}\n\nfunction readQuotedAttributeValue(parser, quoteMark) {\n  var start = parser.pos;\n\n  if (!parser.matchString(quoteMark)) {\n    return null;\n  }\n\n  parser.inAttribute = quoteMark;\n  var tokens = [];\n  var token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n\n  while (token !== null) {\n    tokens.push(token);\n    token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  }\n\n  if (!parser.matchString(quoteMark)) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.inAttribute = false;\n  return tokens;\n}\n\nfunction readQuotedStringToken(parser, quoteMark) {\n  var haystack = parser.remaining();\n  var needles = parser.tags.map(function (t) {\n    return t.open;\n  }); // TODO refactor... we do this in readText.js as well\n\n  needles.push(quoteMark);\n  var index = getLowestIndex(haystack, needles);\n\n  if (index === -1) {\n    parser.error('Quoted attribute value must have a closing quote');\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  parser.pos += index;\n  return haystack.substr(0, index);\n}\n\nfunction readAttributeOrDirective(parser) {\n  var match, directive;\n  var attribute = readAttribute(parser, false);\n  if (!attribute) return null; // lazy, twoway\n\n  if (directive = directives[attribute.n]) {\n    attribute.t = directive.t;\n    if (directive.v) attribute.v = directive.v;\n    delete attribute.n; // no name necessary\n\n    parser.allowWhitespace();\n    if (parser.nextChar() === '=') attribute.f = readAttributeValue(parser);\n  } // decorators\n  else if (match = decoratorPattern.exec(attribute.n)) {\n      attribute.n = match[1];\n      attribute.t = DECORATOR;\n      readArguments(parser, attribute);\n    } // transitions\n    else if (match = transitionPattern.exec(attribute.n)) {\n        attribute.n = match[1];\n        attribute.t = TRANSITION;\n        readArguments(parser, attribute);\n        attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n      } // on-click etc\n      else if (match = eventPattern.exec(attribute.n)) {\n          attribute.n = splitEvent(match[1]);\n          attribute.t = EVENT;\n          parser.inEvent = true; // check for a proxy event\n\n          if (!readProxyEvent(parser, attribute)) {\n            // otherwise, it's an expression\n            readArguments(parser, attribute, true);\n          } else if (reservedEventNames.test(attribute.f)) {\n            parser.pos -= attribute.f.length;\n            parser.error('Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)');\n          }\n\n          parser.inEvent = false;\n        } // bound directives\n        else if (match = boundPattern.exec(attribute.n)) {\n            var _bind = match[2] === 'bind';\n\n            attribute.n = _bind ? match[3] : match[1];\n            attribute.t = ATTRIBUTE;\n            readArguments(parser, attribute, false, true);\n\n            if (!attribute.f && _bind) {\n              attribute.f = [{\n                t: INTERPOLATOR,\n                r: match[3]\n              }];\n            }\n          } else {\n            parser.allowWhitespace();\n\n            var _value5 = parser.nextChar() === '=' ? readAttributeValue(parser) : null;\n\n            attribute.f = _value5 != null ? _value5 : attribute.f;\n\n            if (parser.sanitizeEventAttributes && onPattern.test(attribute.n)) {\n              return {\n                exclude: true\n              };\n            } else {\n              attribute.f = attribute.f || (attribute.f === '' ? '' : 0);\n              attribute.t = ATTRIBUTE;\n            }\n          }\n\n  return attribute;\n}\n\nfunction readProxyEvent(parser, attribute) {\n  var start = parser.pos;\n  if (!parser.matchString('=')) parser.error(\"Missing required directive arguments\");\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n  parser.allowWhitespace();\n  var proxy = parser.matchPattern(proxyEvent);\n\n  if (proxy !== undefined) {\n    if (quote) {\n      parser.allowWhitespace();\n      if (!parser.matchString(quote)) parser.pos = start;else return (attribute.f = proxy) || true;\n    } else if (!parser.matchPattern(whitespace)) {\n      parser.pos = start;\n    } else {\n      return (attribute.f = proxy) || true;\n    }\n  } else {\n    parser.pos = start;\n  }\n}\n\nfunction readArguments(parser, attribute) {\n  var required = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var single = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  parser.allowWhitespace();\n\n  if (!parser.matchString('=')) {\n    if (required) parser.error(\"Missing required directive arguments\");\n    return;\n  }\n\n  parser.allowWhitespace();\n  var quote = parser.matchString('\"') || parser.matchString(\"'\");\n  var spread = parser.spreadArgs;\n  parser.spreadArgs = true;\n  parser.inUnquotedAttribute = !quote;\n  var expr = single ? readExpressionOrReference(parser, [quote || ' ', '/', '>']) : {\n    m: readExpressionList(parser),\n    t: ARRAY_LITERAL\n  };\n  parser.inUnquotedAttribute = false;\n  parser.spreadArgs = spread;\n\n  if (quote) {\n    parser.allowWhitespace();\n    if (parser.matchString(quote) !== quote) parser.error(\"Expected matching quote '\".concat(quote, \"'\"));\n  }\n\n  if (single) {\n    var interpolator = {\n      t: INTERPOLATOR\n    };\n    refineExpression(expr, interpolator);\n    attribute.f = [interpolator];\n  } else {\n    attribute.f = flattenExpression(expr);\n  }\n}\n\nvar delimiterChangeToken = {\n  t: DELIMCHANGE,\n  exclude: true\n};\n\nfunction readMustache(parser) {\n  var mustache, i; // If we're inside a <script> or <style> tag, and we're not\n  // interpolating, bug out\n\n  if (parser.interpolate[parser.inside] === false) {\n    return null;\n  }\n\n  for (i = 0; i < parser.tags.length; i += 1) {\n    if (mustache = readMustacheOfType(parser, parser.tags[i])) {\n      return mustache;\n    }\n  }\n\n  if (parser.inTag && !parser.inAttribute) {\n    mustache = readAttributeOrDirective(parser);\n\n    if (mustache) {\n      parser.allowWhitespace();\n      return mustache;\n    }\n  }\n}\n\nfunction readMustacheOfType(parser, tag) {\n  var mustache, reader, i;\n  var start = parser.pos;\n\n  if (parser.matchString('\\\\' + tag.open)) {\n    if (start === 0 || parser.str[start - 1] !== '\\\\') {\n      return tag.open;\n    }\n  } else if (!parser.matchString(tag.open)) {\n    return null;\n  } // delimiter change?\n\n\n  if (mustache = readDelimiterChange(parser)) {\n    // find closing delimiter or abort...\n    if (!parser.matchString(tag.close)) {\n      return null;\n    } // ...then make the switch\n\n\n    tag.open = mustache[0];\n    tag.close = mustache[1];\n    parser.sortMustacheTags();\n    return delimiterChangeToken;\n  }\n\n  parser.allowWhitespace(); // illegal section closer\n\n  if (parser.matchString('/')) {\n    parser.pos -= 1;\n    var rewind = parser.pos;\n\n    if (!readNumberLiteral(parser)) {\n      parser.pos = rewind - tag.close.length;\n\n      if (parser.inAttribute) {\n        parser.pos = start;\n        return null;\n      } else {\n        parser.error('Attempted to close a section that wasn\\'t open');\n      }\n    } else {\n      parser.pos = rewind;\n    }\n  }\n\n  for (i = 0; i < tag.readers.length; i += 1) {\n    reader = tag.readers[i];\n\n    if (mustache = reader(parser, tag)) {\n      if (tag.isStatic) {\n        mustache.s = 1;\n      }\n\n      if (parser.includeLinePositions) {\n        mustache.p = parser.getLinePos(start);\n      }\n\n      return mustache;\n    }\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readTriple(parser, tag) {\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  var triple = {\n    t: TRIPLE\n  };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nfunction readUnescaped(parser, tag) {\n  if (!parser.matchString('&')) {\n    return null;\n  }\n\n  parser.allowWhitespace();\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  var triple = {\n    t: TRIPLE\n  };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar asRE = /^as/i;\n\nfunction readAliases(parser) {\n  var aliases = [];\n  var alias;\n  var start = parser.pos;\n  parser.allowWhitespace();\n  alias = readAlias(parser);\n\n  if (alias) {\n    alias.x = refineExpression(alias.x, {});\n    aliases.push(alias);\n    parser.allowWhitespace();\n\n    while (parser.matchString(',')) {\n      alias = readAlias(parser);\n\n      if (!alias) {\n        parser.error('Expected another alias.');\n      }\n\n      alias.x = refineExpression(alias.x, {});\n      aliases.push(alias);\n      parser.allowWhitespace();\n    }\n\n    return aliases;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readAlias(parser) {\n  var start = parser.pos;\n  parser.allowWhitespace();\n  var expr = readExpression(parser, []);\n\n  if (!expr) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchPattern(asRE)) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.allowWhitespace();\n  var alias = parser.matchPattern(legalAlias);\n\n  if (!alias) {\n    parser.error('Expected a legal alias name.');\n  }\n\n  return {\n    n: alias,\n    x: expr\n  };\n}\n\nfunction readPartial(parser, tag) {\n  var type = parser.matchString('>') || parser.matchString('yield');\n  var partial = {\n    t: type === '>' ? PARTIAL : YIELDER\n  };\n  var aliases;\n  if (!type) return null;\n  parser.allowWhitespace();\n\n  if (type === '>' || !(aliases = parser.matchString('with'))) {\n    // Partial names can include hyphens, so we can't use readExpression\n    // blindly. Instead, we use the `relaxedNames` flag to indicate that\n    // `foo-bar` should be read as a single name, rather than 'subtract\n    // bar from foo'\n    parser.relaxedNames = parser.strictRefinement = true;\n    var expression = readExpression(parser);\n    parser.relaxedNames = parser.strictRefinement = false;\n    if (!expression && type === '>') return null;\n\n    if (expression) {\n      refineExpression(expression, partial); // TODO...\n\n      parser.allowWhitespace();\n      if (type !== '>') aliases = parser.matchString('with');\n    }\n  }\n\n  parser.allowWhitespace(); // check for alias context e.g. `{{>foo bar as bat, bip as bop}}`\n\n  if (aliases || type === '>') {\n    aliases = readAliases(parser);\n\n    if (aliases && aliases.length) {\n      partial.z = aliases;\n    } // otherwise check for literal context e.g. `{{>foo bar}}` then\n    // turn it into `{{#with bar}}{{>foo}}{{/with}}`\n    else if (type === '>') {\n        var context = readExpression(parser);\n\n        if (context) {\n          partial.c = {};\n          refineExpression(context, partial.c);\n        }\n      } else {\n        // {{yield with}} requires some aliases\n        parser.error(\"Expected one or more aliases\");\n      }\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  return partial;\n}\n\nfunction readComment(parser, tag) {\n  if (!parser.matchString('!')) {\n    return null;\n  }\n\n  var index = parser.remaining().indexOf(tag.close);\n\n  if (index !== -1) {\n    parser.pos += index + tag.close.length;\n    return {\n      t: COMMENT\n    };\n  }\n}\n\nfunction readInterpolator(parser, tag) {\n  var expression, err;\n  var start = parser.pos; // TODO would be good for perf if we could do away with the try-catch\n\n  try {\n    expression = readExpressionOrReference(parser, [tag.close]);\n  } catch (e) {\n    err = e;\n  }\n\n  if (!expression) {\n    if (parser.str.charAt(start) === '!') {\n      // special case - comment\n      parser.pos = start;\n      return null;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"' after reference\"));\n\n    if (!expression) {\n      // special case - comment\n      if (parser.nextChar() === '!') {\n        return null;\n      }\n\n      parser.error(\"Expected expression or legal reference\");\n    }\n  }\n\n  var interpolator = {\n    t: INTERPOLATOR\n  };\n  refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  return interpolator;\n}\n\nfunction readClosing(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('/')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.allowWhitespace();\n  var remaining = parser.remaining();\n  var index = remaining.indexOf(tag.close);\n\n  if (index !== -1) {\n    var closing = {\n      t: CLOSING,\n      r: remaining.substr(0, index).split(' ')[0]\n    };\n    parser.pos += index;\n\n    if (!parser.matchString(tag.close)) {\n      parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n    }\n\n    return closing;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nvar elsePattern = /^\\s*else\\s*/;\n\nfunction readElse(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  if (!parser.matchPattern(elsePattern)) {\n    parser.pos = start;\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  return {\n    t: ELSE\n  };\n}\n\nvar elsePattern$1 = /^\\s*elseif\\s+/;\n\nfunction readElseIf(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  if (!parser.matchPattern(elsePattern$1)) {\n    parser.pos = start;\n    return null;\n  }\n\n  var expression = readExpression(parser);\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  return {\n    t: ELSEIF,\n    x: expression\n  };\n}\n\nvar handlebarsBlockCodes = {\n  each: SECTION_EACH,\n  \"if\": SECTION_IF,\n  \"with\": SECTION_IF_WITH,\n  unless: SECTION_UNLESS\n};\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar handlebarsBlockPattern = new RegExp('^(' + Object.keys(handlebarsBlockCodes).join('|') + ')\\\\b');\n\nfunction readSection(parser, tag) {\n  var expression, section, child, children, hasElse, block, unlessBlock, closed, i, expectedClose;\n  var aliasOnly = false;\n  var start = parser.pos;\n\n  if (parser.matchString('^')) {\n    // watch out for parent context refs - {{^^/^^/foo}}\n    if (parser.matchString('^/')) {\n      parser.pos = start;\n      return null;\n    }\n\n    section = {\n      t: SECTION,\n      f: [],\n      n: SECTION_UNLESS\n    };\n  } else if (parser.matchString('#')) {\n    section = {\n      t: SECTION,\n      f: []\n    };\n\n    if (parser.matchString('partial')) {\n      parser.pos = start - parser.standardDelimiters[0].length;\n      parser.error('Partial definitions can only be at the top level of the template, or immediately inside components');\n    }\n\n    if (block = parser.matchPattern(handlebarsBlockPattern)) {\n      expectedClose = block;\n      section.n = handlebarsBlockCodes[block];\n    }\n  } else {\n    return null;\n  }\n\n  parser.allowWhitespace();\n\n  if (block === 'with') {\n    var aliases = readAliases(parser);\n\n    if (aliases) {\n      aliasOnly = true;\n      section.z = aliases;\n      section.t = ALIAS;\n    }\n  } else if (block === 'each') {\n    var alias = readAlias(parser);\n\n    if (alias) {\n      section.z = [{\n        n: alias.n,\n        x: {\n          r: '.'\n        }\n      }];\n      expression = alias.x;\n    }\n  }\n\n  if (!aliasOnly) {\n    if (!expression) expression = readExpression(parser);\n\n    if (!expression) {\n      parser.error('Expected expression');\n    } // optional index and key references\n\n\n    if (i = parser.matchPattern(indexRefPattern)) {\n      var extra;\n\n      if (extra = parser.matchPattern(keyIndexRefPattern)) {\n        section.i = i + ',' + extra;\n      } else {\n        section.i = i;\n      }\n    }\n\n    if (!block && expression.n) {\n      expectedClose = expression.n;\n    }\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error(\"Expected closing delimiter '\".concat(tag.close, \"'\"));\n  }\n\n  parser.sectionDepth += 1;\n  children = section.f;\n  var pos;\n\n  do {\n    pos = parser.pos;\n\n    if (child = readClosing(parser, tag)) {\n      if (expectedClose && child.r !== expectedClose) {\n        if (!block) {\n          if (child.r) parser.warn(\"Expected \".concat(tag.open, \"/\").concat(expectedClose).concat(tag.close, \" but found \").concat(tag.open, \"/\").concat(child.r).concat(tag.close));\n        } else {\n          parser.pos = pos;\n          parser.error(\"Expected \".concat(tag.open, \"/\").concat(expectedClose).concat(tag.close));\n        }\n      }\n\n      parser.sectionDepth -= 1;\n      closed = true;\n    } else if (!aliasOnly && (child = readElseIf(parser, tag))) {\n      if (section.n === SECTION_UNLESS) {\n        parser.error('{{else}} not allowed in {{#unless}}');\n      }\n\n      if (hasElse) {\n        parser.error('illegal {{elseif...}} after {{else}}');\n      }\n\n      if (!unlessBlock) {\n        unlessBlock = [];\n      }\n\n      var _mustache = {\n        t: SECTION,\n        n: SECTION_IF,\n        f: children = []\n      };\n      refineExpression(child.x, _mustache);\n      unlessBlock.push(_mustache);\n    } else if (!aliasOnly && (child = readElse(parser, tag))) {\n      if (section.n === SECTION_UNLESS) {\n        parser.error('{{else}} not allowed in {{#unless}}');\n      }\n\n      if (hasElse) {\n        parser.error('there can only be one {{else}} block, at the end of a section');\n      }\n\n      hasElse = true; // use an unless block if there's no elseif\n\n      if (!unlessBlock) {\n        unlessBlock = [];\n      }\n\n      unlessBlock.push({\n        t: SECTION,\n        n: SECTION_UNLESS,\n        f: children = []\n      });\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        break;\n      }\n\n      children.push(child);\n    }\n  } while (!closed);\n\n  if (unlessBlock) {\n    section.l = unlessBlock;\n  }\n\n  if (!aliasOnly) {\n    refineExpression(expression, section);\n  } // TODO if a section is empty it should be discarded. Don't do\n  // that here though - we need to clean everything up first, as\n  // it may contain removeable whitespace. As a temporary measure,\n  // to pass the existing tests, remove empty `f` arrays\n\n\n  if (!section.f.length) {\n    delete section.f;\n  }\n\n  return section;\n}\n\nvar OPEN_COMMENT = '<!--';\nvar CLOSE_COMMENT = '-->';\n\nfunction readHtmlComment(parser) {\n  var start = parser.pos;\n\n  if (parser.textOnlyMode || !parser.matchString(OPEN_COMMENT)) {\n    return null;\n  }\n\n  var remaining = parser.remaining();\n  var endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  if (endIndex === -1) {\n    parser.error('Illegal HTML - expected closing comment sequence (\\'-->\\')');\n  }\n\n  var content = remaining.substr(0, endIndex);\n  parser.pos += endIndex + 3;\n  var comment = {\n    t: COMMENT,\n    c: content\n  };\n\n  if (parser.includeLinePositions) {\n    comment.p = parser.getLinePos(start);\n  }\n\n  return comment;\n}\n\nvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\nvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\nvar stripStandalones = function stripStandalones(items) {\n  var i, current, backOne, backTwo, lastSectionItem;\n\n  for (i = 1; i < items.length; i += 1) {\n    current = items[i];\n    backOne = items[i - 1];\n    backTwo = items[i - 2]; // if we're at the end of a [text][comment][text] sequence...\n\n    if (isString(current) && isComment(backOne) && isString(backTwo)) {\n      // ... and the comment is a standalone (i.e. line breaks either side)...\n      if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n        // ... then we want to remove the whitespace after the first line break\n        items[i - 2] = backTwo.replace(trailingLinebreak, '\\n'); // and the leading line break of the second text token\n\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    } // if the current item is a section, and it is preceded by a linebreak, and\n    // its first item is a linebreak...\n\n\n    if (isSection(current) && isString(backOne)) {\n      if (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n        items[i - 1] = backOne.replace(trailingLinebreak, '\\n');\n        current.f[0] = current.f[0].replace(leadingLinebreak, '');\n      }\n    } // if the last item was a section, and it is followed by a linebreak, and\n    // its last item is a linebreak...\n\n\n    if (isString(current) && isSection(backOne)) {\n      lastSectionItem = lastItem(backOne.f);\n\n      if (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n        backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, '\\n');\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    }\n  }\n\n  return items;\n};\n\nfunction isString(item) {\n  return typeof item === 'string';\n}\n\nfunction isComment(item) {\n  return item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection(item) {\n  return (item.t === SECTION || item.t === INVERTED) && item.f;\n}\n\nvar trimWhitespace = function trimWhitespace(items, leadingPattern, trailingPattern) {\n  var item;\n\n  if (leadingPattern) {\n    item = items[0];\n\n    if (typeof item === 'string') {\n      item = item.replace(leadingPattern, '');\n\n      if (!item) {\n        items.shift();\n      } else {\n        items[0] = item;\n      }\n    }\n  }\n\n  if (trailingPattern) {\n    item = lastItem(items);\n\n    if (typeof item === 'string') {\n      item = item.replace(trailingPattern, '');\n\n      if (!item) {\n        items.pop();\n      } else {\n        items[items.length - 1] = item;\n      }\n    }\n  }\n};\n\nvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\nvar preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\nvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\nvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\nvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\nvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\nfunction cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  if (typeof items === 'string') return;\n  var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment; // First pass - remove standalones and comments etc\n\n  stripStandalones(items);\n  i = items.length;\n\n  while (i--) {\n    item = items[i]; // Remove delimiter changes, unsafe elements etc\n\n    if (item.exclude) {\n      items.splice(i, 1);\n    } // Remove comments, unless we want to keep them\n    else if (stripComments && item.t === COMMENT) {\n        items.splice(i, 1);\n      }\n  } // If necessary, remove leading and trailing whitespace\n\n\n  trimWhitespace(items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null);\n  i = items.length;\n\n  while (i--) {\n    item = items[i]; // Recurse\n\n    if (item.f) {\n      var isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n      preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n      if (!preserveWhitespace && isPreserveWhitespaceElement) {\n        trimWhitespace(item.f, leadingNewLine, trailingNewLine);\n      }\n\n      if (!preserveWhitespaceInsideFragment) {\n        previousItem = items[i - 1];\n        nextItem = items[i + 1]; // if the previous item was a text item with trailing whitespace,\n        // remove leading whitespace inside the fragment\n\n        if (!previousItem || typeof previousItem === 'string' && trailingWhitespace.test(previousItem)) {\n          removeLeadingWhitespaceInsideFragment = true;\n        } // and vice versa\n\n\n        if (!nextItem || typeof nextItem === 'string' && leadingWhitespace$1.test(nextItem)) {\n          removeTrailingWhitespaceInsideFragment = true;\n        }\n      }\n\n      cleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n    } // Split if-else blocks into two (an if, and an unless)\n\n\n    if (item.l) {\n      cleanup(item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n      item.l.forEach(function (s) {\n        return s.l = 1;\n      });\n      item.l.unshift(i + 1, 0);\n      items.splice.apply(items, item.l);\n      delete item.l; // TODO would be nice if there was a way around this\n    } // Clean up conditional attributes\n\n\n    if (item.m) {\n      cleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n      if (item.m.length < 1) delete item.m;\n    }\n  } // final pass - fuse text nodes together\n\n\n  i = items.length;\n\n  while (i--) {\n    if (typeof items[i] === 'string') {\n      if (typeof items[i + 1] === 'string') {\n        items[i] = items[i] + items[i + 1];\n        items.splice(i + 1, 1);\n      }\n\n      if (!preserveWhitespace) {\n        items[i] = items[i].replace(contiguousWhitespace, ' ');\n      }\n\n      if (items[i] === '') {\n        items.splice(i, 1);\n      }\n    }\n  }\n}\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nfunction readClosingTag(parser) {\n  var tag;\n  var start = parser.pos; // are we looking at a closing tag?\n\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  if (tag = parser.matchPattern(closingTagPattern)) {\n    if (parser.inside && tag !== parser.inside) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: CLOSING_TAG,\n      e: tag\n    };\n  } // We have an illegal closing tag, report it\n\n\n  parser.pos -= 2;\n  parser.error('Illegal closing tag');\n}\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\nvar anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;\nvar validTagNameFollower = /^[\\s\\n\\/>]/;\nvar exclude = {\n  exclude: true\n}; // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\nvar disallowedContents = {\n  li: ['li'],\n  dt: ['dt', 'dd'],\n  dd: ['dt', 'dd'],\n  p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(' '),\n  rt: ['rt', 'rp'],\n  rp: ['rt', 'rp'],\n  optgroup: ['optgroup'],\n  option: ['option', 'optgroup'],\n  thead: ['tbody', 'tfoot'],\n  tbody: ['tbody', 'tfoot'],\n  tfoot: ['tbody'],\n  tr: ['tr', 'tbody'],\n  td: ['td', 'th', 'tr'],\n  th: ['td', 'th', 'tr']\n};\n\nfunction readElement$1(parser) {\n  var attribute, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag, anchor;\n  var start = parser.pos;\n\n  if (parser.inside || parser.inAttribute || parser.textOnlyMode) {\n    return null;\n  }\n\n  if (!parser.matchString('<')) {\n    return null;\n  } // if this is a closing tag, abort straight away\n\n\n  if (parser.nextChar() === '/') {\n    return null;\n  }\n\n  var element = {};\n\n  if (parser.includeLinePositions) {\n    element.p = parser.getLinePos(start);\n  } // check for doctype decl\n\n\n  if (parser.matchString('!')) {\n    element.t = DOCTYPE;\n\n    if (!parser.matchPattern(/^doctype/i)) {\n      parser.error('Expected DOCTYPE declaration');\n    }\n\n    element.a = parser.matchPattern(/^(.+?)>/);\n    return element;\n  } // check for anchor\n  else if (anchor = parser.matchString('#')) {\n      parser.allowWhitespace();\n      element.t = ANCHOR;\n      element.n = parser.matchPattern(anchorPattern);\n    } // otherwise, it's an element/component\n    else {\n        element.t = ELEMENT; // element name\n\n        element.e = parser.matchPattern(tagNamePattern);\n\n        if (!element.e) {\n          return null;\n        }\n      } // next character must be whitespace, closing solidus or '>'\n\n\n  if (!validTagNameFollower.test(parser.nextChar())) {\n    parser.error('Illegal tag name');\n  }\n\n  parser.allowWhitespace();\n  parser.inTag = true; // directives and attributes\n\n  while (attribute = readMustache(parser)) {\n    if (attribute !== false) {\n      if (!element.m) element.m = [];\n      element.m.push(attribute);\n    }\n\n    parser.allowWhitespace();\n  }\n\n  parser.inTag = false; // allow whitespace before closing solidus\n\n  parser.allowWhitespace(); // self-closing solidus?\n\n  if (parser.matchString('/')) {\n    selfClosing = true;\n  } // closing angle bracket\n\n\n  if (!parser.matchString('>')) {\n    return null;\n  }\n\n  var lowerCaseName = (element.e || element.n).toLowerCase();\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  if (!selfClosing && (anchor || !voidElementNames.test(element.e))) {\n    if (!anchor) {\n      parser.elementStack.push(lowerCaseName); // Special case - if we open a script element, further tags should\n      // be ignored unless they're a closing script element\n\n      if (lowerCaseName in parser.interpolate) {\n        parser.inside = lowerCaseName;\n      }\n    }\n\n    children = [];\n    partials = Object.create(null);\n\n    do {\n      pos = parser.pos;\n      remaining = parser.remaining();\n\n      if (!remaining) {\n        parser.error(\"Missing end \".concat(parser.elementStack.length > 1 ? 'tags' : 'tag', \" (\").concat(parser.elementStack.reverse().map(function (x) {\n          return \"</\".concat(x, \">\");\n        }).join(''), \")\"));\n      } // if for example we're in an <li> element, and we see another\n      // <li> tag, close the first so they become siblings\n\n\n      if (!anchor && !canContain(lowerCaseName, remaining)) {\n        closed = true;\n      } // closing tag\n      else if (!anchor && (closingTag = readClosingTag(parser))) {\n          closed = true;\n          var closingTagName = closingTag.e.toLowerCase(); // if this *isn't* the closing tag for the current element...\n\n          if (closingTagName !== lowerCaseName) {\n            // rewind parser\n            parser.pos = pos; // if it doesn't close a parent tag, error\n\n            if (!~parser.elementStack.indexOf(closingTagName)) {\n              var _errorMessage = 'Unexpected closing tag'; // add additional help for void elements, since component names\n              // might clash with them\n\n              if (voidElementNames.test(closingTagName)) {\n                _errorMessage += \" (<\".concat(closingTagName, \"> is a void element - it cannot contain children)\");\n              }\n\n              parser.error(_errorMessage);\n            }\n          }\n        } else if (anchor && readAnchorClose(parser, element.n)) {\n          closed = true;\n        } else {\n          (function () {\n            // implicit close by closing section tag. TODO clean this up\n            var tag = {\n              open: parser.standardDelimiters[0],\n              close: parser.standardDelimiters[1]\n            };\n            var implicitCloseCase = [readClosing, readElseIf, readElse];\n\n            if (implicitCloseCase.some(function (r) {\n              return r(parser, tag);\n            })) {\n              closed = true;\n              parser.pos = pos;\n            } else if (child = parser.read(PARTIAL_READERS)) {\n              if (partials[child.n]) {\n                parser.pos = pos;\n                parser.error('Duplicate partial definition');\n              }\n\n              cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n              partials[child.n] = child.f;\n              hasPartials = true;\n            } else {\n              if (child = parser.read(READERS)) {\n                children.push(child);\n              } else {\n                closed = true;\n              }\n            }\n          })();\n        }\n    } while (!closed);\n\n    if (children.length) {\n      element.f = children;\n    }\n\n    if (hasPartials) {\n      element.p = partials;\n    }\n\n    parser.elementStack.pop();\n  }\n\n  parser.inside = null;\n\n  if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n    return exclude;\n  }\n\n  return element;\n}\n\nfunction canContain(name, remaining) {\n  var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  var disallowed = disallowedContents[name];\n\n  if (!match || !disallowed) {\n    return true;\n  }\n\n  return !~disallowed.indexOf(match[1].toLowerCase());\n}\n\nfunction readAnchorClose(parser, name) {\n  var pos = parser.pos;\n\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  parser.matchString('#');\n  parser.allowWhitespace();\n\n  if (!parser.matchString(name)) {\n    parser.pos = pos;\n    return null;\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString('>')) {\n    parser.pos = pos;\n    return null;\n  }\n\n  return true;\n}\n\nfunction readText(parser) {\n  var index, disallowed, barrier;\n  var remaining = parser.remaining();\n\n  if (parser.textOnlyMode) {\n    disallowed = parser.tags.map(function (t) {\n      return t.open;\n    });\n    disallowed = disallowed.concat(parser.tags.map(function (t) {\n      return '\\\\' + t.open;\n    }));\n    index = getLowestIndex(remaining, disallowed);\n  } else {\n    barrier = parser.inside ? '</' + parser.inside : '<';\n\n    if (parser.inside && !parser.interpolate[parser.inside]) {\n      index = remaining.indexOf(barrier);\n    } else {\n      disallowed = parser.tags.map(function (t) {\n        return t.open;\n      });\n      disallowed = disallowed.concat(parser.tags.map(function (t) {\n        return '\\\\' + t.open;\n      })); // http://developers.whatwg.org/syntax.html#syntax-attributes\n\n      if (parser.inAttribute === true) {\n        // we're inside an unquoted attribute value\n        disallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", '`');\n      } else if (parser.inAttribute) {\n        // quoted attribute value\n        disallowed.push(parser.inAttribute);\n      } else {\n        disallowed.push(barrier);\n      }\n\n      index = getLowestIndex(remaining, disallowed);\n    }\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  if (index === -1) {\n    index = remaining.length;\n  }\n\n  parser.pos += index;\n\n  if (parser.inside && parser.inside !== 'textarea' || parser.textOnlyMode) {\n    return remaining.substr(0, index);\n  } else {\n    return decodeCharacterReferences(remaining.substr(0, index));\n  }\n}\n\nvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\nfunction readPartialDefinitionSection(parser) {\n  var child, closed;\n  var start = parser.pos;\n  var delimiters = parser.standardDelimiters;\n\n  if (!parser.matchString(delimiters[0])) {\n    return null;\n  }\n\n  if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n    parser.pos = start;\n    return null;\n  }\n\n  var name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/);\n\n  if (!name) {\n    parser.error('expected legal partial name');\n  }\n\n  parser.allowWhitespace();\n\n  if (!parser.matchString(delimiters[1])) {\n    parser.error(\"Expected closing delimiter '\".concat(delimiters[1], \"'\"));\n  }\n\n  var content = [];\n\n  var _delimiters = _slicedToArray(delimiters, 2),\n      open = _delimiters[0],\n      close = _delimiters[1];\n\n  do {\n    if (child = readClosing(parser, {\n      open: open,\n      close: close\n    })) {\n      if (child.r !== 'partial') {\n        parser.error(\"Expected \".concat(open, \"/partial\").concat(close));\n      }\n\n      closed = true;\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        parser.error(\"Expected \".concat(open, \"/partial\").concat(close));\n      }\n\n      content.push(child);\n    }\n  } while (!closed);\n\n  return {\n    t: INLINE_PARTIAL,\n    n: name,\n    f: content\n  };\n}\n\nfunction readTemplate(parser) {\n  var fragment = [];\n  var partials = Object.create(null);\n  var hasPartials = false;\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  while (parser.pos < parser.str.length) {\n    var pos = parser.pos;\n    var item = void 0,\n        partial = void 0;\n\n    if (partial = parser.read(PARTIAL_READERS)) {\n      if (partials[partial.n]) {\n        parser.pos = pos;\n        parser.error('Duplicated partial definition');\n      }\n\n      cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n      partials[partial.n] = partial.f;\n      hasPartials = true;\n    } else if (item = parser.read(READERS)) {\n      fragment.push(item);\n    } else {\n      parser.error('Unexpected template content');\n    }\n  }\n\n  var result = {\n    v: TEMPLATE_VERSION,\n    t: fragment\n  };\n\n  if (hasPartials) {\n    result.p = partials;\n  }\n\n  return result;\n}\n\nfunction insertExpressions(obj, expr) {\n  Object.keys(obj).forEach(function (key) {\n    if (isExpression(key, obj)) return addTo(obj, expr);\n    var ref = obj[key];\n    if (hasChildren(ref)) insertExpressions(ref, expr);\n  });\n}\n\nfunction isExpression(key, obj) {\n  return key === 's' && Array.isArray(obj.r);\n}\n\nfunction addTo(obj, expr) {\n  var s = obj.s,\n      r = obj.r;\n  if (!expr[s]) expr[s] = fromExpression(s, r.length);\n}\n\nfunction hasChildren(ref) {\n  return Array.isArray(ref) || isObject(ref);\n}\n\nvar shared = {}; // See https://github.com/ractivejs/template-spec for information\n// about the Ractive template specification\n\nvar STANDARD_READERS = [readPartial, readUnescaped, readSection, readInterpolator, readComment];\nvar TRIPLE_READERS = [readTriple];\nvar STATIC_READERS = [readUnescaped, readSection, readInterpolator]; // TODO does it make sense to have a static section?\n\nvar READERS = [readMustache, readHtmlComment, readElement$1, readText];\nvar PARTIAL_READERS = [readPartialDefinitionSection];\nvar defaultInterpolate = ['script', 'style', 'template'];\nvar StandardParser = Parser.extend({\n  init: function init(str, options) {\n    var _this20 = this;\n\n    var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;\n    var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;\n    var staticTripleDelimiters = options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;\n    this.standardDelimiters = options.delimiters || shared.defaults.delimiters;\n    this.tags = [{\n      isStatic: false,\n      isTriple: false,\n      open: this.standardDelimiters[0],\n      close: this.standardDelimiters[1],\n      readers: STANDARD_READERS\n    }, {\n      isStatic: false,\n      isTriple: true,\n      open: tripleDelimiters[0],\n      close: tripleDelimiters[1],\n      readers: TRIPLE_READERS\n    }, {\n      isStatic: true,\n      isTriple: false,\n      open: staticDelimiters[0],\n      close: staticDelimiters[1],\n      readers: STATIC_READERS\n    }, {\n      isStatic: true,\n      isTriple: true,\n      open: staticTripleDelimiters[0],\n      close: staticTripleDelimiters[1],\n      readers: TRIPLE_READERS\n    }];\n    this.contextLines = options.contextLines || shared.defaults.contextLines;\n    this.sortMustacheTags();\n    this.sectionDepth = 0;\n    this.elementStack = [];\n    this.interpolate = Object.create(options.interpolate || shared.defaults.interpolate || {});\n    this.interpolate.textarea = true;\n    defaultInterpolate.forEach(function (t) {\n      return _this20.interpolate[t] = !options.interpolate || options.interpolate[t] !== false;\n    });\n\n    if (options.sanitize === true) {\n      options.sanitize = {\n        // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n        elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split(' '),\n        eventAttributes: true\n      };\n    }\n\n    this.stripComments = options.stripComments !== false;\n    this.preserveWhitespace = options.preserveWhitespace;\n    this.sanitizeElements = options.sanitize && options.sanitize.elements;\n    this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n    this.includeLinePositions = options.includeLinePositions;\n    this.textOnlyMode = options.textOnlyMode;\n    this.csp = options.csp;\n    if (options.attributes) this.inTag = true;\n    this.transforms = options.transforms || options.parserTransforms;\n\n    if (this.transforms) {\n      this.transforms = this.transforms.concat(shared.defaults.parserTransforms);\n    } else {\n      this.transforms = shared.defaults.parserTransforms;\n    }\n  },\n  postProcess: function postProcess(result) {\n    // special case - empty string\n    if (!result.length) {\n      return {\n        t: [],\n        v: TEMPLATE_VERSION\n      };\n    }\n\n    if (this.sectionDepth > 0) {\n      this.error('A section was left open');\n    }\n\n    cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n    var transforms = this.transforms;\n\n    if (transforms.length) {\n      var tlen = transforms.length;\n\n      var walk = function walk(fragment) {\n        var len = fragment.length;\n\n        for (var _i22 = 0; _i22 < len; _i22++) {\n          var node = fragment[_i22];\n\n          if (node.t === ELEMENT) {\n            for (var _j2 = 0; _j2 < tlen; _j2++) {\n              var res = transforms[_j2].call(shared.Ractive, node);\n\n              if (!res) {\n                continue;\n              } else if (res.remove) {\n                fragment.splice(_i22--, 1);\n                len--;\n                break;\n              } else if (res.replace) {\n                if (Array.isArray(res.replace)) {\n                  fragment.splice.apply(fragment, [_i22--, 1].concat(_toConsumableArray(res.replace)));\n                  len += res.replace.length - 1;\n                } else {\n                  fragment[_i22--] = node = res.replace;\n                }\n\n                break;\n              }\n            } // watch for partials\n\n\n            if (node.p && !Array.isArray(node.p)) {\n              for (var k in node.p) {\n                walk(node.p[k]);\n              }\n            }\n          }\n\n          if (node.f) walk(node.f);\n        }\n      }; // process the root fragment\n\n\n      walk(result[0].t); // watch for root partials\n\n      if (result[0].p && !Array.isArray(result[0].p)) {\n        for (var k in result[0].p) {\n          walk(result[0].p[k]);\n        }\n      }\n    }\n\n    if (this.csp !== false) {\n      var expr = {};\n      insertExpressions(result[0].t, expr);\n      if (Object.keys(expr).length) result[0].e = expr;\n    }\n\n    return result[0];\n  },\n  converters: [readTemplate],\n  sortMustacheTags: function sortMustacheTags() {\n    // Sort in order of descending opening delimiter length (longer first),\n    // to protect against opening delimiters being substrings of each other\n    this.tags.sort(function (a, b) {\n      return b.open.length - a.open.length;\n    });\n  }\n});\n\nfunction _parse(template, options) {\n  return new StandardParser(template, options || {}).result;\n}\n\nvar parseOptions = ['delimiters', 'tripleDelimiters', 'staticDelimiters', 'staticTripleDelimiters', 'csp', 'interpolate', 'preserveWhitespace', 'sanitize', 'stripComments', 'contextLines', 'parserTransforms', 'allowExpressions', 'attributes'];\nvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\nvar COMPUTATION_INSTRUCTIONS = \"Either include a version of Ractive that can parse or convert your computation strings to functions.\";\n\nfunction throwNoParse(method, error, instructions) {\n  if (!method) {\n    fatal(\"Missing Ractive.parse - cannot parse \".concat(error, \". \").concat(instructions));\n  }\n}\n\nfunction createFunction(body, length) {\n  throwNoParse(fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS);\n  return fromExpression(body, length);\n}\n\nfunction createFunctionFromString(str, bindTo) {\n  throwNoParse(fromComputationString, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS);\n  return fromComputationString(str, bindTo);\n}\n\nvar parser = {\n  fromId: function fromId(id, options) {\n    if (!doc) {\n      if (options && options.noThrow) {\n        return;\n      }\n\n      throw new Error(\"Cannot retrieve template #\".concat(id, \" as Ractive is not running in a browser.\"));\n    }\n\n    if (id) id = id.replace(/^#/, '');\n    var template;\n\n    if (!(template = doc.getElementById(id))) {\n      if (options && options.noThrow) {\n        return;\n      }\n\n      throw new Error(\"Could not find template element with id #\".concat(id));\n    }\n\n    if (template.tagName.toUpperCase() !== 'SCRIPT') {\n      if (options && options.noThrow) {\n        return;\n      }\n\n      throw new Error(\"Template element with id #\".concat(id, \", must be a <script> element\"));\n    }\n\n    return 'textContent' in template ? template.textContent : template.innerHTML;\n  },\n  isParsed: function isParsed(template) {\n    return !(typeof template === 'string');\n  },\n  getParseOptions: function getParseOptions(ractive) {\n    // Could be Ractive or a Component\n    if (ractive.defaults) {\n      ractive = ractive.defaults;\n    }\n\n    return parseOptions.reduce(function (val, key) {\n      val[key] = ractive[key];\n      return val;\n    }, {});\n  },\n  parse: function parse(template, options) {\n    throwNoParse(_parse, 'template', TEMPLATE_INSTRUCTIONS);\n\n    var parsed = _parse(template, options);\n\n    addFunctions(parsed);\n    return parsed;\n  },\n  parseFor: function parseFor(template, ractive) {\n    return this.parse(template, this.getParseOptions(ractive));\n  }\n};\nvar functions = Object.create(null);\n\nfunction getFunction(str, i) {\n  if (functions[str]) return functions[str];\n  return functions[str] = createFunction(str, i);\n}\n\nfunction addFunctions(template) {\n  if (!template) return;\n  var exp = template.e;\n  if (!exp) return;\n  Object.keys(exp).forEach(function (str) {\n    if (functions[str]) return;\n    functions[str] = exp[str];\n  });\n}\n\nvar templateConfigurator = {\n  name: 'template',\n  extend: function extend(Parent, proto, options) {\n    // only assign if exists\n    if ('template' in options) {\n      var template = options.template;\n\n      if (typeof template === 'function') {\n        proto.template = template;\n      } else {\n        proto.template = parseTemplate(template, proto);\n      }\n    }\n  },\n  init: function init(Parent, ractive, options) {\n    // TODO because of prototypal inheritance, we might just be able to use\n    // ractive.template, and not bother passing through the Parent object.\n    // At present that breaks the test mocks' expectations\n    var template = 'template' in options ? options.template : Parent.prototype.template;\n    template = template || {\n      v: TEMPLATE_VERSION,\n      t: []\n    };\n\n    if (typeof template === 'function') {\n      var fn = template;\n      template = getDynamicTemplate(ractive, fn);\n      ractive._config.template = {\n        fn: fn,\n        result: template\n      };\n    }\n\n    template = parseTemplate(template, ractive); // TODO the naming of this is confusing - ractive.template refers to [...],\n    // but Component.prototype.template refers to {v:1,t:[],p:[]}...\n    // it's unnecessary, because the developer never needs to access\n    // ractive.template\n\n    ractive.template = template.t;\n\n    if (template.p) {\n      extendPartials(ractive.partials, template.p);\n    }\n  },\n  reset: function reset(ractive) {\n    var result = resetValue(ractive);\n\n    if (result) {\n      var parsed = parseTemplate(result, ractive);\n      ractive.template = parsed.t;\n      extendPartials(ractive.partials, parsed.p, true);\n      return true;\n    }\n  }\n};\n\nfunction resetValue(ractive) {\n  var initial = ractive._config.template; // If this isn't a dynamic template, there's nothing to do\n\n  if (!initial || !initial.fn) {\n    return;\n  }\n\n  var result = getDynamicTemplate(ractive, initial.fn); // TODO deep equality check to prevent unnecessary re-rendering\n  // in the case of already-parsed templates\n\n  if (result !== initial.result) {\n    initial.result = result;\n    return result;\n  }\n}\n\nfunction getDynamicTemplate(ractive, fn) {\n  return fn.call(ractive, {\n    fromId: parser.fromId,\n    isParsed: parser.isParsed,\n    parse: function parse(template) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parser.getParseOptions(ractive);\n      return parser.parse(template, options);\n    }\n  });\n}\n\nfunction parseTemplate(template, ractive) {\n  if (typeof template === 'string') {\n    // parse will validate and add expression functions\n    template = parseAsString(template, ractive);\n  } else {\n    // need to validate and add exp for already parsed template\n    validate$1(template);\n    addFunctions(template);\n  }\n\n  return template;\n}\n\nfunction parseAsString(template, ractive) {\n  // ID of an element containing the template?\n  if (template[0] === '#') {\n    template = parser.fromId(template);\n  }\n\n  return parser.parseFor(template, ractive);\n}\n\nfunction validate$1(template) {\n  // Check that the template even exists\n  if (template == undefined) {\n    throw new Error(\"The template cannot be \".concat(template, \".\"));\n  } // Check the parsed template has a version at all\n  else if (typeof template.v !== 'number') {\n      throw new Error('The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.');\n    } // Check we're using the correct version\n    else if (template.v !== TEMPLATE_VERSION) {\n        throw new Error(\"Mismatched template version (expected \".concat(TEMPLATE_VERSION, \", got \").concat(template.v, \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\"));\n      }\n}\n\nfunction extendPartials(existingPartials, newPartials, overwrite) {\n  if (!newPartials) return; // TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  // case, but not initially...\n\n  for (var key in newPartials) {\n    if (overwrite || !existingPartials.hasOwnProperty(key)) {\n      existingPartials[key] = newPartials[key];\n    }\n  }\n}\n\nvar registryNames = ['adaptors', 'components', 'computed', 'decorators', 'easing', 'events', 'interpolators', 'partials', 'transitions'];\nvar registriesOnDefaults = ['computed'];\n\nvar Registry =\n/*#__PURE__*/\nfunction () {\n  function Registry(name, useDefaults) {\n    _classCallCheck(this, Registry);\n\n    this.name = name;\n    this.useDefaults = useDefaults;\n  }\n\n  _createClass(Registry, [{\n    key: \"extend\",\n    value: function extend(Parent, proto, options) {\n      var parent = this.useDefaults ? Parent.defaults : Parent;\n      var target = this.useDefaults ? proto : proto.constructor;\n      this.configure(parent, target, options);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {// noop\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(Parent, target, options) {\n      var name = this.name;\n      var option = options[name];\n      var registry = Object.create(Parent[name]);\n\n      for (var key in option) {\n        registry[key] = option[key];\n      }\n\n      target[name] = registry;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(ractive) {\n      var registry = ractive[this.name];\n      var changed = false;\n      Object.keys(registry).forEach(function (key) {\n        var item = registry[key];\n\n        if (item._fn) {\n          if (item._fn.isOwner) {\n            registry[key] = item._fn;\n          } else {\n            delete registry[key];\n          }\n\n          changed = true;\n        }\n      });\n      return changed;\n    }\n  }]);\n\n  return Registry;\n}();\n\nvar registries = registryNames.map(function (name) {\n  var putInDefaults = registriesOnDefaults.indexOf(name) > -1;\n  return new Registry(name, putInDefaults);\n});\n\nfunction wrap(parent, name, method) {\n  if (!/_super/.test(method)) return method;\n\n  function wrapper() {\n    var superMethod = getSuperMethod(wrapper._parent, name);\n    var hasSuper = '_super' in this;\n    var oldSuper = this._super;\n    this._super = superMethod;\n    var result = method.apply(this, arguments);\n\n    if (hasSuper) {\n      this._super = oldSuper;\n    } else {\n      delete this._super;\n    }\n\n    return result;\n  }\n\n  wrapper._parent = parent;\n  wrapper._method = method;\n  return wrapper;\n}\n\nfunction getSuperMethod(parent, name) {\n  if (name in parent) {\n    var _value6 = parent[name];\n    return typeof _value6 === 'function' ? _value6 : function () {\n      return _value6;\n    };\n  }\n\n  return noop;\n}\n\nfunction getMessage(deprecated, correct, isError) {\n  return \"options.\".concat(deprecated, \" has been deprecated in favour of options.\").concat(correct, \".\") + (isError ? \" You cannot specify both options, please use options.\".concat(correct, \".\") : '');\n}\n\nfunction deprecateOption(options, deprecatedOption, correct) {\n  if (deprecatedOption in options) {\n    if (!(correct in options)) {\n      warnIfDebug(getMessage(deprecatedOption, correct));\n      options[correct] = options[deprecatedOption];\n    } else {\n      throw new Error(getMessage(deprecatedOption, correct, true));\n    }\n  }\n}\n\nfunction deprecate(options) {\n  deprecateOption(options, 'beforeInit', 'onconstruct');\n  deprecateOption(options, 'init', 'onrender');\n  deprecateOption(options, 'complete', 'oncomplete');\n  deprecateOption(options, 'eventDefinitions', 'events'); // Using extend with Component instead of options,\n  // like Human.extend( Spider ) means adaptors as a registry\n  // gets copied to options. So we have to check if actually an array\n\n  if (Array.isArray(options.adaptors)) {\n    deprecateOption(options, 'adaptors', 'adapt');\n  }\n}\n\nvar custom = {\n  adapt: adaptConfigurator,\n  css: cssConfigurator,\n  data: dataConfigurator,\n  template: templateConfigurator\n};\nvar defaultKeys = Object.keys(defaults);\nvar isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  return !custom[key];\n})); // blacklisted keys that we don't double extend\n\nvar isBlacklisted = makeObj(defaultKeys.concat(registries.map(function (r) {\n  return r.name;\n}), ['on', 'observe', 'attributes', 'cssData']));\nvar order = [].concat(defaultKeys.filter(function (key) {\n  return !registries[key] && !custom[key];\n}), registries, //custom.data,\ncustom.template, custom.css);\nvar config = {\n  extend: function extend(Parent, proto$$1, options, Child) {\n    return configure('extend', Parent, proto$$1, options, Child);\n  },\n  init: function init(Parent, ractive, options) {\n    return configure('init', Parent, ractive, options);\n  },\n  reset: function reset(ractive) {\n    return order.filter(function (c) {\n      return c.reset && c.reset(ractive);\n    }).map(function (c) {\n      return c.name;\n    });\n  }\n};\n\nfunction configure(method, Parent, target, options, Child) {\n  deprecate(options);\n\n  for (var key in options) {\n    if (isStandardKey.hasOwnProperty(key)) {\n      var _value7 = options[key]; // warn the developer if they passed a function and ignore its value\n      // NOTE: we allow some functions on \"el\" because we duck type element lists\n      // and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n      // function object as the result of querySelector methods\n\n      if (key !== 'el' && typeof _value7 === 'function') {\n        warnIfDebug(\"\".concat(key, \" is a Ractive option that does not expect a function and will be ignored\"), method === 'init' ? target : null);\n      } else {\n        target[key] = _value7;\n      }\n    }\n  } // disallow combination of `append` and `enhance`\n\n\n  if (options.append && options.enhance) {\n    throw new Error('Cannot use append and enhance at the same time');\n  }\n\n  registries.forEach(function (registry) {\n    registry[method](Parent, target, options, Child);\n  });\n  adaptConfigurator[method](Parent, target, options, Child);\n  templateConfigurator[method](Parent, target, options, Child);\n  cssConfigurator[method](Parent, target, options, Child);\n  extendOtherMethods(Parent.prototype, target, options);\n}\n\nvar _super = /\\b_super\\b/;\n\nfunction extendOtherMethods(parent, target, options) {\n  for (var key in options) {\n    if (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n      var member = options[key]; // if this is a method that overwrites a method, wrap it:\n\n      if (typeof member === 'function') {\n        if (key in proto && !_super.test(member.toString())) {\n          warnIfDebug(\"Overriding Ractive prototype function '\".concat(key, \"' without calling the '\").concat(_super, \"' method can be very dangerous.\"));\n        }\n\n        member = wrap(parent, key, member);\n      }\n\n      target[key] = member;\n    }\n  }\n}\n\nfunction makeObj(array) {\n  var obj = {};\n  array.forEach(function (x) {\n    return obj[x] = true;\n  });\n  return obj;\n}\n\nvar Item =\n/*#__PURE__*/\nfunction () {\n  function Item(options) {\n    _classCallCheck(this, Item);\n\n    this.parentFragment = options.parentFragment;\n    this.ractive = options.parentFragment.ractive;\n    this.template = options.template;\n    this.index = options.index;\n    this.type = options.template.t;\n    this.dirty = false;\n  }\n\n  _createClass(Item, [{\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.dirty = true;\n        this.parentFragment.bubble();\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      if (this.fragment) this.fragment.destroyed();\n    }\n  }, {\n    key: \"find\",\n    value: function find() {\n      return null;\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent() {\n      return null;\n    }\n  }, {\n    key: \"findNextNode\",\n    value: function findNextNode() {\n      return this.parentFragment.findNextNode(this);\n    }\n  }, {\n    key: \"shuffled\",\n    value: function shuffled() {\n      if (this.fragment) this.fragment.shuffled();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toString();\n    }\n  }]);\n\n  return Item;\n}();\n\nItem.prototype.findAll = noop;\nItem.prototype.findAllComponents = noop;\n\nvar ContainerItem =\n/*#__PURE__*/\nfunction (_Item) {\n  _inherits(ContainerItem, _Item);\n\n  function ContainerItem(options) {\n    _classCallCheck(this, ContainerItem);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ContainerItem).call(this, options));\n  }\n\n  _createClass(ContainerItem, [{\n    key: \"detach\",\n    value: function detach() {\n      return this.fragment ? this.fragment.detach() : createDocumentFragment();\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      if (this.fragment) {\n        return this.fragment.find(selector);\n      }\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      if (this.fragment) {\n        this.fragment.findAll(selector, options);\n      }\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent(name) {\n      if (this.fragment) {\n        return this.fragment.findComponent(name);\n      }\n    }\n  }, {\n    key: \"findAllComponents\",\n    value: function findAllComponents(name, options) {\n      if (this.fragment) {\n        this.fragment.findAllComponents(name, options);\n      }\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode(skipParent) {\n      return this.fragment && this.fragment.firstNode(skipParent);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(escape) {\n      return this.fragment ? this.fragment.toString(escape) : '';\n    }\n  }]);\n\n  return ContainerItem;\n}(Item);\n\nvar ComputationChild =\n/*#__PURE__*/\nfunction (_Model3) {\n  _inherits(ComputationChild, _Model3);\n\n  function ComputationChild(parent, key) {\n    var _this21;\n\n    _classCallCheck(this, ComputationChild);\n\n    _this21 = _possibleConstructorReturn(this, _getPrototypeOf(ComputationChild).call(this, parent, key));\n    _this21.isReadonly = !_this21.root.ractive.syncComputedChildren;\n    _this21.dirty = true;\n    return _this21;\n  }\n\n  _createClass(ComputationChild, [{\n    key: \"applyValue\",\n    value: function applyValue(value) {\n      _get(_getPrototypeOf(ComputationChild.prototype), \"applyValue\", this).call(this, value);\n\n      if (!this.isReadonly) {\n        var source = this.parent; // computed models don't have a shuffle method\n\n        while (source && source.shuffle) {\n          source = source.parent;\n        }\n\n        if (source) {\n          source.dependencies.forEach(_mark);\n        }\n      }\n\n      if (this.setRoot) {\n        this.setRoot.set(this.setRoot.value);\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture) {\n      if (shouldCapture) capture(this);\n\n      if (this.dirty) {\n        this.dirty = false;\n        var parentValue = this.parent.get();\n        this.value = parentValue ? parentValue[this.key] : undefined;\n      }\n\n      return this.value;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.dirty = true;\n      if (this.boundValue) this.boundValue = null;\n      this.links.forEach(_marked);\n      this.deps.forEach(_handleChange);\n      this.children.forEach(_handleChange);\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key) {\n      if (key === undefined || key === '') return this;\n\n      if (!this.childByKey.hasOwnProperty(key)) {\n        var _child7 = new ComputationChild(this, key);\n\n        this.children.push(_child7);\n        this.childByKey[key] = _child7;\n      }\n\n      return this.childByKey[key];\n    }\n  }, {\n    key: \"setRoot\",\n    get: function get() {\n      return this.parent.setRoot;\n    }\n  }]);\n\n  return ComputationChild;\n}(Model);\n/* global console */\n\n/* eslint no-console:\"off\" */\n\n\nvar Computation =\n/*#__PURE__*/\nfunction (_Model4) {\n  _inherits(Computation, _Model4);\n\n  function Computation(viewmodel, signature, key) {\n    var _this22;\n\n    _classCallCheck(this, Computation);\n\n    _this22 = _possibleConstructorReturn(this, _getPrototypeOf(Computation).call(this, null, null));\n    _this22.root = _this22.parent = viewmodel;\n    _this22.signature = signature;\n    _this22.key = key; // not actually used, but helps with debugging\n\n    _this22.isExpression = key && key[0] === '@';\n    _this22.isReadonly = !_this22.signature.setter;\n    _this22.context = viewmodel.computationContext;\n    _this22.dependencies = [];\n    _this22.children = [];\n    _this22.childByKey = {};\n    _this22.deps = [];\n    _this22.dirty = true; // TODO: is there a less hackish way to do this?\n\n    _this22.shuffle = undefined;\n    return _this22;\n  }\n\n  _createClass(Computation, [{\n    key: \"get\",\n    value: function get(shouldCapture) {\n      if (shouldCapture) capture(this);\n\n      if (this.dirty) {\n        this.dirty = false;\n        var _old = this.value;\n        this.value = this.getValue();\n        if (!isEqual(_old, this.value)) this.notifyUpstream();\n        if (this.wrapper) this.newWrapperValue = this.value;\n        this.adapt();\n      } // if capturing, this value needs to be unwrapped because it's for external use\n\n\n      return maybeBind(this, shouldCapture && this.wrapper ? this.wrapperValue : this.value);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      startCapturing();\n      var result;\n\n      try {\n        result = this.signature.getter.call(this.context);\n      } catch (err) {\n        warnIfDebug(\"Failed to compute \".concat(this.getKeypath(), \": \").concat(err.message || err)); // TODO this is all well and good in Chrome, but...\n        // ...also, should encapsulate this stuff better, and only\n        // show it if Ractive.DEBUG\n\n        if (hasConsole) {\n          if (console.groupCollapsed) console.groupCollapsed('%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;');\n          var sig = this.signature;\n          console.error(\"\".concat(err.name, \": \").concat(err.message, \"\\n\\n\").concat(sig.getterString).concat(sig.getterUseStack ? '\\n\\n' + err.stack : ''));\n          if (console.groupCollapsed) console.groupEnd();\n        }\n      }\n\n      var dependencies = stopCapturing();\n      this.setDependencies(dependencies);\n      return result;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark() {\n      this.handleChange();\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous) {\n      // computations will grab all of their deps again automagically\n      if (next !== previous) this.handleChange();\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      if (this.isReadonly) {\n        throw new Error(\"Cannot set read-only computed value '\".concat(this.key, \"'\"));\n      }\n\n      this.signature.setter(value);\n      this.mark();\n    }\n  }, {\n    key: \"setDependencies\",\n    value: function setDependencies(dependencies) {\n      // unregister any soft dependencies we no longer have\n      var i = this.dependencies.length;\n\n      while (i--) {\n        var model = this.dependencies[i];\n        if (!~dependencies.indexOf(model)) model.unregister(this);\n      } // and add any new ones\n\n\n      i = dependencies.length;\n\n      while (i--) {\n        var _model = dependencies[i];\n        if (!~this.dependencies.indexOf(_model)) _model.register(this);\n      }\n\n      this.dependencies = dependencies;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      var i = this.dependencies.length;\n\n      while (i--) {\n        if (this.dependencies[i]) this.dependencies[i].unregister(this);\n      }\n\n      if (this.root.computations[this.key] === this) delete this.root.computations[this.key];\n\n      _get(_getPrototypeOf(Computation.prototype), \"teardown\", this).call(this);\n    }\n  }, {\n    key: \"setRoot\",\n    get: function get() {\n      if (this.signature.setter) return this;\n    }\n  }]);\n\n  return Computation;\n}(Model);\n\nvar prototype$1 = Computation.prototype;\nvar child = ComputationChild.prototype;\nprototype$1.handleChange = child.handleChange;\nprototype$1.joinKey = child.joinKey;\n\nvar ExpressionProxy =\n/*#__PURE__*/\nfunction (_Model5) {\n  _inherits(ExpressionProxy, _Model5);\n\n  function ExpressionProxy(fragment, template) {\n    var _this23;\n\n    _classCallCheck(this, ExpressionProxy);\n\n    _this23 = _possibleConstructorReturn(this, _getPrototypeOf(ExpressionProxy).call(this, fragment.ractive.viewmodel, null));\n    _this23.fragment = fragment;\n    _this23.template = template;\n    _this23.isReadonly = true;\n    _this23.dirty = true;\n    _this23.fn = getFunction(template.s, template.r.length);\n    _this23.models = _this23.template.r.map(function (ref) {\n      return resolveReference(_this23.fragment, ref);\n    });\n    _this23.dependencies = [];\n    _this23.shuffle = undefined;\n\n    _this23.bubble();\n\n    return _this23;\n  }\n\n  _createClass(ExpressionProxy, [{\n    key: \"bubble\",\n    value: function bubble() {\n      var actuallyChanged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // refresh the keypath\n      this.keypath = undefined;\n\n      if (actuallyChanged) {\n        this.handleChange();\n      }\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      var _this24 = this;\n\n      if (!this.template) return '@undefined';\n\n      if (!this.keypath) {\n        this.keypath = '@' + this.template.s.replace(/_(\\d+)/g, function (match, i) {\n          if (i >= _this24.models.length) return match;\n          var model = _this24.models[i];\n          return model ? model.getKeypath() : '@undefined';\n        });\n      }\n\n      return this.keypath;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      var _this25 = this;\n\n      startCapturing();\n      var result;\n\n      try {\n        var params = this.models.map(function (m) {\n          return m ? m.get(true) : undefined;\n        });\n        result = this.fn.apply(this.fragment.ractive, params);\n      } catch (err) {\n        warnIfDebug(\"Failed to compute \".concat(this.getKeypath(), \": \").concat(err.message || err));\n      }\n\n      var dependencies = stopCapturing(); // remove missing deps\n\n      this.dependencies.filter(function (d) {\n        return !~dependencies.indexOf(d);\n      }).forEach(function (d) {\n        d.unregister(_this25);\n        removeFromArray(_this25.dependencies, d);\n      }); // register new deps\n\n      dependencies.filter(function (d) {\n        return !~_this25.dependencies.indexOf(d);\n      }).forEach(function (d) {\n        d.register(_this25);\n\n        _this25.dependencies.push(d);\n      });\n      return result;\n    }\n  }, {\n    key: \"notifyUpstream\",\n    value: function notifyUpstream() {}\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous, safe) {\n      var idx = this.models.indexOf(previous);\n\n      if (~idx) {\n        next = rebindMatch(this.template.r[idx], next, previous);\n\n        if (next !== previous) {\n          previous.unregister(this);\n          this.models.splice(idx, 1, next);\n          if (next) next.addShuffleRegister(this, 'mark');\n        }\n      }\n\n      this.bubble(!safe);\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      return this.get();\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      var _this26 = this;\n\n      this.unbind();\n      this.fragment = undefined;\n      if (this.dependencies) this.dependencies.forEach(function (d) {\n        return d.unregister(_this26);\n      });\n\n      _get(_getPrototypeOf(ExpressionProxy.prototype), \"teardown\", this).call(this);\n    }\n  }, {\n    key: \"unreference\",\n    value: function unreference() {\n      _get(_getPrototypeOf(ExpressionProxy.prototype), \"unreference\", this).call(this);\n\n      if (!this.deps.length && !this.refs) this.teardown();\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(dep) {\n      _get(_getPrototypeOf(ExpressionProxy.prototype), \"unregister\", this).call(this, dep);\n\n      if (!this.deps.length && !this.refs) this.teardown();\n    }\n  }]);\n\n  return ExpressionProxy;\n}(Model);\n\nvar prototype = ExpressionProxy.prototype;\nvar computation = Computation.prototype;\nprototype.get = computation.get;\nprototype.handleChange = computation.handleChange;\nprototype.joinKey = computation.joinKey;\nprototype.mark = computation.mark;\nprototype.unbind = noop;\n\nvar ReferenceExpressionChild =\n/*#__PURE__*/\nfunction (_Model6) {\n  _inherits(ReferenceExpressionChild, _Model6);\n\n  function ReferenceExpressionChild(parent, key) {\n    var _this27;\n\n    _classCallCheck(this, ReferenceExpressionChild);\n\n    _this27 = _possibleConstructorReturn(this, _getPrototypeOf(ReferenceExpressionChild).call(this, parent, key));\n    _this27.dirty = true;\n    return _this27;\n  }\n\n  _createClass(ReferenceExpressionChild, [{\n    key: \"applyValue\",\n    value: function applyValue(value) {\n      if (isEqual(value, this.value)) return;\n      var parent = this.parent;\n      var keys = [this.key];\n\n      while (parent) {\n        if (parent.base) {\n          var target = parent.model.joinAll(keys);\n          target.applyValue(value);\n          break;\n        }\n\n        keys.unshift(parent.key);\n        parent = parent.parent;\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture, opts) {\n      this.retrieve();\n      return _get(_getPrototypeOf(ReferenceExpressionChild.prototype), \"get\", this).call(this, shouldCapture, opts);\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key) {\n      if (key === undefined || key === '') return this;\n\n      if (!this.childByKey.hasOwnProperty(key)) {\n        var _child8 = new ReferenceExpressionChild(this, key);\n\n        this.children.push(_child8);\n        this.childByKey[key] = _child8;\n      }\n\n      return this.childByKey[key];\n    }\n  }, {\n    key: \"mark\",\n    value: function mark() {\n      this.dirty = true;\n\n      _get(_getPrototypeOf(ReferenceExpressionChild.prototype), \"mark\", this).call(this);\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      if (this.dirty) {\n        this.dirty = false;\n        var parent = this.parent.get();\n        this.value = parent && parent[this.key];\n      }\n\n      return this.value;\n    }\n  }]);\n\n  return ReferenceExpressionChild;\n}(Model);\n\nvar missing = {\n  get: function get() {}\n};\n\nvar ReferenceExpressionProxy =\n/*#__PURE__*/\nfunction (_Model7) {\n  _inherits(ReferenceExpressionProxy, _Model7);\n\n  function ReferenceExpressionProxy(fragment, template) {\n    var _this28;\n\n    _classCallCheck(this, ReferenceExpressionProxy);\n\n    _this28 = _possibleConstructorReturn(this, _getPrototypeOf(ReferenceExpressionProxy).call(this, null, null));\n    _this28.dirty = true;\n    _this28.root = fragment.ractive.viewmodel;\n    _this28.template = template;\n    _this28.base = resolve(fragment, template);\n    var intermediary = _this28.intermediary = {\n      handleChange: function handleChange() {\n        return _this28.handleChange();\n      },\n      rebind: function rebind(next, previous) {\n        if (previous === _this28.base) {\n          next = rebindMatch(template, next, previous);\n\n          if (next !== _this28.base) {\n            _this28.base.unregister(intermediary);\n\n            _this28.base = next;\n          }\n        } else {\n          var idx = _this28.members.indexOf(previous);\n\n          if (~idx) {\n            // only direct references will rebind... expressions handle themselves\n            next = rebindMatch(template.m[idx].n, next, previous);\n\n            if (next !== _this28.members[idx]) {\n              _this28.members.splice(idx, 1, next || missing);\n            }\n          }\n        }\n\n        if (next !== previous) previous.unregister(intermediary);\n        if (next) next.addShuffleTask(function () {\n          return next.register(intermediary);\n        });\n\n        _this28.bubble();\n      }\n    };\n    _this28.members = template.m.map(function (template) {\n      if (typeof template === 'string') {\n        return {\n          get: function get() {\n            return template;\n          }\n        };\n      }\n\n      var model;\n\n      if (template.t === REFERENCE) {\n        model = resolveReference(fragment, template.n);\n        model.register(intermediary);\n        return model;\n      }\n\n      model = new ExpressionProxy(fragment, template);\n      model.register(intermediary);\n      return model;\n    });\n\n    _this28.base.register(intermediary);\n\n    _this28.bubble();\n\n    return _this28;\n  }\n\n  _createClass(ReferenceExpressionProxy, [{\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.base) return;\n      if (!this.dirty) this.handleChange();\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture) {\n      if (this.dirty) {\n        this.bubble();\n        var keys = this.members.map(function (m) {\n          return escapeKey(String(m.get()));\n        });\n        var model = this.base.joinAll(keys);\n\n        if (model !== this.model) {\n          if (this.model) {\n            this.model.unregister(this);\n            this.model.unregisterTwowayBinding(this);\n          }\n\n          this.model = model;\n          this.parent = model.parent;\n          this.model.register(this);\n          this.model.registerTwowayBinding(this);\n          if (this.keypathModel) this.keypathModel.handleChange();\n        }\n\n        this.value = this.model.get(shouldCapture);\n        this.dirty = false;\n        this.mark();\n        return this.value;\n      } else {\n        return this.model ? this.model.get(shouldCapture) : undefined;\n      }\n    } // indirect two-way bindings\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      this.value = this.model ? this.model.get() : undefined;\n      var i = this.bindings.length;\n\n      while (i--) {\n        var _value8 = this.bindings[i].getValue();\n\n        if (_value8 !== this.value) return _value8;\n      } // check one-way bindings\n\n\n      var oneway = findBoundValue(this.deps);\n      if (oneway) return oneway.value;\n      return this.value;\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return this.model ? this.model.getKeypath() : '@undefined';\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.dirty = true;\n      this.mark();\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key) {\n      if (key === undefined || key === '') return this;\n\n      if (!this.childByKey.hasOwnProperty(key)) {\n        var _child9 = new ReferenceExpressionChild(this, key);\n\n        this.children.push(_child9);\n        this.childByKey[key] = _child9;\n      }\n\n      return this.childByKey[key];\n    }\n  }, {\n    key: \"mark\",\n    value: function mark() {\n      if (this.dirty) {\n        this.deps.forEach(_handleChange);\n      }\n\n      this.links.forEach(_marked);\n      this.children.forEach(_mark);\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind() {\n      this.handleChange();\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      return this.value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      this.model.set(value);\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      var _this29 = this;\n\n      if (this.model) {\n        this.model.unregister(this);\n        this.model.unregisterTwowayBinding(this);\n      }\n\n      if (this.members) {\n        this.members.forEach(function (m) {\n          return m && m.unregister && m.unregister(_this29);\n        });\n      }\n    }\n  }, {\n    key: \"unreference\",\n    value: function unreference() {\n      _get(_getPrototypeOf(ReferenceExpressionProxy.prototype), \"unreference\", this).call(this);\n\n      if (!this.deps.length && !this.refs) this.teardown();\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(dep) {\n      _get(_getPrototypeOf(ReferenceExpressionProxy.prototype), \"unregister\", this).call(this, dep);\n\n      if (!this.deps.length && !this.refs) this.teardown();\n    }\n  }]);\n\n  return ReferenceExpressionProxy;\n}(Model);\n\nfunction resolve(fragment, template) {\n  if (template.r) {\n    return resolveReference(fragment, template.r);\n  } else if (template.x) {\n    return new ExpressionProxy(fragment, template.x);\n  } else if (template.rx) {\n    return new ReferenceExpressionProxy(fragment, template.rx);\n  }\n}\n\nfunction resolveAliases(aliases, fragment) {\n  var resolved = {};\n\n  for (var _i23 = 0; _i23 < aliases.length; _i23++) {\n    resolved[aliases[_i23].n] = resolve(fragment, aliases[_i23].x);\n  }\n\n  for (var k in resolved) {\n    resolved[k].reference();\n  }\n\n  return resolved;\n}\n\nvar Alias =\n/*#__PURE__*/\nfunction (_ContainerItem) {\n  _inherits(Alias, _ContainerItem);\n\n  function Alias(options) {\n    var _this30;\n\n    _classCallCheck(this, Alias);\n\n    _this30 = _possibleConstructorReturn(this, _getPrototypeOf(Alias).call(this, options));\n    _this30.fragment = null;\n    return _this30;\n  }\n\n  _createClass(Alias, [{\n    key: \"bind\",\n    value: function bind() {\n      this.fragment = new Fragment({\n        owner: this,\n        template: this.template.f\n      });\n      this.fragment.aliases = resolveAliases(this.template.z, this.parentFragment);\n      this.fragment.bind();\n    }\n  }, {\n    key: \"render\",\n    value: function render(target) {\n      this.rendered = true;\n      if (this.fragment) this.fragment.render(target);\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      for (var k in this.fragment.aliases) {\n        this.fragment.aliases[k].unreference();\n      }\n\n      this.fragment.aliases = {};\n      if (this.fragment) this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if (this.rendered && this.fragment) this.fragment.unrender(shouldDestroy);\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        this.dirty = false;\n        this.fragment.update();\n      }\n    }\n  }]);\n\n  return Alias;\n}(ContainerItem);\n\nvar hyphenateCamel = function hyphenateCamel(camelCaseStr) {\n  return camelCaseStr.replace(/([A-Z])/g, function (match, $1) {\n    return '-' + $1.toLowerCase();\n  });\n};\n\nvar space = /\\s+/;\n\nfunction readStyle(css) {\n  if (typeof css !== 'string') return {};\n  return cleanCss(css, function (css, reconstruct) {\n    return css.split(';').filter(function (rule) {\n      return !!rule.trim();\n    }).map(reconstruct).reduce(function (rules, rule) {\n      var i = rule.indexOf(':');\n      var name = rule.substr(0, i).trim();\n      rules[name] = rule.substr(i + 1).trim();\n      return rules;\n    }, {});\n  });\n}\n\nfunction readClass(str) {\n  var list = str.split(space); // remove any empty entries\n\n  var i = list.length;\n\n  while (i--) {\n    if (!list[i]) list.splice(i, 1);\n  }\n\n  return list;\n}\n\nvar textTypes = [undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit'];\n\nfunction getUpdateDelegate(attribute) {\n  var element = attribute.element,\n      name = attribute.name;\n\n  if (name === 'value') {\n    if (attribute.interpolator) attribute.interpolator.bound = true; // special case - selects\n\n    if (element.name === 'select' && name === 'value') {\n      return element.getAttribute('multiple') ? updateMultipleSelectValue : updateSelectValue;\n    }\n\n    if (element.name === 'textarea') return updateStringValue; // special case - contenteditable\n\n    if (element.getAttribute('contenteditable') != null) return updateContentEditableValue; // special case - <input>\n\n    if (element.name === 'input') {\n      var type = element.getAttribute('type'); // type='file' value='{{fileList}}'>\n\n      if (type === 'file') return noop; // read-only\n      // type='radio' name='{{twoway}}'\n\n      if (type === 'radio' && element.binding && element.binding.attribute.name === 'name') return updateRadioValue;\n      if (~textTypes.indexOf(type)) return updateStringValue;\n    }\n\n    return updateValue;\n  }\n\n  var node = element.node; // special case - <input type='radio' name='{{twoway}}' value='foo'>\n\n  if (attribute.isTwoway && name === 'name') {\n    if (node.type === 'radio') return updateRadioName;\n    if (node.type === 'checkbox') return updateCheckboxName;\n  }\n\n  if (name === 'style') return updateStyleAttribute;\n  if (name.indexOf('style-') === 0) return updateInlineStyle; // special case - class names. IE fucks things up, again\n\n  if (name === 'class' && (!node.namespaceURI || node.namespaceURI === html)) return updateClassName;\n  if (name.indexOf('class-') === 0) return updateInlineClass;\n\n  if (attribute.isBoolean) {\n    var _type = element.getAttribute('type');\n\n    if (attribute.interpolator && name === 'checked' && (_type === 'checkbox' || _type === 'radio')) attribute.interpolator.bound = true;\n    return updateBoolean;\n  }\n\n  if (attribute.namespace && attribute.namespace !== attribute.node.namespaceURI) return updateNamespacedAttribute;\n  return updateAttribute;\n}\n\nfunction updateMultipleSelectValue(reset) {\n  var value = this.getValue();\n  if (!Array.isArray(value)) value = [value];\n  var options = this.node.options;\n  var i = options.length;\n\n  if (reset) {\n    while (i--) {\n      options[i].selected = false;\n    }\n  } else {\n    while (i--) {\n      var option = options[i];\n      var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n      option.selected = arrayContains(value, optionValue);\n    }\n  }\n}\n\nfunction updateSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    // TODO is locked still a thing?\n    this.node._ractive.value = value;\n    var options = this.node.options;\n    var _i24 = options.length;\n    var wasSelected = false;\n\n    if (reset) {\n      while (_i24--) {\n        options[_i24].selected = false;\n      }\n    } else {\n      while (_i24--) {\n        var option = options[_i24];\n        var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n        if (option.disabled && option.selected) wasSelected = true;\n\n        if (optionValue == value) {\n          // double equals as we may be comparing numbers with strings\n          option.selected = true;\n          return;\n        }\n      }\n    }\n\n    if (!wasSelected) this.node.selectedIndex = -1;\n  }\n}\n\nfunction updateContentEditableValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    if (reset) this.node.innerHTML = '';else this.node.innerHTML = value === undefined ? '' : value;\n  }\n}\n\nfunction updateRadioValue(reset) {\n  var node = this.node;\n  var wasChecked = node.checked;\n  var value = this.getValue();\n  if (reset) return node.checked = false; //node.value = this.element.getAttribute( 'value' );\n\n  node.value = this.node._ractive.value = value;\n  node.checked = this.element.compare(value, this.element.getAttribute('name')); // This is a special case - if the input was checked, and the value\n  // changed so that it's no longer checked, the twoway binding is\n  // most likely out of date. To fix it we have to jump through some\n  // hoops... this is a little kludgy but it works\n\n  if (wasChecked && !node.checked && this.element.binding && this.element.binding.rendered) {\n    this.element.binding.group.model.set(this.element.binding.group.getValue());\n  }\n}\n\nfunction updateValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node.removeAttribute('value');\n      this.node.value = this.node._ractive.value = null;\n    } else {\n      var _value9 = this.getValue();\n\n      this.node.value = this.node._ractive.value = _value9;\n      this.node.setAttribute('value', safeToStringValue(_value9));\n    }\n  }\n}\n\nfunction updateStringValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node._ractive.value = '';\n      this.node.removeAttribute('value');\n    } else {\n      var _value10 = this.getValue();\n\n      this.node._ractive.value = _value10;\n      this.node.value = safeToStringValue(_value10);\n      this.node.setAttribute('value', safeToStringValue(_value10));\n    }\n  }\n}\n\nfunction updateRadioName(reset) {\n  if (reset) this.node.checked = false;else this.node.checked = this.element.compare(this.getValue(), this.element.binding.getValue());\n}\n\nfunction updateCheckboxName(reset) {\n  var element = this.element,\n      node = this.node;\n  var binding = element.binding;\n  var value = this.getValue();\n  var valueAttribute = element.getAttribute('value');\n\n  if (reset) {// TODO: WAT?\n  }\n\n  if (!Array.isArray(value)) {\n    binding.isChecked = node.checked = element.compare(value, valueAttribute);\n  } else {\n    var _i25 = value.length;\n\n    while (_i25--) {\n      if (element.compare(valueAttribute, value[_i25])) {\n        binding.isChecked = node.checked = true;\n        return;\n      }\n    }\n\n    binding.isChecked = node.checked = false;\n  }\n}\n\nfunction updateStyleAttribute(reset) {\n  var props = reset ? {} : readStyle(this.getValue() || '');\n  var style = this.node.style;\n  var keys = Object.keys(props);\n  var prev = this.previous || [];\n  var i = 0;\n\n  while (i < keys.length) {\n    if (keys[i] in style) {\n      var safe = props[keys[i]].replace('!important', '');\n      style.setProperty(keys[i], safe, safe.length !== props[keys[i]].length ? 'important' : '');\n    }\n\n    i++;\n  } // remove now-missing attrs\n\n\n  i = prev.length;\n\n  while (i--) {\n    if (!~keys.indexOf(prev[i]) && prev[i] in style) style.setProperty(prev[i], '', '');\n  }\n\n  this.previous = keys;\n}\n\nfunction updateInlineStyle(reset) {\n  if (!this.style) {\n    this.style = hyphenateCamel(this.name.substr(6));\n  }\n\n  if (reset && this.node.style.getPropertyValue(this.style) !== this.last) return;\n  var value = reset ? '' : safeToStringValue(this.getValue());\n  var safe = value.replace('!important', '');\n  this.node.style.setProperty(this.style, safe, safe.length !== value.length ? 'important' : '');\n  this.last = safe;\n}\n\nfunction updateClassName(reset) {\n  var value = reset ? [] : readClass(safeToStringValue(this.getValue())); // watch out for werdo svg elements\n\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n  var attr = readClass(cls);\n  var prev = this.previous || attr.slice(0);\n  var className = value.concat(attr.filter(function (c) {\n    return !~prev.indexOf(c);\n  })).join(' ');\n\n  if (className !== cls) {\n    if (typeof this.node.className !== 'string') {\n      this.node.className.baseVal = className;\n    } else {\n      this.node.className = className;\n    }\n  }\n\n  this.previous = value;\n}\n\nfunction updateInlineClass(reset) {\n  var name = this.name.substr(6); // watch out for werdo svg elements\n\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n  var attr = readClass(cls);\n  var value = reset ? false : this.getValue();\n  if (!this.inlineClass) this.inlineClass = name;\n  if (value && !~attr.indexOf(name)) attr.push(name);else if (!value && ~attr.indexOf(name)) attr.splice(attr.indexOf(name), 1);\n\n  if (typeof this.node.className !== 'string') {\n    this.node.className.baseVal = attr.join(' ');\n  } else {\n    this.node.className = attr.join(' ');\n  }\n}\n\nfunction updateBoolean(reset) {\n  // with two-way binding, only update if the change wasn't initiated by the user\n  // otherwise the cursor will often be sent to the wrong place\n  if (!this.locked) {\n    if (reset) {\n      if (this.useProperty) this.node[this.propertyName] = false;\n      this.node.removeAttribute(this.propertyName);\n    } else {\n      if (this.useProperty) {\n        this.node[this.propertyName] = this.getValue();\n      } else {\n        var val = this.getValue();\n\n        if (val) {\n          this.node.setAttribute(this.propertyName, typeof val === 'string' ? val : '');\n        } else {\n          this.node.removeAttribute(this.propertyName);\n        }\n      }\n    }\n  }\n}\n\nfunction updateAttribute(reset) {\n  if (reset) {\n    if (this.node.getAttribute(this.name) === this.value) {\n      this.node.removeAttribute(this.name);\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttribute(this.name, this.value);\n  }\n}\n\nfunction updateNamespacedAttribute(reset) {\n  if (reset) {\n    if (this.value === this.node.getAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1))) {\n      this.node.removeAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1));\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1), this.value);\n  }\n}\n\nvar propertyNames = {\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  bgcolor: 'bgColor',\n  \"class\": 'className',\n  codebase: 'codeBase',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  datetime: 'dateTime',\n  dirname: 'dirName',\n  \"for\": 'htmlFor',\n  'http-equiv': 'httpEquiv',\n  ismap: 'isMap',\n  maxlength: 'maxLength',\n  novalidate: 'noValidate',\n  pubdate: 'pubDate',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  tabindex: 'tabIndex',\n  usemap: 'useMap'\n};\nvar div$1 = doc ? createElement('div') : null;\nvar attributes = false;\n\nfunction inAttributes() {\n  return attributes;\n}\n\nfunction doInAttributes(fn) {\n  attributes = true;\n  fn();\n  attributes = false;\n}\n\nvar ConditionalAttribute =\n/*#__PURE__*/\nfunction (_Item2) {\n  _inherits(ConditionalAttribute, _Item2);\n\n  function ConditionalAttribute(options) {\n    var _this31;\n\n    _classCallCheck(this, ConditionalAttribute);\n\n    _this31 = _possibleConstructorReturn(this, _getPrototypeOf(ConditionalAttribute).call(this, options));\n    _this31.attributes = [];\n    _this31.owner = options.owner;\n    _this31.fragment = new Fragment({\n      ractive: _this31.ractive,\n      owner: _assertThisInitialized(_this31),\n      template: _this31.template\n    }); // this fragment can't participate in node-y things\n\n    _this31.fragment.findNextNode = noop;\n    _this31.dirty = false;\n    return _this31;\n  }\n\n  _createClass(ConditionalAttribute, [{\n    key: \"bind\",\n    value: function bind() {\n      this.fragment.bind();\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.dirty = true;\n        this.owner.bubble();\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      this.unrender();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.node = this.owner.node;\n\n      if (this.node) {\n        this.isSvg = this.node.namespaceURI === svg$1;\n      }\n\n      attributes = true;\n      if (!this.rendered) this.fragment.render();\n      this.rendered = true;\n      this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n\n      this.update();\n      attributes = false;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.fragment.toString();\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.rendered = false;\n      this.fragment.unrender();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this32 = this;\n\n      var str;\n      var attrs;\n\n      if (this.dirty) {\n        this.dirty = false;\n        var current = attributes;\n        attributes = true;\n        this.fragment.update();\n\n        if (this.rendered && this.node) {\n          str = this.fragment.toString();\n          attrs = parseAttributes(str, this.isSvg); // any attributes that previously existed but no longer do\n          // must be removed\n\n          this.attributes.filter(function (a) {\n            return notIn(attrs, a);\n          }).forEach(function (a) {\n            _this32.node.removeAttribute(a.name);\n          });\n          attrs.forEach(function (a) {\n            _this32.node.setAttribute(a.name, a.value);\n          });\n          this.attributes = attrs;\n        }\n\n        attributes = current || false;\n      }\n    }\n  }]);\n\n  return ConditionalAttribute;\n}(Item);\n\nvar onlyWhitespace = /^\\s*$/;\n\nfunction parseAttributes(str, isSvg) {\n  if (onlyWhitespace.test(str)) return [];\n  var tagName = isSvg ? 'svg' : 'div';\n  return str ? (div$1.innerHTML = \"<\".concat(tagName, \" \").concat(str, \"></\").concat(tagName, \">\")) && toArray(div$1.childNodes[0].attributes) : [];\n}\n\nfunction notIn(haystack, needle) {\n  var i = haystack.length;\n\n  while (i--) {\n    if (haystack[i].name === needle.name) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lookupNamespace(node, prefix) {\n  var qualified = \"xmlns:\".concat(prefix);\n\n  while (node) {\n    if (node.hasAttribute && node.hasAttribute(qualified)) return node.getAttribute(qualified);\n    node = node.parentNode;\n  }\n\n  return namespaces[prefix];\n}\n\nvar attribute = false;\n\nfunction inAttribute() {\n  return attribute;\n}\n\nvar Attribute =\n/*#__PURE__*/\nfunction (_Item3) {\n  _inherits(Attribute, _Item3);\n\n  function Attribute(options) {\n    var _this33;\n\n    _classCallCheck(this, Attribute);\n\n    _this33 = _possibleConstructorReturn(this, _getPrototypeOf(Attribute).call(this, options));\n    _this33.name = options.template.n;\n    _this33.namespace = null;\n    _this33.owner = options.owner || options.parentFragment.owner || options.element || findElement(options.parentFragment);\n    _this33.element = options.element || (_this33.owner.attributeByName ? _this33.owner : findElement(options.parentFragment));\n    _this33.parentFragment = options.parentFragment; // shared\n\n    _this33.ractive = _this33.parentFragment.ractive;\n    _this33.rendered = false;\n    _this33.updateDelegate = null;\n    _this33.fragment = null;\n    _this33.element.attributeByName[_this33.name] = _assertThisInitialized(_this33);\n\n    if (!Array.isArray(options.template.f)) {\n      _this33.value = options.template.f;\n\n      if (_this33.value === 0) {\n        _this33.value = '';\n      } else if (_this33.value === undefined) {\n        _this33.value = true;\n      }\n    } else {\n      _this33.fragment = new Fragment({\n        owner: _assertThisInitialized(_this33),\n        template: options.template.f\n      });\n    }\n\n    _this33.interpolator = _this33.fragment && _this33.fragment.items.length === 1 && _this33.fragment.items[0].type === INTERPOLATOR && _this33.fragment.items[0];\n    if (_this33.interpolator) _this33.interpolator.owner = _assertThisInitialized(_this33);\n    return _this33;\n  }\n\n  _createClass(Attribute, [{\n    key: \"bind\",\n    value: function bind() {\n      if (this.fragment) {\n        this.fragment.bind();\n      }\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.parentFragment.bubble();\n        this.element.bubble();\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode() {}\n  }, {\n    key: \"getString\",\n    value: function getString() {\n      attribute = true;\n      var value = this.fragment ? this.fragment.toString() : this.value != null ? '' + this.value : '';\n      attribute = false;\n      return value;\n    } // TODO could getValue ever be called for a static attribute,\n    // or can we assume that this.fragment exists?\n\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      attribute = true;\n      var value = this.fragment ? this.fragment.valueOf() : booleanAttributes.test(this.name) ? true : this.value;\n      attribute = false;\n      return value;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var node = this.element.node;\n      this.node = node; // should we use direct property access, or setAttribute?\n\n      if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n        this.propertyName = propertyNames[this.name] || this.name;\n\n        if (node[this.propertyName] !== undefined) {\n          this.useProperty = true;\n        } // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n        // node.selected = true rather than node.setAttribute( 'selected', '' )\n\n\n        if (booleanAttributes.test(this.name) || this.isTwoway) {\n          this.isBoolean = true;\n        }\n\n        if (this.propertyName === 'value') {\n          node._ractive.value = this.value;\n        }\n      }\n\n      if (node.namespaceURI) {\n        var index = this.name.indexOf(':');\n\n        if (index !== -1) {\n          this.namespace = lookupNamespace(node, this.name.slice(0, index));\n        } else {\n          this.namespace = node.namespaceURI;\n        }\n      }\n\n      this.rendered = true;\n      this.updateDelegate = getUpdateDelegate(this);\n      this.updateDelegate();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (inAttributes()) return '';\n      attribute = true;\n      var value = this.getValue(); // Special case - select and textarea values (should not be stringified)\n\n      if (this.name === 'value' && (this.element.getAttribute('contenteditable') !== undefined || this.element.name === 'select' || this.element.name === 'textarea')) {\n        return;\n      } // Special case – bound radio `name` attributes\n\n\n      if (this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute('type') === 'radio') {\n        return \"name=\\\"{{\".concat(this.interpolator.model.getKeypath(), \"}}\\\"\");\n      } // Special case - style and class attributes and directives\n\n\n      if (this.owner === this.element && (this.name === 'style' || this.name === 'class' || this.style || this.inlineClass)) {\n        return;\n      }\n\n      if (!this.rendered && this.owner === this.element && (!this.name.indexOf('style-') || !this.name.indexOf('class-'))) {\n        if (!this.name.indexOf('style-')) {\n          this.style = hyphenateCamel(this.name.substr(6));\n        } else {\n          this.inlineClass = this.name.substr(6);\n        }\n\n        return;\n      }\n\n      if (booleanAttributes.test(this.name)) return value ? typeof value === 'string' ? \"\".concat(this.name, \"=\\\"\").concat(safeAttributeString(value), \"\\\"\") : this.name : '';\n      if (value == null) return '';\n      var str = safeAttributeString(this.getString());\n      attribute = false;\n      return str ? \"\".concat(this.name, \"=\\\"\").concat(str, \"\\\"\") : this.name;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (this.fragment) this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.updateDelegate(true);\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        this.dirty = false;\n        if (this.fragment) this.fragment.update();\n        if (this.rendered) this.updateDelegate();\n\n        if (this.isTwoway && !this.locked) {\n          this.interpolator.twowayBinding.lastVal(true, this.interpolator.model.get());\n        }\n      }\n    }\n  }]);\n\n  return Attribute;\n}(Item);\n\nvar BindingFlag =\n/*#__PURE__*/\nfunction (_Item4) {\n  _inherits(BindingFlag, _Item4);\n\n  function BindingFlag(options) {\n    var _this34;\n\n    _classCallCheck(this, BindingFlag);\n\n    _this34 = _possibleConstructorReturn(this, _getPrototypeOf(BindingFlag).call(this, options));\n    _this34.owner = options.owner || options.parentFragment.owner || findElement(options.parentFragment);\n    _this34.element = _this34.owner.attributeByName ? _this34.owner : findElement(options.parentFragment);\n    _this34.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n\n    if (_this34.element.type === ELEMENT) {\n      if (Array.isArray(options.template.f)) {\n        _this34.fragment = new Fragment({\n          owner: _assertThisInitialized(_this34),\n          template: options.template.f\n        });\n      }\n\n      _this34.interpolator = _this34.fragment && _this34.fragment.items.length === 1 && _this34.fragment.items[0].type === INTERPOLATOR && _this34.fragment.items[0];\n    }\n\n    return _this34;\n  }\n\n  _createClass(BindingFlag, [{\n    key: \"bind\",\n    value: function bind() {\n      if (this.fragment) this.fragment.bind();\n      set$1(this, this.getValue(), true);\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.element.bubble();\n        this.dirty = true;\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (this.fragment) return this.fragment.valueOf();else if ('value' in this) return this.value;else if ('f' in this.template) return this.template.f;else return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      set$1(this, this.getValue(), true);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '';\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (this.fragment) this.fragment.unbind();\n      delete this.element[this.flag];\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      if (this.element.rendered) this.element.recreateTwowayBinding();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        if (this.fragment) this.fragment.update();\n        set$1(this, this.getValue(), true);\n      }\n    }\n  }]);\n\n  return BindingFlag;\n}(Item);\n\nfunction set$1(flag, value, update) {\n  if (value === 0) {\n    flag.value = true;\n  } else if (value === 'true') {\n    flag.value = true;\n  } else if (value === 'false' || value === '0') {\n    flag.value = false;\n  } else {\n    flag.value = value;\n  }\n\n  var current = flag.element[flag.flag];\n  flag.element[flag.flag] = flag.value;\n\n  if (update && !flag.element.attributes.binding && current !== flag.value) {\n    flag.element.recreateTwowayBinding();\n  }\n\n  return flag.value;\n}\n\nvar teardownHook = new Hook('teardown');\nvar destructHook = new Hook('destruct'); // Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nfunction Ractive$teardown() {\n  var _this35 = this;\n\n  if (this.torndown) {\n    warnIfDebug('ractive.teardown() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  this.shouldDestroy = true;\n  return teardown$1(this, function () {\n    return _this35.fragment.rendered ? _this35.unrender() : Promise.resolve();\n  });\n}\n\nfunction teardown$1(instance, getPromise) {\n  instance.torndown = true;\n  instance.viewmodel.teardown();\n  instance.fragment.unbind();\n\n  instance._observers.slice().forEach(cancel);\n\n  if (instance.el && instance.el.__ractive_instances__) {\n    removeFromArray(instance.el.__ractive_instances__, instance);\n  }\n\n  var promise = getPromise();\n  teardownHook.fire(instance);\n  promise.then(function () {\n    return destructHook.fire(instance);\n  });\n  return promise;\n}\n\nvar RactiveModel =\n/*#__PURE__*/\nfunction (_SharedModel2) {\n  _inherits(RactiveModel, _SharedModel2);\n\n  function RactiveModel(ractive) {\n    var _this36;\n\n    _classCallCheck(this, RactiveModel);\n\n    _this36 = _possibleConstructorReturn(this, _getPrototypeOf(RactiveModel).call(this, ractive, '@this'));\n    _this36.ractive = ractive;\n    return _this36;\n  }\n\n  _createClass(RactiveModel, [{\n    key: \"joinKey\",\n    value: function joinKey(key) {\n      var model = _get(_getPrototypeOf(RactiveModel.prototype), \"joinKey\", this).call(this, key);\n\n      if ((key === 'root' || key === 'parent') && !model.isLink) return initLink(model, key);else if (key === 'data') return this.ractive.viewmodel;else if (key === 'cssData') return this.ractive.constructor._cssModel;\n      return model;\n    }\n  }]);\n\n  return RactiveModel;\n}(SharedModel);\n\nfunction initLink(model, key) {\n  model.applyValue = function (value) {\n    this.parent.value[key] = value;\n\n    if (value && value.viewmodel) {\n      this.link(value.viewmodel.getRactiveModel(), key);\n\n      this._link.markedAll();\n    } else {\n      this.link(Object.create(Missing), key);\n\n      this._link.markedAll();\n    }\n  };\n\n  model.applyValue(model.parent.ractive[key], key);\n\n  model._link.set = function (v) {\n    return model.applyValue(v);\n  };\n\n  model._link.applyValue = function (v) {\n    return model.applyValue(v);\n  };\n\n  return model._link;\n}\n\nvar hasProp$1 = Object.prototype.hasOwnProperty;\n\nvar RootModel =\n/*#__PURE__*/\nfunction (_Model8) {\n  _inherits(RootModel, _Model8);\n\n  function RootModel(options) {\n    var _this37;\n\n    _classCallCheck(this, RootModel);\n\n    _this37 = _possibleConstructorReturn(this, _getPrototypeOf(RootModel).call(this, null, null));\n    _this37.isRoot = true;\n    _this37.root = _assertThisInitialized(_this37);\n    _this37.ractive = options.ractive; // TODO sever this link\n\n    _this37.value = options.data;\n    _this37.adaptors = options.adapt;\n\n    _this37.adapt();\n\n    _this37.computationContext = options.ractive;\n    _this37.computations = {};\n    return _this37;\n  }\n\n  _createClass(RootModel, [{\n    key: \"attached\",\n    value: function attached(fragment) {\n      attachImplicits(this, fragment);\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(key, signature) {\n      var computation = new Computation(this, signature, key);\n      this.computations[escapeKey(key)] = computation;\n      return computation;\n    }\n  }, {\n    key: \"createLink\",\n    value: function createLink(keypath, target, targetPath, options) {\n      var keys = splitKeypath(keypath);\n      var model = this;\n\n      while (keys.length) {\n        var key = keys.shift();\n        model = model.childByKey[key] || model.joinKey(key);\n      }\n\n      return model.link(target, targetPath, options);\n    }\n  }, {\n    key: \"detached\",\n    value: function detached() {\n      detachImplicits(this);\n    }\n  }, {\n    key: \"get\",\n    value: function get(shouldCapture, options) {\n      if (shouldCapture) capture(this);\n\n      if (!options || options.virtual !== false) {\n        var result = this.getVirtual();\n        var keys = Object.keys(this.computations);\n        var _i26 = keys.length;\n\n        while (_i26--) {\n          result[keys[_i26]] = this.computations[keys[_i26]].get();\n        }\n\n        return result;\n      } else {\n        return this.value;\n      }\n    }\n  }, {\n    key: \"getKeypath\",\n    value: function getKeypath() {\n      return '';\n    }\n  }, {\n    key: \"getRactiveModel\",\n    value: function getRactiveModel() {\n      return this.ractiveModel || (this.ractiveModel = new RactiveModel(this.ractive));\n    }\n  }, {\n    key: \"getValueChildren\",\n    value: function getValueChildren() {\n      var children = _get(_getPrototypeOf(RootModel.prototype), \"getValueChildren\", this).call(this, this.value);\n\n      this.children.forEach(function (child) {\n        if (child._link) {\n          var idx = children.indexOf(child);\n          if (~idx) children.splice(idx, 1, child._link);else children.push(child._link);\n        }\n      });\n\n      for (var k in this.computations) {\n        children.push(this.computations[k]);\n      }\n\n      return children;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var value = this.value;\n      var unescapedKey = unescapeKey(key);\n      if (unescapedKey === '@this' || unescapedKey === '@global' || unescapedKey === '@shared' || unescapedKey === '@style') return true;\n      if (unescapedKey[0] === '~' && unescapedKey[1] === '/') unescapedKey = unescapedKey.slice(2);\n      if (key === '' || hasProp$1.call(value, unescapedKey)) return true; // mappings/links and computations\n\n      if (key in this.computations || this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link) return true; // We climb up the constructor chain to find if one of them contains the unescapedKey\n\n      var constructor = value.constructor;\n\n      while (constructor !== Function && constructor !== Array && constructor !== Object) {\n        if (hasProp$1.call(constructor.prototype, unescapedKey)) return true;\n        constructor = constructor.constructor;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"joinKey\",\n    value: function joinKey(key, opts) {\n      if (key[0] === '@') {\n        if (key === '@this' || key === '@') return this.getRactiveModel();\n        if (key === '@global') return GlobalModel;\n        if (key === '@shared') return SharedModel$1;\n        if (key === '@style') return this.getRactiveModel().joinKey('cssData');\n        return;\n      }\n\n      if (key[0] === '~' && key[1] === '/') key = key.slice(2);\n      return this.computations.hasOwnProperty(key) ? this.computations[key] : _get(_getPrototypeOf(RootModel.prototype), \"joinKey\", this).call(this, key, opts);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      // TODO wrapping root node is a baaaad idea. We should prevent this\n      var wrapper = this.wrapper;\n\n      if (wrapper) {\n        var shouldTeardown = !wrapper.reset || wrapper.reset(value) === false;\n\n        if (shouldTeardown) {\n          wrapper.teardown();\n          this.wrapper = null;\n          this.value = value;\n          this.adapt();\n        }\n      } else {\n        this.value = value;\n        this.adapt();\n      }\n\n      this.deps.forEach(_handleChange);\n      this.children.forEach(_mark);\n    }\n  }, {\n    key: \"retrieve\",\n    value: function retrieve() {\n      return this.wrapper ? this.wrapper.get() : this.value;\n    }\n  }, {\n    key: \"teardown\",\n    value: function teardown() {\n      _get(_getPrototypeOf(RootModel.prototype), \"teardown\", this).call(this);\n\n      for (var k in this.computations) {\n        this.computations[k].teardown();\n      }\n    }\n  }]);\n\n  return RootModel;\n}(Model);\n\nRootModel.prototype.update = noop;\n\nfunction attachImplicits(model, fragment) {\n  if (model._link && model._link.implicit && model._link.isDetached()) {\n    model.attach(fragment);\n  } // look for virtual children to relink and cascade\n\n\n  for (var k in model.childByKey) {\n    if (k in model.value) {\n      attachImplicits(model.childByKey[k], fragment);\n    } else if (!model.childByKey[k]._link || model.childByKey[k]._link.isDetached()) {\n      var mdl = resolveReference(fragment, k);\n\n      if (mdl) {\n        model.childByKey[k].link(mdl, k, {\n          implicit: true\n        });\n      }\n    }\n  }\n}\n\nfunction detachImplicits(model) {\n  if (model._link && model._link.implicit) {\n    model.unlink();\n  }\n\n  for (var k in model.childByKey) {\n    detachImplicits(model.childByKey[k]);\n  }\n}\n\nfunction getComputationSignature(ractive, key, signature) {\n  var getter;\n  var setter; // useful for debugging\n\n  var getterString;\n  var getterUseStack;\n  var setterString;\n\n  if (typeof signature === 'function') {\n    getter = bind$1(signature, ractive);\n    getterString = signature.toString();\n    getterUseStack = true;\n  }\n\n  if (typeof signature === 'string') {\n    getter = createFunctionFromString(signature, ractive);\n    getterString = signature;\n  }\n\n  if (_typeof(signature) === 'object') {\n    if (typeof signature.get === 'string') {\n      getter = createFunctionFromString(signature.get, ractive);\n      getterString = signature.get;\n    } else if (typeof signature.get === 'function') {\n      getter = bind$1(signature.get, ractive);\n      getterString = signature.get.toString();\n      getterUseStack = true;\n    } else {\n      fatal('`%s` computation must have a `get()` method', key);\n    }\n\n    if (typeof signature.set === 'function') {\n      setter = bind$1(signature.set, ractive);\n      setterString = signature.set.toString();\n    }\n  }\n\n  return {\n    getter: getter,\n    setter: setter,\n    getterString: getterString,\n    setterString: setterString,\n    getterUseStack: getterUseStack\n  };\n}\n\nfunction fillGaps(target) {\n  for (var _i27 = 0; _i27 < (arguments.length <= 1 ? 0 : arguments.length - 1); _i27++) {\n    var source = _i27 + 1 < 1 || arguments.length <= _i27 + 1 ? undefined : arguments[_i27 + 1];\n\n    for (var key in source) {\n      // Source can be a prototype-less object.\n      if (key in target || !Object.prototype.hasOwnProperty.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction toPairs() {\n  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var pairs = [];\n\n  for (var key in obj) {\n    // Source can be a prototype-less object.\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;\n    pairs.push([key, obj[key]]);\n  }\n\n  return pairs;\n}\n\nfunction subscribe(instance, options, type) {\n  var subs = (instance.constructor[\"_\".concat(type)] || []).concat(toPairs(options[type] || []));\n  var single = type === 'on' ? 'once' : \"\".concat(type, \"Once\");\n  subs.forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        target = _ref2[0],\n        config = _ref2[1];\n\n    if (typeof config === 'function') {\n      instance[type](target, config);\n    } else if (_typeof(config) === 'object' && typeof config.handler === 'function') {\n      instance[config.once ? single : type](target, config.handler, Object.create(config));\n    }\n  });\n}\n\nvar constructHook = new Hook('construct');\nvar registryNames$1 = ['adaptors', 'components', 'decorators', 'easing', 'events', 'interpolators', 'partials', 'transitions'];\nvar uid = 0;\n\nfunction construct(ractive, options) {\n  if (Ractive.DEBUG) _welcome();\n  initialiseProperties(ractive);\n  handleAttributes(ractive); // set up event subscribers\n\n  subscribe(ractive, options, 'on'); // if there's not a delegation setting, inherit from parent if it's not default\n\n  if (!options.hasOwnProperty('delegate') && ractive.parent && ractive.parent.delegate !== ractive.delegate) {\n    ractive.delegate = false;\n  } // TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\n\n  constructHook.fire(ractive, options); // Add registries\n\n  var i = registryNames$1.length;\n\n  while (i--) {\n    var _name2 = registryNames$1[i];\n    ractive[_name2] = Object.assign(Object.create(ractive.constructor[_name2] || null), options[_name2]);\n  }\n\n  if (ractive._attributePartial) {\n    ractive.partials['extra-attributes'] = ractive._attributePartial;\n    delete ractive._attributePartial;\n  } // Create a viewmodel\n\n\n  var viewmodel = new RootModel({\n    adapt: getAdaptors(ractive, ractive.adapt, options),\n    data: dataConfigurator.init(ractive.constructor, ractive, options),\n    ractive: ractive\n  });\n  ractive.viewmodel = viewmodel; // Add computed properties\n\n  var computed = Object.assign(Object.create(ractive.constructor.prototype.computed), options.computed);\n\n  for (var key in computed) {\n    if (key === '__proto__') continue;\n    var signature = getComputationSignature(ractive, key, computed[key]);\n    viewmodel.compute(key, signature);\n  }\n}\n\nfunction getAdaptors(ractive, protoAdapt, options) {\n  protoAdapt = protoAdapt.map(lookup);\n  var adapt = ensureArray(options.adapt).map(lookup);\n  var srcs = [protoAdapt, adapt];\n\n  if (ractive.parent && !ractive.isolated) {\n    srcs.push(ractive.parent.viewmodel.adaptors);\n  }\n\n  return combine.apply(null, srcs);\n\n  function lookup(adaptor) {\n    if (typeof adaptor === 'string') {\n      adaptor = findInViewHierarchy('adaptors', ractive, adaptor);\n\n      if (!adaptor) {\n        fatal(missingPlugin(adaptor, 'adaptor'));\n      }\n    }\n\n    return adaptor;\n  }\n}\n\nfunction initialiseProperties(ractive) {\n  // Generate a unique identifier, for places where you'd use a weak map if it\n  // existed\n  ractive._guid = 'r-' + uid++; // events\n\n  ractive._subs = Object.create(null);\n  ractive._nsSubs = 0; // storage for item configuration from instantiation to reset,\n  // like dynamic functions or original values\n\n  ractive._config = {}; // events\n\n  ractive.event = null;\n  ractive._eventQueue = []; // observers\n\n  ractive._observers = []; // external children\n\n  ractive._children = [];\n  ractive._children.byName = {};\n  ractive.children = ractive._children;\n\n  if (!ractive.component) {\n    ractive.root = ractive;\n    ractive.parent = ractive.container = null; // TODO container still applicable?\n  }\n}\n\nfunction handleAttributes(ractive) {\n  var component = ractive.component;\n  var attributes = ractive.constructor.attributes;\n\n  if (attributes && component) {\n    var tpl = component.template;\n    var attrs = tpl.m ? tpl.m.slice() : []; // grab all of the passed attribute names\n\n    var props = attrs.filter(function (a) {\n      return a.t === ATTRIBUTE;\n    }).map(function (a) {\n      return a.n;\n    }); // warn about missing requireds\n\n    attributes.required.forEach(function (p) {\n      if (!~props.indexOf(p)) {\n        warnIfDebug(\"Component '\".concat(component.name, \"' requires attribute '\").concat(p, \"' to be provided\"));\n      }\n    }); // set up a partial containing non-property attributes\n\n    var all = attributes.optional.concat(attributes.required);\n    var partial = [];\n    var _i28 = attrs.length;\n\n    while (_i28--) {\n      var a = attrs[_i28];\n\n      if (a.t === ATTRIBUTE && !~all.indexOf(a.n)) {\n        if (attributes.mapAll) {\n          // map the attribute if requested and make the extra attribute in the partial refer to the mapping\n          partial.unshift({\n            t: ATTRIBUTE,\n            n: a.n,\n            f: [{\n              t: INTERPOLATOR,\n              r: \"~/\".concat(a.n)\n            }]\n          });\n        } else {\n          // transfer the attribute to the extra attributes partal\n          partial.unshift(attrs.splice(_i28, 1)[0]);\n        }\n      }\n    }\n\n    if (partial.length) component.template = {\n      t: tpl.t,\n      e: tpl.e,\n      f: tpl.f,\n      m: attrs,\n      p: tpl.p\n    };\n    ractive._attributePartial = partial;\n  }\n}\n\nvar Component =\n/*#__PURE__*/\nfunction (_Item5) {\n  _inherits(Component, _Item5);\n\n  function Component(options, ComponentConstructor) {\n    var _this38;\n\n    _classCallCheck(this, Component);\n\n    _this38 = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this, options));\n    var template = options.template;\n    _this38.isAnchor = template.t === ANCHOR;\n    _this38.type = _this38.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super\n\n    var attrs = template.m;\n    var partials = template.p || {};\n    if (!('content' in partials)) partials.content = template.f || [];\n    _this38._partials = partials; // TEMP\n\n    if (_this38.isAnchor) {\n      _this38.name = template.n;\n      _this38.addChild = addChild;\n      _this38.removeChild = removeChild;\n    } else {\n      var instance = Object.create(ComponentConstructor.prototype);\n      _this38.instance = instance;\n      _this38.name = template.e;\n\n      if (instance.el) {\n        warnIfDebug(\"The <\".concat(_this38.name, \"> component has a default 'el' property; it has been disregarded\"));\n      } // find container\n\n\n      var fragment = options.parentFragment;\n      var container;\n\n      while (fragment) {\n        if (fragment.owner.type === YIELDER) {\n          container = fragment.owner.container;\n          break;\n        }\n\n        fragment = fragment.parent;\n      } // add component-instance-specific properties\n\n\n      instance.parent = _this38.parentFragment.ractive;\n      instance.container = container || null;\n      instance.root = instance.parent.root;\n      instance.component = _assertThisInitialized(_this38);\n      construct(_this38.instance, {\n        partials: partials\n      }); // these can be modified during construction\n\n      template = _this38.template;\n      attrs = template.m; // allow components that are so inclined to add programmatic mappings\n\n      if (Array.isArray(_this38.mappings)) {\n        attrs = (attrs || []).concat(_this38.mappings);\n      } else if (typeof _this38.mappings === 'string') {\n        attrs = (attrs || []).concat(parser.parse(_this38.mappings, {\n          attributes: true\n        }).t);\n      } // for hackability, this could be an open option\n      // for any ractive instance, but for now, just\n      // for components and just for ractive...\n\n\n      instance._inlinePartials = partials;\n    }\n\n    _this38.attributeByName = {};\n    _this38.attributes = [];\n\n    if (attrs) {\n      var leftovers = [];\n      attrs.forEach(function (template) {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case EVENT:\n            _this38.attributes.push(createItem({\n              owner: _assertThisInitialized(_this38),\n              parentFragment: _this38.parentFragment,\n              template: template\n            }));\n\n            break;\n\n          case TRANSITION:\n          case BINDING_FLAG:\n          case DECORATOR:\n            break;\n\n          default:\n            leftovers.push(template);\n            break;\n        }\n      });\n\n      if (leftovers.length) {\n        _this38.attributes.push(new ConditionalAttribute({\n          owner: _assertThisInitialized(_this38),\n          parentFragment: _this38.parentFragment,\n          template: leftovers\n        }));\n      }\n    }\n\n    _this38.eventHandlers = [];\n    return _this38;\n  }\n\n  _createClass(Component, [{\n    key: \"bind\",\n    value: function bind() {\n      if (!this.isAnchor) {\n        this.attributes.forEach(_bind2);\n        initialise(this.instance, {\n          partials: this._partials\n        }, {\n          cssIds: this.parentFragment.cssIds\n        });\n        this.eventHandlers.forEach(_bind2);\n        this.bound = true;\n      }\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.dirty = true;\n        this.parentFragment.bubble();\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      if (!this.isAnchor && this.instance.fragment) this.instance.fragment.destroyed();\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      if (this.isAnchor) {\n        if (this.instance) return this.instance.fragment.detach();\n        return createDocumentFragment();\n      }\n\n      return this.instance.fragment.detach();\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector, options) {\n      if (this.instance) return this.instance.fragment.find(selector, options);\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      if (this.instance) this.instance.fragment.findAll(selector, options);\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent(name, options) {\n      if (!name || this.name === name) return this.instance;\n\n      if (this.instance.fragment) {\n        return this.instance.fragment.findComponent(name, options);\n      }\n    }\n  }, {\n    key: \"findAllComponents\",\n    value: function findAllComponents(name, options) {\n      var result = options.result;\n\n      if (this.instance && (!name || this.name === name)) {\n        result.push(this.instance);\n      }\n\n      if (this.instance) this.instance.findAllComponents(name, options);\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode(skipParent) {\n      if (this.instance) return this.instance.fragment.firstNode(skipParent);\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      for (var _len15 = arguments.length, assigns = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {\n        assigns[_key15] = arguments[_key15];\n      }\n\n      assigns.unshift(this.instance);\n      return getRactiveContext.apply(null, assigns);\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      if (this.isAnchor) {\n        this.rendered = true;\n        this.target = target;\n\n        if (!checking.length) {\n          checking.push(this.ractive);\n\n          if (occupants) {\n            this.occupants = occupants;\n            checkAnchors();\n            this.occupants = null;\n          } else {\n            runloop.scheduleTask(checkAnchors, true);\n          }\n        }\n      } else {\n        render$1(this.instance, target, null, occupants);\n        this.attributes.forEach(_render);\n        this.eventHandlers.forEach(_render);\n        this.rendered = true;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.instance) return this.instance.toHTML();\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (!this.isAnchor) {\n        this.bound = false;\n        this.attributes.forEach(_unbind);\n        teardown$1(this.instance, function () {\n          return runloop.promise();\n        });\n      }\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      this.shouldDestroy = shouldDestroy;\n\n      if (this.isAnchor) {\n        if (this.item) unrenderItem(this, this.item);\n        this.target = null;\n\n        if (!checking.length) {\n          checking.push(this.ractive);\n          runloop.scheduleTask(checkAnchors, true);\n        }\n      } else {\n        this.instance.unrender();\n        this.instance.el = this.instance.target = null;\n        this.attributes.forEach(_unrender);\n        this.eventHandlers.forEach(_unrender);\n      }\n\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.dirty = false;\n\n      if (this.instance) {\n        this.instance.fragment.update();\n        this.attributes.forEach(_update);\n        this.eventHandlers.forEach(_update);\n      }\n    }\n  }]);\n\n  return Component;\n}(Item);\n\nfunction addChild(meta) {\n  if (this.item) this.removeChild(this.item);\n  var child = meta.instance;\n  meta.anchor = this;\n  meta.parentFragment = this.parentFragment;\n  meta.name = meta.nameOption || this.name;\n  this.name = meta.name;\n  if (!child.isolated) child.viewmodel.attached(this.parentFragment); // render as necessary\n\n  if (this.rendered) {\n    renderItem(this, meta);\n  }\n}\n\nfunction removeChild(meta) {\n  // unrender as necessary\n  if (this.item === meta) {\n    unrenderItem(this, meta);\n    this.name = this.template.n;\n  }\n}\n\nfunction renderItem(anchor, meta) {\n  if (!anchor.rendered) return;\n  meta.shouldDestroy = false;\n  meta.parentFragment = anchor.parentFragment;\n  anchor.item = meta;\n  anchor.instance = meta.instance;\n  var nextNode = anchor.parentFragment.findNextNode(anchor);\n\n  if (meta.instance.fragment.rendered) {\n    meta.instance.unrender();\n  }\n\n  meta.partials = meta.instance.partials;\n  meta.instance.partials = Object.assign(Object.create(meta.partials), meta.partials, anchor._partials);\n  meta.instance.fragment.unbind();\n  meta.instance.fragment.componentParent = anchor.parentFragment;\n  meta.instance.fragment.bind(meta.instance.viewmodel);\n  anchor.attributes.forEach(_bind2);\n  anchor.eventHandlers.forEach(_bind2);\n  anchor.attributes.forEach(_render);\n  anchor.eventHandlers.forEach(_render);\n  var target = anchor.parentFragment.findParentNode();\n  render$1(meta.instance, target, target.contains(nextNode) ? nextNode : null, anchor.occupants);\n\n  if (meta.lastBound !== anchor) {\n    meta.lastBound = anchor;\n  }\n}\n\nfunction unrenderItem(anchor, meta) {\n  if (!anchor.rendered) return;\n  meta.shouldDestroy = true;\n  meta.instance.unrender();\n  anchor.eventHandlers.forEach(_unrender);\n  anchor.attributes.forEach(_unrender);\n  anchor.eventHandlers.forEach(_unbind);\n  anchor.attributes.forEach(_unbind);\n  meta.instance.el = meta.instance.anchor = null;\n  meta.instance.fragment.componentParent = null;\n  meta.parentFragment = null;\n  meta.anchor = null;\n  anchor.item = null;\n  anchor.instance = null;\n}\n\nvar checking = [];\n\nfunction checkAnchors() {\n  var list = checking;\n  checking = [];\n  list.forEach(updateAnchors);\n}\n\nfunction setupArgsFn(item, template, fragment) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (template && template.f && template.f.s) {\n    item.fn = getFunction(template.f.s, template.f.r.length);\n\n    if (opts.register === true) {\n      item.models = resolveArgs(item, template, fragment, opts);\n    }\n  }\n}\n\nfunction resolveArgs(item, template, fragment) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return template.f.r.map(function (ref, i) {\n    var model;\n    if (opts.specialRef && (model = opts.specialRef(ref, i))) return model;\n    model = resolveReference(fragment, ref);\n\n    if (opts.register === true) {\n      model.register(item);\n    }\n\n    return model;\n  });\n}\n\nfunction teardownArgsFn(item, template) {\n  if (template && template.f && template.f.s) {\n    if (item.models) item.models.forEach(function (m) {\n      if (m && m.unregister) m.unregister(item);\n    });\n    item.models = null;\n  }\n}\n\nvar missingDecorator = {\n  update: noop,\n  teardown: noop\n};\n\nvar Decorator =\n/*#__PURE__*/\nfunction () {\n  function Decorator(options) {\n    _classCallCheck(this, Decorator);\n\n    this.owner = options.owner || options.parentFragment.owner || findElement(options.parentFragment);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.parentFragment);\n    this.parentFragment = this.owner.parentFragment;\n    this.ractive = this.owner.ractive;\n    var template = this.template = options.template;\n    this.name = template.n;\n    this.node = null;\n    this.handle = null;\n    this.element.decorators.push(this);\n  }\n\n  _createClass(Decorator, [{\n    key: \"bind\",\n    value: function bind() {\n      setupArgsFn(this, this.template, this.parentFragment, {\n        register: true\n      });\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (!this.dirty) {\n        this.dirty = true;\n        this.owner.bubble();\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      if (this.handle) {\n        this.handle.teardown();\n        this.handle = null;\n      }\n\n      this.shouldDestroy = true;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.bubble();\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous, safe) {\n      var idx = this.models.indexOf(previous);\n      if (!~idx) return;\n      next = rebindMatch(this.template.f.r[idx], next, previous);\n      if (next === previous) return;\n      previous.unregister(this);\n      this.models.splice(idx, 1, next);\n      if (next) next.addShuffleRegister(this, 'mark');\n      if (!safe) this.bubble();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this39 = this;\n\n      this.shouldDestroy = false;\n      if (this.handle) this.unrender();\n      runloop.scheduleTask(function () {\n        var fn = findInViewHierarchy('decorators', _this39.ractive, _this39.name);\n\n        if (!fn) {\n          warnOnce(missingPlugin(_this39.name, 'decorator'));\n          _this39.handle = missingDecorator;\n          return;\n        }\n\n        _this39.node = _this39.element.node;\n        var args;\n\n        if (_this39.fn) {\n          args = _this39.models.map(function (model) {\n            if (!model) return undefined;\n            return model.get();\n          });\n          args = _this39.fn.apply(_this39.ractive, args);\n        }\n\n        _this39.handle = fn.apply(_this39.ractive, [_this39.node].concat(args));\n\n        if (!_this39.handle || !_this39.handle.teardown) {\n          throw new Error(\"The '\".concat(_this39.name, \"' decorator must return an object with a teardown method\"));\n        } // watch out for decorators that cause their host element to be unrendered\n\n\n        if (_this39.shouldDestroy) _this39.destroyed();\n      }, true);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '';\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      teardownArgsFn(this, this.template);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if ((!shouldDestroy || this.element.rendered) && this.handle) {\n        this.handle.teardown();\n        this.handle = null;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var instance = this.handle;\n\n      if (!this.dirty) {\n        if (instance && instance.invalidate) {\n          runloop.scheduleTask(function () {\n            return instance.invalidate();\n          }, true);\n        }\n\n        return;\n      }\n\n      this.dirty = false;\n\n      if (instance) {\n        if (!instance.update) {\n          this.unrender();\n          this.render();\n        } else {\n          var args = this.models.map(function (model) {\n            return model && model.get();\n          });\n          instance.update.apply(this.ractive, this.fn.apply(this.ractive, args));\n        }\n      }\n    }\n  }]);\n\n  return Decorator;\n}();\n\nvar Doctype =\n/*#__PURE__*/\nfunction (_Item6) {\n  _inherits(Doctype, _Item6);\n\n  function Doctype() {\n    _classCallCheck(this, Doctype);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Doctype).apply(this, arguments));\n  }\n\n  _createClass(Doctype, [{\n    key: \"toString\",\n    value: function toString() {\n      return '<!DOCTYPE' + this.template.a + '>';\n    }\n  }]);\n\n  return Doctype;\n}(Item);\n\nvar proto$2 = Doctype.prototype;\nproto$2.bind = proto$2.render = proto$2.teardown = proto$2.unbind = proto$2.unrender = proto$2.update = noop;\n\nvar Binding =\n/*#__PURE__*/\nfunction () {\n  function Binding(element) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';\n\n    _classCallCheck(this, Binding);\n\n    this.element = element;\n    this.ractive = element.ractive;\n    this.attribute = element.attributeByName[name];\n    var interpolator = this.attribute.interpolator;\n    interpolator.twowayBinding = this;\n    var model = interpolator.model;\n\n    if (model.isReadonly && !model.setRoot) {\n      var keypath = model.getKeypath().replace(/^@/, '');\n      warnOnceIfDebug(\"Cannot use two-way binding on <\".concat(element.name, \"> element: \").concat(keypath, \" is read-only. To suppress this warning use <\").concat(element.name, \" twoway='false'...>\"), {\n        ractive: this.ractive\n      });\n      return false;\n    }\n\n    this.attribute.isTwoway = true;\n    this.model = model; // initialise value, if it's undefined\n\n    var value = model.get();\n    this.wasUndefined = value === undefined;\n\n    if (value === undefined && this.getInitialValue) {\n      value = this.getInitialValue();\n      model.set(value);\n    }\n\n    this.lastVal(true, value);\n    var parentForm = findElement(this.element, false, 'form');\n\n    if (parentForm) {\n      this.resetValue = value;\n      parentForm.formBindings.push(this);\n    }\n  }\n\n  _createClass(Binding, [{\n    key: \"bind\",\n    value: function bind() {\n      this.model.registerTwowayBinding(this);\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      var _this40 = this;\n\n      var value = this.getValue();\n      if (this.lastVal() === value) return;\n      runloop.start();\n      this.attribute.locked = true;\n      this.model.set(value);\n      this.lastVal(true, value); // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n\n      if (this.model.get() !== value) this.attribute.locked = false;else runloop.scheduleTask(function () {\n        return _this40.attribute.locked = false;\n      });\n      runloop.end();\n    }\n  }, {\n    key: \"lastVal\",\n    value: function lastVal(setting, value) {\n      if (setting) this.lastValue = value;else return this.lastValue;\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous) {\n      var _this41 = this;\n\n      if (this.model && this.model === previous) previous.unregisterTwowayBinding(this);\n\n      if (next) {\n        this.model = next;\n        runloop.scheduleTask(function () {\n          return next.registerTwowayBinding(_this41);\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.node = this.element.node;\n      this.node._ractive.binding = this;\n      this.rendered = true; // TODO is this used anywhere?\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      this.model.set(node.value);\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.model.unregisterTwowayBinding(this);\n    }\n  }]);\n\n  return Binding;\n}();\n\nBinding.prototype.unrender = noop; // This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\n\nfunction handleDomEvent() {\n  this._ractive.binding.handleChange();\n}\n\nvar CheckboxBinding =\n/*#__PURE__*/\nfunction (_Binding) {\n  _inherits(CheckboxBinding, _Binding);\n\n  function CheckboxBinding(element) {\n    _classCallCheck(this, CheckboxBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CheckboxBinding).call(this, element, 'checked'));\n  }\n\n  _createClass(CheckboxBinding, [{\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(CheckboxBinding.prototype), \"render\", this).call(this);\n\n      this.element.on('change', handleDomEvent);\n\n      if (this.node.attachEvent) {\n        this.element.on('click', handleDomEvent);\n      }\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.element.off('change', handleDomEvent);\n      this.element.off('click', handleDomEvent);\n    }\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      return !!this.element.getAttribute('checked');\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.node.checked;\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      this.model.set(node.checked);\n    }\n  }]);\n\n  return CheckboxBinding;\n}(Binding);\n\nfunction getBindingGroup(group, model, getValue) {\n  var hash = \"\".concat(group, \"-bindingGroup\");\n  return model[hash] || (model[hash] = new BindingGroup(hash, model, getValue));\n}\n\nvar BindingGroup =\n/*#__PURE__*/\nfunction () {\n  function BindingGroup(hash, model, getValue) {\n    var _this42 = this;\n\n    _classCallCheck(this, BindingGroup);\n\n    this.model = model;\n    this.hash = hash;\n\n    this.getValue = function () {\n      _this42.value = getValue.call(_this42);\n      return _this42.value;\n    };\n\n    this.bindings = [];\n  }\n\n  _createClass(BindingGroup, [{\n    key: \"add\",\n    value: function add(binding) {\n      this.bindings.push(binding);\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      this.value = this.model.get();\n      this.model.registerTwowayBinding(this);\n      this.bound = true;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(binding) {\n      removeFromArray(this.bindings, binding);\n\n      if (!this.bindings.length) {\n        this.unbind();\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.model.unregisterTwowayBinding(this);\n      this.bound = false;\n      delete this.model[this.hash];\n    }\n  }]);\n\n  return BindingGroup;\n}();\n\nBindingGroup.prototype.rebind = Binding.prototype.rebind;\nvar push$1 = [].push;\n\nfunction getValue() {\n  var _this43 = this;\n\n  var all = this.bindings.filter(function (b) {\n    return b.node && b.node.checked;\n  }).map(function (b) {\n    return b.element.getAttribute('value');\n  });\n  var res = [];\n  all.forEach(function (v) {\n    if (!_this43.bindings[0].arrayContains(res, v)) res.push(v);\n  });\n  return res;\n}\n\nvar CheckboxNameBinding =\n/*#__PURE__*/\nfunction (_Binding2) {\n  _inherits(CheckboxNameBinding, _Binding2);\n\n  function CheckboxNameBinding(element) {\n    var _this44;\n\n    _classCallCheck(this, CheckboxNameBinding);\n\n    _this44 = _possibleConstructorReturn(this, _getPrototypeOf(CheckboxNameBinding).call(this, element, 'name'));\n    _this44.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n    // Each input has a reference to an array containing it and its\n    // group, as two-way binding depends on being able to ascertain\n    // the status of all inputs within the group\n\n    _this44.group = getBindingGroup('checkboxes', _this44.model, getValue);\n\n    _this44.group.add(_assertThisInitialized(_this44));\n\n    if (_this44.noInitialValue) {\n      _this44.group.noInitialValue = true;\n    } // If no initial value was set, and this input is checked, we\n    // update the model\n\n\n    if (_this44.group.noInitialValue && _this44.element.getAttribute('checked')) {\n      var existingValue = _this44.model.get();\n\n      var bindingValue = _this44.element.getAttribute('value');\n\n      if (!_this44.arrayContains(existingValue, bindingValue)) {\n        push$1.call(existingValue, bindingValue); // to avoid triggering runloop with array adaptor\n      }\n    }\n\n    return _this44;\n  }\n\n  _createClass(CheckboxNameBinding, [{\n    key: \"bind\",\n    value: function bind() {\n      if (!this.group.bound) {\n        this.group.bind();\n      }\n    }\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      // This only gets called once per group (of inputs that\n      // share a name), because it only gets called if there\n      // isn't an initial value. By the same token, we can make\n      // a note of that fact that there was no initial value,\n      // and populate it using any `checked` attributes that\n      // exist (which users should avoid, but which we should\n      // support anyway to avoid breaking expectations)\n      this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n\n      return [];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.group.value;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.isChecked = this.element.node.checked;\n      this.group.value = this.model.get();\n      var value = this.element.getAttribute('value');\n\n      if (this.isChecked && !this.arrayContains(this.group.value, value)) {\n        this.group.value.push(value);\n      } else if (!this.isChecked && this.arrayContains(this.group.value, value)) {\n        this.removeFromArray(this.group.value, value);\n      } // make sure super knows there's a change\n\n\n      this.lastValue = null;\n\n      _get(_getPrototypeOf(CheckboxNameBinding.prototype), \"handleChange\", this).call(this);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(CheckboxNameBinding.prototype), \"render\", this).call(this);\n\n      var node = this.node;\n      var existingValue = this.model.get();\n      var bindingValue = this.element.getAttribute('value');\n\n      if (Array.isArray(existingValue)) {\n        this.isChecked = this.arrayContains(existingValue, bindingValue);\n      } else {\n        this.isChecked = this.element.compare(existingValue, bindingValue);\n      }\n\n      node.name = '{{' + this.model.getKeypath() + '}}';\n      node.checked = this.isChecked;\n      this.element.on('change', handleDomEvent); // in case of IE emergency, bind to click event as well\n\n      if (this.node.attachEvent) {\n        this.element.on('click', handleDomEvent);\n      }\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      this.group.bindings.forEach(function (binding) {\n        return binding.wasUndefined = true;\n      });\n\n      if (node.checked) {\n        var valueSoFar = this.group.getValue();\n        valueSoFar.push(this.element.getAttribute('value'));\n        this.group.model.set(valueSoFar);\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.group.remove(this);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      var el = this.element;\n      el.off('change', handleDomEvent);\n      el.off('click', handleDomEvent);\n    }\n  }, {\n    key: \"arrayContains\",\n    value: function arrayContains(selectValue, optionValue) {\n      var i = selectValue.length;\n\n      while (i--) {\n        if (this.element.compare(optionValue, selectValue[i])) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"removeFromArray\",\n    value: function removeFromArray(array, item) {\n      if (!array) return;\n      var i = array.length;\n\n      while (i--) {\n        if (this.element.compare(item, array[i])) {\n          array.splice(i, 1);\n        }\n      }\n    }\n  }]);\n\n  return CheckboxNameBinding;\n}(Binding);\n\nvar ContentEditableBinding =\n/*#__PURE__*/\nfunction (_Binding3) {\n  _inherits(ContentEditableBinding, _Binding3);\n\n  function ContentEditableBinding() {\n    _classCallCheck(this, ContentEditableBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ContentEditableBinding).apply(this, arguments));\n  }\n\n  _createClass(ContentEditableBinding, [{\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      return this.element.fragment ? this.element.fragment.toString() : '';\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.element.node.innerHTML;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(ContentEditableBinding.prototype), \"render\", this).call(this);\n\n      var el = this.element;\n      el.on('change', handleDomEvent);\n      el.on('blur', handleDomEvent);\n\n      if (!this.ractive.lazy) {\n        el.on('input', handleDomEvent);\n\n        if (this.node.attachEvent) {\n          el.on('keyup', handleDomEvent);\n        }\n      }\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      this.model.set(node.innerHTML);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      var el = this.element;\n      el.off('blur', handleDomEvent);\n      el.off('change', handleDomEvent);\n      el.off('input', handleDomEvent);\n      el.off('keyup', handleDomEvent);\n    }\n  }]);\n\n  return ContentEditableBinding;\n}(Binding);\n\nfunction handleBlur() {\n  handleDomEvent.call(this);\n\n  var value = this._ractive.binding.model.get();\n\n  this.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay(delay) {\n  var timeout;\n  return function () {\n    var _this45 = this;\n\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      var binding = _this45._ractive.binding;\n      if (binding.rendered) handleDomEvent.call(_this45);\n      timeout = null;\n    }, delay);\n  };\n}\n\nvar GenericBinding =\n/*#__PURE__*/\nfunction (_Binding4) {\n  _inherits(GenericBinding, _Binding4);\n\n  function GenericBinding() {\n    _classCallCheck(this, GenericBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GenericBinding).apply(this, arguments));\n  }\n\n  _createClass(GenericBinding, [{\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      return '';\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.node.value;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(GenericBinding.prototype), \"render\", this).call(this); // any lazy setting for this element overrides the root\n      // if the value is a number, it's a timeout\n\n\n      var lazy = this.ractive.lazy;\n      var timeout = false;\n      var el = this.element;\n\n      if ('lazy' in this.element) {\n        lazy = this.element.lazy;\n      }\n\n      if (isNumeric(lazy)) {\n        timeout = +lazy;\n        lazy = false;\n      }\n\n      this.handler = timeout ? handleDelay(timeout) : handleDomEvent;\n      var node = this.node;\n      el.on('change', handleDomEvent);\n\n      if (node.type !== 'file') {\n        if (!lazy) {\n          el.on('input', this.handler); // IE is a special snowflake\n\n          if (node.attachEvent) {\n            el.on('keyup', this.handler);\n          }\n        }\n\n        el.on('blur', handleBlur);\n      }\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      var el = this.element;\n      this.rendered = false;\n      el.off('change', handleDomEvent);\n      el.off('input', this.handler);\n      el.off('keyup', this.handler);\n      el.off('blur', handleBlur);\n    }\n  }]);\n\n  return GenericBinding;\n}(Binding);\n\nvar FileBinding =\n/*#__PURE__*/\nfunction (_GenericBinding) {\n  _inherits(FileBinding, _GenericBinding);\n\n  function FileBinding() {\n    _classCallCheck(this, FileBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FileBinding).apply(this, arguments));\n  }\n\n  _createClass(FileBinding, [{\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      /* istanbul ignore next */\n      return undefined;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      /* istanbul ignore next */\n      return this.node.files;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      /* istanbul ignore next */\n      this.element.lazy = false;\n      /* istanbul ignore next */\n\n      _get(_getPrototypeOf(FileBinding.prototype), \"render\", this).call(this);\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      /* istanbul ignore next */\n      this.model.set(node.files);\n    }\n  }]);\n\n  return FileBinding;\n}(GenericBinding);\n\nfunction getSelectedOptions(select) {\n  /* istanbul ignore next */\n  return select.selectedOptions ? toArray(select.selectedOptions) : select.options ? toArray(select.options).filter(function (option) {\n    return option.selected;\n  }) : [];\n}\n\nvar MultipleSelectBinding =\n/*#__PURE__*/\nfunction (_Binding5) {\n  _inherits(MultipleSelectBinding, _Binding5);\n\n  function MultipleSelectBinding() {\n    _classCallCheck(this, MultipleSelectBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MultipleSelectBinding).apply(this, arguments));\n  }\n\n  _createClass(MultipleSelectBinding, [{\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      return this.element.options.filter(function (option) {\n        return option.getAttribute('selected');\n      }).map(function (option) {\n        return option.getAttribute('value');\n      });\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      var options = this.element.node.options;\n      var len = options.length;\n      var selectedValues = [];\n\n      for (var _i29 = 0; _i29 < len; _i29 += 1) {\n        var option = options[_i29];\n\n        if (option.selected) {\n          var optionValue = option._ractive ? option._ractive.value : option.value;\n          selectedValues.push(optionValue);\n        }\n      }\n\n      return selectedValues;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      var attribute = this.attribute;\n      var previousValue = attribute.getValue();\n      var value = this.getValue();\n\n      if (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n        _get(_getPrototypeOf(MultipleSelectBinding.prototype), \"handleChange\", this).call(this);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(MultipleSelectBinding.prototype), \"render\", this).call(this);\n\n      this.element.on('change', handleDomEvent);\n\n      if (this.model.get() === undefined) {\n        // get value from DOM, if possible\n        this.handleChange();\n      }\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      var selectedOptions = getSelectedOptions(node);\n      var i = selectedOptions.length;\n      var result = new Array(i);\n\n      while (i--) {\n        var option = selectedOptions[i];\n        result[i] = option._ractive ? option._ractive.value : option.value;\n      }\n\n      this.model.set(result);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.element.off('change', handleDomEvent);\n    }\n  }]);\n\n  return MultipleSelectBinding;\n}(Binding);\n\nvar NumericBinding =\n/*#__PURE__*/\nfunction (_GenericBinding2) {\n  _inherits(NumericBinding, _GenericBinding2);\n\n  function NumericBinding() {\n    _classCallCheck(this, NumericBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NumericBinding).apply(this, arguments));\n  }\n\n  _createClass(NumericBinding, [{\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      return undefined;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      var value = parseFloat(this.node.value);\n      return isNaN(value) ? undefined : value;\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      var value = parseFloat(node.value);\n      if (!isNaN(value)) this.model.set(value);\n    }\n  }]);\n\n  return NumericBinding;\n}(GenericBinding);\n\nvar siblings = {};\n\nfunction getSiblings(hash) {\n  return siblings[hash] || (siblings[hash] = []);\n}\n\nvar RadioBinding =\n/*#__PURE__*/\nfunction (_Binding6) {\n  _inherits(RadioBinding, _Binding6);\n\n  function RadioBinding(element) {\n    var _this46;\n\n    _classCallCheck(this, RadioBinding);\n\n    _this46 = _possibleConstructorReturn(this, _getPrototypeOf(RadioBinding).call(this, element, 'checked'));\n    _this46.siblings = getSiblings(_this46.ractive._guid + _this46.element.getAttribute('name'));\n\n    _this46.siblings.push(_assertThisInitialized(_this46));\n\n    return _this46;\n  }\n\n  _createClass(RadioBinding, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.node.checked;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      runloop.start();\n      this.siblings.forEach(function (binding) {\n        binding.model.set(binding.getValue());\n      });\n      runloop.end();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(RadioBinding.prototype), \"render\", this).call(this);\n\n      this.element.on('change', handleDomEvent);\n\n      if (this.node.attachEvent) {\n        this.element.on('click', handleDomEvent);\n      }\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      this.model.set(node.checked);\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      removeFromArray(this.siblings, this);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.element.off('change', handleDomEvent);\n      this.element.off('click', handleDomEvent);\n    }\n  }]);\n\n  return RadioBinding;\n}(Binding);\n\nfunction getValue$1() {\n  var checked = this.bindings.filter(function (b) {\n    return b.node.checked;\n  });\n\n  if (checked.length > 0) {\n    return checked[0].element.getAttribute('value');\n  }\n}\n\nvar RadioNameBinding =\n/*#__PURE__*/\nfunction (_Binding7) {\n  _inherits(RadioNameBinding, _Binding7);\n\n  function RadioNameBinding(element) {\n    var _this47;\n\n    _classCallCheck(this, RadioNameBinding);\n\n    _this47 = _possibleConstructorReturn(this, _getPrototypeOf(RadioNameBinding).call(this, element, 'name'));\n    _this47.group = getBindingGroup('radioname', _this47.model, getValue$1);\n\n    _this47.group.add(_assertThisInitialized(_this47));\n\n    if (element.checked) {\n      _this47.group.value = _this47.getValue();\n    }\n\n    return _this47;\n  }\n\n  _createClass(RadioNameBinding, [{\n    key: \"bind\",\n    value: function bind() {\n      var _this48 = this;\n\n      if (!this.group.bound) {\n        this.group.bind();\n      } // update name keypath when necessary\n\n\n      this.nameAttributeBinding = {\n        handleChange: function handleChange() {\n          return _this48.node.name = \"{{\".concat(_this48.model.getKeypath(), \"}}\");\n        },\n        rebind: noop\n      };\n      this.model.getKeypathModel().register(this.nameAttributeBinding);\n    }\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      if (this.element.getAttribute('checked')) {\n        return this.element.getAttribute('value');\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.element.getAttribute('value');\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      // If this <input> is the one that's checked, then the value of its\n      // `name` model gets set to its value\n      if (this.node.checked) {\n        this.group.value = this.getValue();\n\n        _get(_getPrototypeOf(RadioNameBinding.prototype), \"handleChange\", this).call(this);\n      }\n    }\n  }, {\n    key: \"lastVal\",\n    value: function lastVal(setting, value) {\n      if (!this.group) return;\n      if (setting) this.group.lastValue = value;else return this.group.lastValue;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(RadioNameBinding.prototype), \"render\", this).call(this);\n\n      var node = this.node;\n      node.name = \"{{\".concat(this.model.getKeypath(), \"}}\");\n      node.checked = this.element.compare(this.model.get(), this.element.getAttribute('value'));\n      this.element.on('change', handleDomEvent);\n\n      if (node.attachEvent) {\n        this.element.on('click', handleDomEvent);\n      }\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      if (node.checked) {\n        this.group.model.set(this.element.getAttribute('value'));\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.group.remove(this);\n      this.model.getKeypathModel().unregister(this.nameAttributeBinding);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      var el = this.element;\n      el.off('change', handleDomEvent);\n      el.off('click', handleDomEvent);\n    }\n  }]);\n\n  return RadioNameBinding;\n}(Binding);\n\nvar SingleSelectBinding =\n/*#__PURE__*/\nfunction (_Binding8) {\n  _inherits(SingleSelectBinding, _Binding8);\n\n  function SingleSelectBinding() {\n    _classCallCheck(this, SingleSelectBinding);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SingleSelectBinding).apply(this, arguments));\n  }\n\n  _createClass(SingleSelectBinding, [{\n    key: \"forceUpdate\",\n    value: function forceUpdate() {\n      var _this49 = this;\n\n      var value = this.getValue();\n\n      if (value !== undefined) {\n        this.attribute.locked = true;\n        runloop.scheduleTask(function () {\n          return _this49.attribute.locked = false;\n        });\n        this.model.set(value);\n      }\n    }\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      if (this.element.getAttribute('value') !== undefined) {\n        return;\n      }\n\n      var options = this.element.options;\n      var len = options.length;\n      if (!len) return;\n      var value;\n      var optionWasSelected;\n      var i = len; // take the final selected option...\n\n      while (i--) {\n        var option = options[i];\n\n        if (option.getAttribute('selected')) {\n          if (!option.getAttribute('disabled')) {\n            value = option.getAttribute('value');\n          }\n\n          optionWasSelected = true;\n          break;\n        }\n      } // or the first non-disabled option, if none are selected\n\n\n      if (!optionWasSelected) {\n        while (++i < len) {\n          if (!options[i].getAttribute('disabled')) {\n            value = options[i].getAttribute('value');\n            break;\n          }\n        }\n      } // This is an optimisation (aka hack) that allows us to forgo some\n      // other more expensive work\n      // TODO does it still work? seems at odds with new architecture\n\n\n      if (value !== undefined) {\n        this.element.attributeByName.value.value = value;\n      }\n\n      return value;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      var options = this.node.options;\n      var len = options.length;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        var option = options[i];\n\n        if (options[i].selected && !options[i].disabled) {\n          return option._ractive ? option._ractive.value : option.value;\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      _get(_getPrototypeOf(SingleSelectBinding.prototype), \"render\", this).call(this);\n\n      this.element.on('change', handleDomEvent);\n    }\n  }, {\n    key: \"setFromNode\",\n    value: function setFromNode(node) {\n      var option = getSelectedOptions(node)[0];\n      this.model.set(option._ractive ? option._ractive.value : option.value);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.element.off('change', handleDomEvent);\n    }\n  }]);\n\n  return SingleSelectBinding;\n}(Binding);\n\nfunction isBindable(attribute) {\n  // The fragment must be a single non-string fragment\n  if (!attribute || !attribute.template.f || attribute.template.f.length !== 1 || attribute.template.f[0].s) return false; // A binding is an interpolator `{{ }}`, yey.\n\n  if (attribute.template.f[0].t === INTERPOLATOR) return true; // The above is probably the only true case. For the rest, show an appropriate\n  // warning before returning false.\n  // You can't bind a triple curly. HTML values on an attribute makes no sense.\n\n  if (attribute.template.f[0].t === TRIPLE) warnIfDebug('It is not possible create a binding using a triple mustache.');\n  return false;\n}\n\nfunction selectBinding(element) {\n  var name = element.name;\n  var attributes = element.attributeByName;\n  var isBindableByValue = isBindable(attributes.value);\n  var isBindableByContentEditable = isBindable(attributes.contenteditable);\n  var isContentEditable = element.getAttribute('contenteditable'); // contenteditable\n  // Bind if the contenteditable is true or a binding that may become true.\n\n  if ((isContentEditable || isBindableByContentEditable) && isBindableByValue) return ContentEditableBinding; // <input>\n\n  if (name === 'input') {\n    var type = element.getAttribute('type');\n\n    if (type === 'radio') {\n      var isBindableByName = isBindable(attributes.name);\n      var isBindableByChecked = isBindable(attributes.checked); // For radios we can either bind the name or checked, but not both.\n      // Name binding is handed instead.\n\n      if (isBindableByName && isBindableByChecked) {\n        warnIfDebug('A radio input can have two-way binding on its name attribute, or its checked attribute - not both', {\n          ractive: element.root\n        });\n        return RadioNameBinding;\n      }\n\n      if (isBindableByName) return RadioNameBinding;\n      if (isBindableByChecked) return RadioBinding; // Dead end. Unknown binding on radio input.\n\n      return null;\n    }\n\n    if (type === 'checkbox') {\n      var _isBindableByName = isBindable(attributes.name);\n\n      var _isBindableByChecked = isBindable(attributes.checked); // A checkbox with bindings for both name and checked. Checked treated as\n      // the checkbox value, name is treated as a regular binding.\n      //\n      // See https://github.com/ractivejs/ractive/issues/1749\n\n\n      if (_isBindableByName && _isBindableByChecked) return CheckboxBinding;\n      if (_isBindableByName) return CheckboxNameBinding;\n      if (_isBindableByChecked) return CheckboxBinding; // Dead end. Unknown binding on checkbox input.\n\n      return null;\n    }\n\n    if (type === 'file' && isBindableByValue) return FileBinding;\n    if (type === 'number' && isBindableByValue) return NumericBinding;\n    if (type === 'range' && isBindableByValue) return NumericBinding; // Some input of unknown type (browser usually falls back to text).\n\n    if (isBindableByValue) return GenericBinding; // Dead end. Some unknown input and an unbindable.\n\n    return null;\n  } // <select>\n\n\n  if (name === 'select' && isBindableByValue) {\n    return element.getAttribute('multiple') ? MultipleSelectBinding : SingleSelectBinding;\n  } // <textarea>\n\n\n  if (name === 'textarea' && isBindableByValue) return GenericBinding; // Dead end. Some unbindable element.\n\n  return null;\n}\n\nvar endsWithSemi = /;\\s*$/;\n\nvar Element =\n/*#__PURE__*/\nfunction (_ContainerItem2) {\n  _inherits(Element, _ContainerItem2);\n\n  function Element(options) {\n    var _this50;\n\n    _classCallCheck(this, Element);\n\n    _this50 = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, options));\n    _this50.name = options.template.e.toLowerCase(); // find parent element\n\n    _this50.parent = findElement(_this50.parentFragment, false);\n\n    if (_this50.parent && _this50.parent.name === 'option') {\n      throw new Error(\"An <option> element cannot contain other elements (encountered <\".concat(_this50.name, \">)\"));\n    }\n\n    _this50.decorators = []; // create attributes\n\n    _this50.attributeByName = {};\n    var attrs;\n    var n, attr, val, cls, name, template, leftovers;\n    var m = _this50.template.m;\n    var len = m && m.length || 0;\n\n    for (var _i30 = 0; _i30 < len; _i30++) {\n      template = m[_i30];\n\n      switch (template.t) {\n        case ATTRIBUTE:\n        case BINDING_FLAG:\n        case DECORATOR:\n        case EVENT:\n        case TRANSITION:\n          attr = createItem({\n            owner: _assertThisInitialized(_this50),\n            parentFragment: _this50.parentFragment,\n            template: template\n          });\n          n = template.n;\n          attrs = attrs || (attrs = _this50.attributes = []);\n          if (n === 'value') val = attr;else if (n === 'name') name = attr;else if (n === 'class') cls = attr;else attrs.push(attr);\n          break;\n\n        case DELEGATE_FLAG:\n          _this50.delegate = false;\n          break;\n\n        default:\n          (leftovers || (leftovers = [])).push(template);\n          break;\n      }\n    }\n\n    if (name) attrs.push(name);\n    if (val) attrs.push(val);\n    if (cls) attrs.unshift(cls);\n\n    if (leftovers) {\n      (attrs || (_this50.attributes = [])).push(new ConditionalAttribute({\n        owner: _assertThisInitialized(_this50),\n        parentFragment: _this50.parentFragment,\n        template: leftovers\n      })); // empty leftovers array\n\n      leftovers = [];\n    } // create children\n\n\n    if (options.template.f && !options.deferContent) {\n      _this50.fragment = new Fragment({\n        template: options.template.f,\n        owner: _assertThisInitialized(_this50),\n        cssIds: null\n      });\n    }\n\n    _this50.binding = null; // filled in later\n\n    return _this50;\n  }\n\n  _createClass(Element, [{\n    key: \"bind\",\n    value: function bind() {\n      var attrs = this.attributes;\n\n      if (attrs) {\n        attrs.binding = true;\n        attrs.forEach(_bind2);\n        attrs.binding = false;\n      }\n\n      if (this.fragment) this.fragment.bind(); // create two-way binding if necessary\n\n      if (!this.binding) this.recreateTwowayBinding();else this.binding.bind();\n    }\n  }, {\n    key: \"createTwowayBinding\",\n    value: function createTwowayBinding() {\n      if ('twoway' in this ? this.twoway : this.ractive.twoway) {\n        var _Binding9 = selectBinding(this);\n\n        if (_Binding9) {\n          var binding = new _Binding9(this);\n          if (binding && binding.model) return binding;\n        }\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      if (this.attributes) this.attributes.forEach(_destroyed);\n\n      if (!this.parentFragment.delegate && this.listeners) {\n        var ls = this.listeners;\n\n        for (var k in ls) {\n          if (ls[k] && ls[k].length) this.node.removeEventListener(k, handler);\n        }\n      }\n\n      if (this.fragment) this.fragment.destroyed();\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      // if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n      if (!this.rendered) this.destroyed();\n      return detachNode(this.node);\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector, options) {\n      if (this.node && matches(this.node, selector)) return this.node;\n\n      if (this.fragment) {\n        return this.fragment.find(selector, options);\n      }\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      var result = options.result;\n\n      if (matches(this.node, selector)) {\n        result.push(this.node);\n      }\n\n      if (this.fragment) {\n        this.fragment.findAll(selector, options);\n      }\n    }\n  }, {\n    key: \"findNextNode\",\n    value: function findNextNode() {\n      return null;\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode() {\n      return this.node;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      var attribute = this.attributeByName[name];\n      return attribute ? attribute.getValue() : undefined;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      var _this$fragment;\n\n      for (var _len16 = arguments.length, assigns = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {\n        assigns[_key16] = arguments[_key16];\n      }\n\n      if (this.fragment) return (_this$fragment = this.fragment).getContext.apply(_this$fragment, assigns);\n      if (!this.ctx) this.ctx = new Context(this.parentFragment, this);\n      assigns.unshift(Object.create(this.ctx));\n      return Object.assign.apply(null, assigns);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var delegate = this.parentFragment.delegate;\n      var ref = this.listeners && this.listeners[event];\n      if (!ref) return;\n      removeFromArray(ref, callback);\n\n      if (delegate) {\n        var listeners = (delegate.listeners || (delegate.listeners = [])) && (delegate.listeners[event] || (delegate.listeners[event] = []));\n        if (listeners.refs && ! --listeners.refs) delegate.off(event, delegateHandler, true);\n      } else if (this.rendered) {\n        var _n2 = this.node;\n        var _add = _n2.addEventListener;\n        var rem = _n2.removeEventListener;\n\n        if (!ref.length) {\n          rem.call(_n2, event, handler, capture);\n        } else if (ref.length && !ref.refs && capture) {\n          rem.call(_n2, event, handler, true);\n\n          _add.call(_n2, event, handler, false);\n        }\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var delegate = this.parentFragment.delegate;\n      var ref = (this.listeners || (this.listeners = {}))[event] || (this.listeners[event] = []);\n\n      if (delegate) {\n        var listeners = (delegate.listeners || (delegate.listeners = [])) && delegate.listeners[event] || (delegate.listeners[event] = []);\n\n        if (!listeners.refs) {\n          listeners.refs = 0;\n          delegate.on(event, delegateHandler, true);\n          listeners.refs++;\n        } else {\n          listeners.refs++;\n        }\n      } else if (this.rendered) {\n        var _n3 = this.node;\n        var _add2 = _n3.addEventListener;\n        var rem = _n3.removeEventListener;\n\n        if (!ref.length) {\n          _add2.call(_n3, event, handler, capture);\n        } else if (ref.length && !ref.refs && capture) {\n          rem.call(_n3, event, handler, false);\n\n          _add2.call(_n3, event, handler, true);\n        }\n      }\n\n      addToArray(this.listeners[event], callback);\n    }\n  }, {\n    key: \"recreateTwowayBinding\",\n    value: function recreateTwowayBinding() {\n      if (this.binding) {\n        this.binding.unbind();\n        this.binding.unrender();\n      }\n\n      if (this.binding = this.createTwowayBinding()) {\n        this.binding.bind();\n        if (this.rendered) this.binding.render();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      // TODO determine correct namespace\n      this.namespace = getNamespace(this);\n      var node;\n      var existing = false;\n\n      if (occupants) {\n        var _n4;\n\n        while (_n4 = occupants.shift()) {\n          if (_n4.nodeName.toUpperCase() === this.template.e.toUpperCase() && _n4.namespaceURI === this.namespace) {\n            this.node = node = _n4;\n            existing = true;\n            break;\n          } else {\n            detachNode(_n4);\n          }\n        }\n      }\n\n      if (!existing && this.node) {\n        node = this.node;\n        target.appendChild(node);\n        existing = true;\n      }\n\n      if (!node) {\n        var _name3 = this.template.e;\n        node = createElement(this.namespace === html ? _name3.toLowerCase() : _name3, this.namespace, this.getAttribute('is'));\n        this.node = node;\n      } // tie the node to this vdom element\n\n\n      Object.defineProperty(node, '_ractive', {\n        value: {\n          proxy: this\n        },\n        configurable: true\n      });\n      if (existing && this.foundNode) this.foundNode(node); // register intro before rendering content so children can find the intro\n\n      var intro = this.intro;\n\n      if (intro && intro.shouldFire('intro')) {\n        intro.isIntro = true;\n        intro.isOutro = false;\n        runloop.registerTransition(intro);\n      }\n\n      if (this.fragment) {\n        var children = existing ? toArray(node.childNodes) : undefined;\n        this.fragment.render(node, children); // clean up leftover children\n\n        if (children) {\n          children.forEach(detachNode);\n        }\n      }\n\n      if (existing) {\n        // store initial values for two-way binding\n        if (this.binding && this.binding.wasUndefined) this.binding.setFromNode(node); // remove unused attributes\n\n        var _i31 = node.attributes.length;\n\n        while (_i31--) {\n          var _name4 = node.attributes[_i31].name;\n          if (!(_name4 in this.attributeByName)) node.removeAttribute(_name4);\n        }\n      } // Is this a top-level node of a component? If so, we may need to add\n      // a data-ractive-css attribute, for CSS encapsulation\n\n\n      if (this.parentFragment.cssIds) {\n        node.setAttribute('data-ractive-css', this.parentFragment.cssIds.map(function (x) {\n          return \"{\".concat(x, \"}\");\n        }).join(' '));\n      }\n\n      if (this.attributes) this.attributes.forEach(_render);\n      if (this.binding) this.binding.render();\n\n      if (!this.parentFragment.delegate && this.listeners) {\n        var ls = this.listeners;\n\n        for (var k in ls) {\n          if (ls[k] && ls[k].length) this.node.addEventListener(k, handler, !!ls[k].refs);\n        }\n      }\n\n      if (!existing) {\n        target.appendChild(node);\n      }\n\n      this.rendered = true;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var tagName = this.template.e;\n      var attrs = this.attributes && this.attributes.map(stringifyAttribute).join('') || ''; // Special case - selected options\n\n      if (this.name === 'option' && this.isSelected()) {\n        attrs += ' selected';\n      } // Special case - two-way radio name bindings\n\n\n      if (this.name === 'input' && inputIsCheckedRadio(this)) {\n        attrs += ' checked';\n      } // Special case style and class attributes and directives\n\n\n      var style, cls;\n      this.attributes && this.attributes.forEach(function (attr) {\n        if (attr.name === 'class') {\n          cls = (cls || '') + (cls ? ' ' : '') + safeAttributeString(attr.getString());\n        } else if (attr.name === 'style') {\n          style = (style || '') + (style ? ' ' : '') + safeAttributeString(attr.getString());\n          if (style && !endsWithSemi.test(style)) style += ';';\n        } else if (attr.style) {\n          style = (style || '') + (style ? ' ' : '') + \"\".concat(attr.style, \": \").concat(safeAttributeString(attr.getString()), \";\");\n        } else if (attr.inlineClass && attr.getValue()) {\n          cls = (cls || '') + (cls ? ' ' : '') + attr.inlineClass;\n        }\n      }); // put classes first, then inline style\n\n      if (style !== undefined) attrs = ' style' + (style ? \"=\\\"\".concat(style, \"\\\"\") : '') + attrs;\n      if (cls !== undefined) attrs = ' class' + (cls ? \"=\\\"\".concat(cls, \"\\\"\") : '') + attrs;\n\n      if (this.parentFragment.cssIds) {\n        attrs += \" data-ractive-css=\\\"\".concat(this.parentFragment.cssIds.map(function (x) {\n          return \"{\".concat(x, \"}\");\n        }).join(' '), \"\\\"\");\n      }\n\n      var str = \"<\".concat(tagName).concat(attrs, \">\");\n      if (voidElementNames.test(this.name)) return str; // Special case - textarea\n\n      if (this.name === 'textarea' && this.getAttribute('value') !== undefined) {\n        str += escapeHtml(this.getAttribute('value'));\n      } // Special case - contenteditable\n      else if (this.getAttribute('contenteditable') !== undefined) {\n          str += this.getAttribute('value') || '';\n        }\n\n      if (this.fragment) {\n        str += this.fragment.toString(!/^(?:script|style)$/i.test(this.template.e)); // escape text unless script/style\n      }\n\n      str += \"</\".concat(tagName, \">\");\n      return str;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var attrs = this.attributes;\n\n      if (attrs) {\n        attrs.unbinding = true;\n        attrs.forEach(_unbind);\n        attrs.unbinding = false;\n      }\n\n      if (this.binding) this.binding.unbind();\n      if (this.fragment) this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if (!this.rendered) return;\n      this.rendered = false; // unrendering before intro completed? complete it now\n      // TODO should be an API for aborting transitions\n\n      var transition = this.intro;\n      if (transition && transition.complete) transition.complete(); // Detach as soon as we can\n\n      if (this.name === 'option') {\n        // <option> elements detach immediately, so that\n        // their parent <select> element syncs correctly, and\n        // since option elements can't have transitions anyway\n        this.detach();\n      } else if (shouldDestroy) {\n        runloop.detachWhenReady(this);\n      } // outro transition\n\n\n      var outro = this.outro;\n\n      if (outro && outro.shouldFire('outro')) {\n        outro.isIntro = false;\n        outro.isOutro = true;\n        runloop.registerTransition(outro);\n      }\n\n      if (this.fragment) this.fragment.unrender();\n      if (this.binding) this.binding.unrender();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        this.dirty = false;\n        this.attributes && this.attributes.forEach(_update);\n        if (this.fragment) this.fragment.update();\n      }\n    }\n  }]);\n\n  return Element;\n}(ContainerItem);\n\nfunction inputIsCheckedRadio(element) {\n  var nameAttr = element.attributeByName.name;\n  return element.getAttribute('type') === 'radio' && (nameAttr || {}).interpolator && element.getAttribute('value') === nameAttr.interpolator.model.get();\n}\n\nfunction stringifyAttribute(attribute) {\n  var str = attribute.toString();\n  return str ? ' ' + str : '';\n}\n\nfunction getNamespace(element) {\n  // Use specified namespace...\n  var xmlns$$1 = element.getAttribute('xmlns');\n  if (xmlns$$1) return xmlns$$1; // ...or SVG namespace, if this is an <svg> element\n\n  if (element.name === 'svg') return svg$1;\n  var parent = element.parent;\n\n  if (parent) {\n    // ...or HTML, if the parent is a <foreignObject>\n    if (parent.name === 'foreignobject') return html; // ...or inherit from the parent node\n\n    return parent.node.namespaceURI;\n  }\n\n  return element.ractive.el.namespaceURI;\n}\n\nfunction delegateHandler(ev) {\n  var name = ev.type;\n  var end = ev.currentTarget;\n  var endEl = end._ractive && end._ractive.proxy;\n  var node = ev.target;\n  var bubble = true;\n  var listeners; // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener\n\n  while (bubble && node && node !== end) {\n    var proxy = node._ractive && node._ractive.proxy;\n\n    if (proxy && proxy.parentFragment.delegate === endEl && shouldFire(ev, node, end)) {\n      listeners = proxy.listeners && proxy.listeners[name];\n\n      if (listeners) {\n        listeners.forEach(function (l) {\n          bubble = l.call(node, ev) !== false && bubble;\n        });\n      }\n    }\n\n    node = node.parentNode;\n  }\n\n  return bubble;\n}\n\nvar UIEvent = win !== null ? win.UIEvent : null;\n\nfunction shouldFire(event, start, end) {\n  if (UIEvent && event instanceof UIEvent) {\n    var node = start;\n\n    while (node && node !== end) {\n      if (node.disabled) return false;\n      node = node.parentNode;\n    }\n  }\n\n  return true;\n}\n\nfunction handler(ev) {\n  var _this51 = this;\n\n  var el = this._ractive.proxy;\n  if (!el.listeners || !el.listeners[ev.type]) return;\n  el.listeners[ev.type].forEach(function (l) {\n    return l.call(_this51, ev);\n  });\n}\n\nvar Form =\n/*#__PURE__*/\nfunction (_Element) {\n  _inherits(Form, _Element);\n\n  function Form(options) {\n    var _this52;\n\n    _classCallCheck(this, Form);\n\n    _this52 = _possibleConstructorReturn(this, _getPrototypeOf(Form).call(this, options));\n    _this52.formBindings = [];\n    return _this52;\n  }\n\n  _createClass(Form, [{\n    key: \"render\",\n    value: function render(target, occupants) {\n      _get(_getPrototypeOf(Form.prototype), \"render\", this).call(this, target, occupants);\n\n      this.on('reset', handleReset);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      this.off('reset', handleReset);\n\n      _get(_getPrototypeOf(Form.prototype), \"unrender\", this).call(this, shouldDestroy);\n    }\n  }]);\n\n  return Form;\n}(Element);\n\nfunction handleReset() {\n  var element = this._ractive.proxy;\n  runloop.start();\n  element.formBindings.forEach(updateModel);\n  runloop.end();\n}\n\nfunction updateModel(binding) {\n  binding.model.set(binding.resetValue);\n}\n\nvar DOMEvent =\n/*#__PURE__*/\nfunction () {\n  function DOMEvent(name, owner) {\n    _classCallCheck(this, DOMEvent);\n\n    if (name.indexOf('*') !== -1) {\n      fatal(\"Only component proxy-events may contain \\\"*\\\" wildcards, <\".concat(owner.name, \" on-\").concat(name, \"=\\\"...\\\"/> is not valid\"));\n    }\n\n    this.name = name;\n    this.owner = owner;\n    this.handler = null;\n  }\n\n  _createClass(DOMEvent, [{\n    key: \"listen\",\n    value: function listen(directive) {\n      var node = this.owner.node;\n      var name = this.name; // this is probably a custom event fired from a decorator or manually\n\n      if (!(\"on\".concat(name) in node)) return;\n      this.owner.on(name, this.handler = function (event) {\n        return directive.fire({\n          node: node,\n          original: event,\n          event: event,\n          name: name\n        });\n      });\n    }\n  }, {\n    key: \"unlisten\",\n    value: function unlisten() {\n      if (this.handler) this.owner.off(this.name, this.handler);\n    }\n  }]);\n\n  return DOMEvent;\n}();\n\nvar CustomEvent =\n/*#__PURE__*/\nfunction () {\n  function CustomEvent(eventPlugin, owner, name) {\n    _classCallCheck(this, CustomEvent);\n\n    this.eventPlugin = eventPlugin;\n    this.owner = owner;\n    this.name = name;\n    this.handler = null;\n  }\n\n  _createClass(CustomEvent, [{\n    key: \"listen\",\n    value: function listen(directive) {\n      var _this53 = this;\n\n      var node = this.owner.node;\n      this.handler = this.eventPlugin(node, function () {\n        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (event.original) event.event = event.original;else event.original = event.event;\n        event.name = _this53.name;\n        event.node = event.node || node;\n        return directive.fire(event);\n      });\n    }\n  }, {\n    key: \"unlisten\",\n    value: function unlisten() {\n      this.handler.teardown();\n    }\n  }]);\n\n  return CustomEvent;\n}();\n\nvar RactiveEvent =\n/*#__PURE__*/\nfunction () {\n  function RactiveEvent(component, name) {\n    _classCallCheck(this, RactiveEvent);\n\n    this.component = component;\n    this.name = name;\n    this.handler = null;\n  }\n\n  _createClass(RactiveEvent, [{\n    key: \"listen\",\n    value: function listen(directive) {\n      var ractive = this.component.instance;\n      this.handler = ractive.on(this.name, function () {\n        for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {\n          args[_key17] = arguments[_key17];\n        }\n\n        // watch for reproxy\n        if (args[0] instanceof Context) {\n          var ctx = args.shift();\n          ctx.component = ractive;\n          directive.fire(ctx, args);\n        } else {\n          directive.fire({}, args);\n        } // cancel bubbling\n\n\n        return false;\n      });\n    }\n  }, {\n    key: \"unlisten\",\n    value: function unlisten() {\n      this.handler.cancel();\n    }\n  }]);\n\n  return RactiveEvent;\n}();\n\nvar specialPattern = /^(event|arguments|@node|@event|@context)(\\..+)?$/;\nvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\nvar EventDirective =\n/*#__PURE__*/\nfunction () {\n  function EventDirective(options) {\n    var _this54 = this;\n\n    _classCallCheck(this, EventDirective);\n\n    this.owner = options.owner || options.parentFragment.owner || findElement(options.parentFragment);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.parentFragment, true);\n    this.template = options.template;\n    this.parentFragment = options.parentFragment;\n    this.ractive = options.parentFragment.ractive; //const delegate = this.delegate = this.ractive.delegate && options.parentFragment.delegate;\n\n    this.events = [];\n\n    if (this.element.type === COMPONENT || this.element.type === ANCHOR) {\n      this.template.n.forEach(function (n) {\n        _this54.events.push(new RactiveEvent(_this54.element, n));\n      });\n    } else {\n      // make sure the delegate element has a storag object\n      //if ( delegate && !delegate.delegates ) delegate.delegates = {};\n      this.template.n.forEach(function (n) {\n        var fn = findInViewHierarchy('events', _this54.ractive, n);\n\n        if (fn) {\n          _this54.events.push(new CustomEvent(fn, _this54.element, n));\n        } else {\n          _this54.events.push(new DOMEvent(n, _this54.element));\n        }\n      });\n    } // method calls\n\n\n    this.models = null;\n  }\n\n  _createClass(EventDirective, [{\n    key: \"bind\",\n    value: function bind() {\n      addToArray(this.element.events || (this.element.events = []), this);\n      setupArgsFn(this, this.template);\n      if (!this.fn) this.action = this.template.f;\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      this.events.forEach(function (e) {\n        return e.unlisten();\n      });\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      var _this55 = this;\n\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var context = event instanceof Context && event.refire ? event : this.element.getContext(event);\n\n      if (this.fn) {\n        var values = [];\n        var models = resolveArgs(this, this.template, this.parentFragment, {\n          specialRef: function specialRef(ref) {\n            var specialMatch = specialPattern.exec(ref);\n\n            if (specialMatch) {\n              // on-click=\"foo(event.node)\"\n              return {\n                special: specialMatch[1],\n                keys: specialMatch[2] ? splitKeypath(specialMatch[2].substr(1)) : []\n              };\n            }\n\n            var dollarMatch = dollarArgsPattern.exec(ref);\n\n            if (dollarMatch) {\n              // on-click=\"foo($1)\"\n              return {\n                special: 'arguments',\n                keys: [dollarMatch[1] - 1].concat(dollarMatch[2] ? splitKeypath(dollarMatch[2].substr(1)) : [])\n              };\n            }\n          }\n        });\n\n        if (models) {\n          models.forEach(function (model) {\n            if (!model) return values.push(undefined);\n\n            if (model.special) {\n              var which = model.special;\n              var obj;\n\n              if (which === '@node') {\n                obj = _this55.element.node;\n              } else if (which === '@event') {\n                obj = event && event.event;\n              } else if (which === 'event') {\n                warnOnceIfDebug(\"The event reference available to event directives is deprecated and should be replaced with @context and @event\");\n                obj = context;\n              } else if (which === '@context') {\n                obj = context;\n              } else {\n                obj = args;\n              }\n\n              var keys = model.keys.slice();\n\n              while (obj && keys.length) {\n                obj = obj[keys.shift()];\n              }\n\n              return values.push(obj);\n            }\n\n            if (model.wrapper) {\n              return values.push(model.wrapperValue);\n            }\n\n            values.push(model.get());\n          });\n        } // make event available as `this.event`\n\n\n        var ractive = this.ractive;\n        var oldEvent = ractive.event;\n        ractive.event = context;\n        var returned = this.fn.apply(ractive, values);\n        var result = returned.pop(); // Auto prevent and stop if return is explicitly false\n\n        if (result === false) {\n          var original = event ? event.original : undefined;\n\n          if (original) {\n            original.preventDefault && original.preventDefault();\n            original.stopPropagation && original.stopPropagation();\n          } else {\n            warnOnceIfDebug(\"handler '\".concat(this.template.n.join(' '), \"' returned false, but there is no event available to cancel\"));\n          }\n        } // watch for proxy events\n        else if (!returned.length && Array.isArray(result) && typeof result[0] === 'string') {\n            result = fireEvent(this.ractive, result.shift(), context, result);\n          }\n\n        ractive.event = oldEvent;\n        return result;\n      } else {\n        return fireEvent(this.ractive, this.action, context, args);\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {}\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this56 = this;\n\n      // render events after everything else, so they fire after bindings\n      runloop.scheduleTask(function () {\n        return _this56.events.forEach(function (e) {\n          return e.listen(_this56);\n        });\n      }, true);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '';\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      removeFromArray(this.element.events, this);\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      this.events.forEach(function (e) {\n        return e.unlisten();\n      });\n    }\n  }]);\n\n  return EventDirective;\n}();\n\nEventDirective.prototype.update = noop;\n\nfunction progressiveText(item, target, occupants, text) {\n  if (occupants) {\n    var _n5 = occupants[0];\n\n    if (_n5 && _n5.nodeType === 3) {\n      var idx = _n5.nodeValue.indexOf(text);\n\n      occupants.shift();\n\n      if (idx === 0) {\n        if (_n5.nodeValue.length !== text.length) {\n          occupants.unshift(_n5.splitText(text.length));\n        }\n      } else {\n        _n5.nodeValue = text;\n      }\n    } else {\n      _n5 = item.node = doc.createTextNode(text);\n\n      if (occupants[0]) {\n        target.insertBefore(_n5, occupants[0]);\n      } else {\n        target.appendChild(_n5);\n      }\n    }\n\n    item.node = _n5;\n  } else {\n    if (!item.node) item.node = doc.createTextNode(text);\n    target.appendChild(item.node);\n  }\n}\n\nvar Mustache =\n/*#__PURE__*/\nfunction (_Item7) {\n  _inherits(Mustache, _Item7);\n\n  function Mustache(options) {\n    var _this57;\n\n    _classCallCheck(this, Mustache);\n\n    _this57 = _possibleConstructorReturn(this, _getPrototypeOf(Mustache).call(this, options));\n    _this57.parentFragment = options.parentFragment;\n    _this57.template = options.template;\n    _this57.index = options.index;\n    if (options.owner) _this57.parent = options.owner;\n    _this57.isStatic = !!options.template.s;\n    _this57.model = null;\n    _this57.dirty = false;\n    return _this57;\n  }\n\n  _createClass(Mustache, [{\n    key: \"bind\",\n    value: function bind() {\n      // yield mustaches should resolve in container context\n      var start = this.containerFragment || this.parentFragment; // try to find a model for this view\n\n      var model = resolve(start, this.template);\n\n      if (model) {\n        var _value11 = model.get();\n\n        if (this.isStatic) {\n          this.model = {\n            get: function get() {\n              return _value11;\n            }\n          };\n          return;\n        }\n\n        model.register(this);\n        this.model = model;\n      }\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      this.bubble();\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous, safe) {\n      next = rebindMatch(this.template, next, previous, this.parentFragment);\n      if (next === this.model) return false;\n\n      if (this.model) {\n        this.model.unregister(this);\n      }\n\n      if (next) next.addShuffleRegister(this, 'mark');\n      this.model = next;\n      if (!safe) this.handleChange();\n      return true;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (!this.isStatic) {\n        this.model && this.model.unregister(this);\n        this.model = undefined;\n      }\n    }\n  }]);\n\n  return Mustache;\n}(Item);\n\nvar MustacheContainer =\n/*#__PURE__*/\nfunction (_ContainerItem3) {\n  _inherits(MustacheContainer, _ContainerItem3);\n\n  function MustacheContainer(options) {\n    _classCallCheck(this, MustacheContainer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MustacheContainer).call(this, options));\n  }\n\n  return MustacheContainer;\n}(ContainerItem);\n\nvar proto$3 = MustacheContainer.prototype;\nvar mustache = Mustache.prototype;\nproto$3.bind = mustache.bind;\nproto$3.handleChange = mustache.handleChange;\nproto$3.rebind = mustache.rebind;\nproto$3.unbind = mustache.unbind;\n\nvar Interpolator =\n/*#__PURE__*/\nfunction (_Mustache) {\n  _inherits(Interpolator, _Mustache);\n\n  function Interpolator() {\n    _classCallCheck(this, Interpolator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Interpolator).apply(this, arguments));\n  }\n\n  _createClass(Interpolator, [{\n    key: \"bubble\",\n    value: function bubble() {\n      if (this.owner) this.owner.bubble();\n\n      _get(_getPrototypeOf(Interpolator.prototype), \"bubble\", this).call(this);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      return detachNode(this.node);\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode() {\n      return this.node;\n    }\n  }, {\n    key: \"getString\",\n    value: function getString() {\n      return this.model ? safeToStringValue(this.model.get()) : '';\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      if (inAttributes()) return;\n      var value = this.getString();\n      this.rendered = true;\n      progressiveText(this, target, occupants, value);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(escape) {\n      var string = this.getString();\n      return escape ? escapeHtml(string) : string;\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if (shouldDestroy) this.detach();\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        this.dirty = false;\n\n        if (this.rendered) {\n          this.node.data = this.getString();\n        }\n      }\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.model ? this.model.get() : undefined;\n    }\n  }]);\n\n  return Interpolator;\n}(Mustache);\n\nvar Input =\n/*#__PURE__*/\nfunction (_Element2) {\n  _inherits(Input, _Element2);\n\n  function Input() {\n    _classCallCheck(this, Input);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Input).apply(this, arguments));\n  }\n\n  _createClass(Input, [{\n    key: \"render\",\n    value: function render(target, occupants) {\n      _get(_getPrototypeOf(Input.prototype), \"render\", this).call(this, target, occupants);\n\n      this.node.defaultValue = this.node.value;\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(value, attrValue) {\n      var comparator = this.getAttribute('value-comparator');\n\n      if (comparator) {\n        if (typeof comparator === 'function') {\n          return comparator(value, attrValue);\n        }\n\n        if (value && attrValue) {\n          return value[comparator] == attrValue[comparator];\n        }\n      }\n\n      return value == attrValue;\n    }\n  }]);\n\n  return Input;\n}(Element); // simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\n\nvar specials$1 = {\n  \"true\": true,\n  \"false\": false,\n  \"null\": null,\n  undefined: undefined\n};\nvar specialsPattern = new RegExp('^(?:' + Object.keys(specials$1).join('|') + ')');\nvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\nvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nvar onlyWhitespace$1 = /^\\s*$/;\nvar JsonParser = Parser.extend({\n  init: function init(str, options) {\n    this.values = options.values;\n    this.allowWhitespace();\n  },\n  postProcess: function postProcess(result) {\n    if (result.length !== 1 || !onlyWhitespace$1.test(this.leftover)) {\n      return null;\n    }\n\n    return {\n      value: result[0].v\n    };\n  },\n  converters: [function getPlaceholder(parser) {\n    if (!parser.values) return null;\n    var placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n    if (placeholder && parser.values.hasOwnProperty(placeholder)) {\n      return {\n        v: parser.values[placeholder]\n      };\n    }\n  }, function getSpecial(parser) {\n    var special = parser.matchPattern(specialsPattern);\n    if (special) return {\n      v: specials$1[special]\n    };\n  }, function getNumber(parser) {\n    var number = parser.matchPattern(numberPattern$1);\n    if (number) return {\n      v: +number\n    };\n  }, function getString(parser) {\n    var stringLiteral = readStringLiteral(parser);\n    var values = parser.values;\n\n    if (stringLiteral && values) {\n      return {\n        v: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n          return $1 in values ? values[$1] : $1;\n        })\n      };\n    }\n\n    return stringLiteral;\n  }, function getObject(parser) {\n    if (!parser.matchString('{')) return null;\n    var result = {};\n    parser.allowWhitespace();\n\n    if (parser.matchString('}')) {\n      return {\n        v: result\n      };\n    }\n\n    var pair;\n\n    while (pair = getKeyValuePair(parser)) {\n      result[pair.key] = pair.value;\n      parser.allowWhitespace();\n\n      if (parser.matchString('}')) {\n        return {\n          v: result\n        };\n      }\n\n      if (!parser.matchString(',')) {\n        return null;\n      }\n    }\n\n    return null;\n  }, function getArray(parser) {\n    if (!parser.matchString('[')) return null;\n    var result = [];\n    parser.allowWhitespace();\n\n    if (parser.matchString(']')) {\n      return {\n        v: result\n      };\n    }\n\n    var valueToken;\n\n    while (valueToken = parser.read()) {\n      result.push(valueToken.v);\n      parser.allowWhitespace();\n\n      if (parser.matchString(']')) {\n        return {\n          v: result\n        };\n      }\n\n      if (!parser.matchString(',')) {\n        return null;\n      }\n\n      parser.allowWhitespace();\n    }\n\n    return null;\n  }]\n});\n\nfunction getKeyValuePair(parser) {\n  parser.allowWhitespace();\n  var key = readKey(parser);\n  if (!key) return null;\n  var pair = {\n    key: key\n  };\n  parser.allowWhitespace();\n\n  if (!parser.matchString(':')) {\n    return null;\n  }\n\n  parser.allowWhitespace();\n  var valueToken = parser.read();\n  if (!valueToken) return null;\n  pair.value = valueToken.v;\n  return pair;\n}\n\nvar parseJSON = function parseJSON(str, values) {\n  var parser = new JsonParser(str, {\n    values: values\n  });\n  return parser.result;\n};\n\nvar Mapping =\n/*#__PURE__*/\nfunction (_Item8) {\n  _inherits(Mapping, _Item8);\n\n  function Mapping(options) {\n    var _this58;\n\n    _classCallCheck(this, Mapping);\n\n    _this58 = _possibleConstructorReturn(this, _getPrototypeOf(Mapping).call(this, options));\n    _this58.name = options.template.n;\n    _this58.owner = options.owner || options.parentFragment.owner || options.element || findElement(options.parentFragment);\n    _this58.element = options.element || (_this58.owner.attributeByName ? _this58.owner : findElement(options.parentFragment));\n    _this58.parentFragment = _this58.element.parentFragment; // shared\n\n    _this58.ractive = _this58.parentFragment.ractive;\n    _this58.element.attributeByName[_this58.name] = _assertThisInitialized(_this58);\n    _this58.value = options.template.f;\n    return _this58;\n  }\n\n  _createClass(Mapping, [{\n    key: \"bind\",\n    value: function bind() {\n      var template = this.template.f;\n      var viewmodel = this.element.instance.viewmodel;\n\n      if (template === 0) {\n        // empty attributes are `true`\n        viewmodel.joinKey(this.name).set(true);\n      } else if (typeof template === 'string') {\n        var parsed = parseJSON(template);\n        viewmodel.joinKey(this.name).set(parsed ? parsed.value : template);\n      } else if (Array.isArray(template)) {\n        createMapping(this, true);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {}\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (this.model) this.model.unregister(this);\n      if (this.boundFragment) this.boundFragment.unbind();\n\n      if (this.element.bound) {\n        if (this.link.target === this.model) this.link.owner.unlink();\n      }\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {}\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        this.dirty = false;\n        if (this.boundFragment) this.boundFragment.update();\n      }\n    }\n  }]);\n\n  return Mapping;\n}(Item);\n\nfunction createMapping(item) {\n  var template = item.template.f;\n  var viewmodel = item.element.instance.viewmodel;\n  var childData = viewmodel.value;\n\n  if (template.length === 1 && template[0].t === INTERPOLATOR) {\n    var model = resolve(item.parentFragment, template[0]);\n\n    var _val = model.get(false); // if the interpolator is not static\n\n\n    if (!template[0].s) {\n      item.model = model;\n      item.link = viewmodel.createLink(item.name, model, template[0].r, {\n        mapping: true\n      }); // initialize parent side of the mapping from child data\n\n      if (_val === undefined && !model.isReadonly && item.name in childData) {\n        model.set(childData[item.name]);\n      }\n    } // copy non-object, non-computed vals through\n    else if (_typeof(_val) !== 'object' || template[0].x) {\n        viewmodel.joinKey(splitKeypath(item.name)).set(_val);\n      } // warn about trying to copy an object\n      else {\n          warnIfDebug(\"Cannot copy non-computed object value from static mapping '\".concat(item.name, \"'\"));\n        }\n  } else {\n    item.boundFragment = new Fragment({\n      owner: item,\n      template: template\n    }).bind();\n    item.model = viewmodel.joinKey(splitKeypath(item.name));\n    item.model.set(item.boundFragment.valueOf()); // item is a *bit* of a hack\n\n    item.boundFragment.bubble = function () {\n      Fragment.prototype.bubble.call(item.boundFragment); // defer this to avoid mucking around model deps if there happens to be an expression involved\n\n      runloop.scheduleTask(function () {\n        item.boundFragment.update();\n        item.model.set(item.boundFragment.valueOf());\n      });\n    };\n  }\n}\n\nvar Option =\n/*#__PURE__*/\nfunction (_Element3) {\n  _inherits(Option, _Element3);\n\n  function Option(options) {\n    var _this59;\n\n    _classCallCheck(this, Option);\n\n    var template = options.template;\n    if (!template.a) template.a = {}; // If the value attribute is missing, use the element's content,\n    // as long as it isn't disabled\n\n    if (template.a.value === undefined && !('disabled' in template.a)) {\n      template.a.value = template.f || '';\n    }\n\n    _this59 = _possibleConstructorReturn(this, _getPrototypeOf(Option).call(this, options));\n    _this59.select = findElement(_this59.parent || _this59.parentFragment, false, 'select');\n    return _this59;\n  }\n\n  _createClass(Option, [{\n    key: \"bind\",\n    value: function bind() {\n      if (!this.select) {\n        _get(_getPrototypeOf(Option.prototype), \"bind\", this).call(this);\n\n        return;\n      } // If the select has a value, it overrides the `selected` attribute on\n      // this option - so we delete the attribute\n\n\n      var selectedAttribute = this.attributeByName.selected;\n\n      if (selectedAttribute && this.select.getAttribute('value') !== undefined) {\n        var index = this.attributes.indexOf(selectedAttribute);\n        this.attributes.splice(index, 1);\n        delete this.attributeByName.selected;\n      }\n\n      _get(_getPrototypeOf(Option.prototype), \"bind\", this).call(this);\n\n      this.select.options.push(this);\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      // if we're using content as value, may need to update here\n      var value = this.getAttribute('value');\n\n      if (this.node && this.node.value !== value) {\n        this.node._ractive.value = value;\n      }\n\n      _get(_getPrototypeOf(Option.prototype), \"bubble\", this).call(this);\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      var attribute = this.attributeByName[name];\n      return attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;\n    }\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      var optionValue = this.getAttribute('value');\n\n      if (optionValue === undefined || !this.select) {\n        return false;\n      }\n\n      var selectValue = this.select.getAttribute('value');\n\n      if (this.select.compare(selectValue, optionValue)) {\n        return true;\n      }\n\n      if (this.select.getAttribute('multiple') && Array.isArray(selectValue)) {\n        var _i32 = selectValue.length;\n\n        while (_i32--) {\n          if (this.select.compare(selectValue[_i32], optionValue)) {\n            return true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      _get(_getPrototypeOf(Option.prototype), \"render\", this).call(this, target, occupants);\n\n      if (!this.attributeByName.value) {\n        this.node._ractive.value = this.getAttribute('value');\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      _get(_getPrototypeOf(Option.prototype), \"unbind\", this).call(this);\n\n      if (this.select) {\n        removeFromArray(this.select.options, this);\n      }\n    }\n  }]);\n\n  return Option;\n}(Element);\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction getPartialTemplate(ractive, name, parentFragment) {\n  // If the partial in instance or view heirarchy instances, great\n  var partial = getPartialFromRegistry(ractive, name, parentFragment || {});\n  if (partial) return partial; // Does it exist on the page as a script tag?\n\n  partial = parser.fromId(name, {\n    noThrow: true\n  });\n\n  if (partial) {\n    // parse and register to this ractive instance\n    var parsed = parser.parseFor(partial, ractive); // register extra partials on the ractive instance if they don't already exist\n\n    if (parsed.p) fillGaps(ractive.partials, parsed.p); // register (and return main partial if there are others in the template)\n\n    return ractive.partials[name] = parsed.t;\n  }\n}\n\nfunction getPartialFromRegistry(ractive, name, parentFragment) {\n  // if there was an instance up-hierarchy, cool\n  var partial = findParentPartial(name, parentFragment.owner);\n  if (partial) return partial; // find first instance in the ractive or view hierarchy that has this partial\n\n  var instance = findInstance('partials', ractive, name);\n\n  if (!instance) {\n    return;\n  }\n\n  partial = instance.partials[name]; // partial is a function?\n\n  var fn;\n\n  if (typeof partial === 'function') {\n    fn = partial.bind(instance);\n    fn.isOwner = instance.partials.hasOwnProperty(name);\n    partial = fn.call(ractive, parser);\n  }\n\n  if (!partial && partial !== '') {\n    warnIfDebug(noRegistryFunctionReturn, name, 'partial', 'partial', {\n      ractive: ractive\n    });\n    return;\n  } // If this was added manually to the registry,\n  // but hasn't been parsed, parse it now\n\n\n  if (!parser.isParsed(partial)) {\n    // use the parseOptions of the ractive instance on which it was found\n    var parsed = parser.parseFor(partial, instance); // Partials cannot contain nested partials!\n    // TODO add a test for this\n\n    if (parsed.p) {\n      warnIfDebug('Partials ({{>%s}}) cannot contain nested inline partials', name, {\n        ractive: ractive\n      });\n    } // if fn, use instance to store result, otherwise needs to go\n    // in the correct point in prototype chain on instance or constructor\n\n\n    var target = fn ? instance : findOwner(instance, name); // may be a template with partials, which need to be registered and main template extracted\n\n    target.partials[name] = partial = parsed.t;\n  } // store for reset\n\n\n  if (fn) partial._fn = fn;\n  return partial.v ? partial.t : partial;\n}\n\nfunction findOwner(ractive, key) {\n  return ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n}\n\nfunction findConstructor(constructor, key) {\n  if (!constructor) {\n    return;\n  }\n\n  return constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor.Parent, key);\n}\n\nfunction findParentPartial(name, parent) {\n  if (parent) {\n    if (parent.template && parent.template.p && !Array.isArray(parent.template.p) && hasOwn.call(parent.template.p, name)) {\n      return parent.template.p[name];\n    } else if (parent.parentFragment && parent.parentFragment.owner) {\n      return findParentPartial(name, parent.parentFragment.owner);\n    }\n  }\n}\n\nvar Partial =\n/*#__PURE__*/\nfunction (_MustacheContainer) {\n  _inherits(Partial, _MustacheContainer);\n\n  function Partial(options) {\n    var _this60;\n\n    _classCallCheck(this, Partial);\n\n    _this60 = _possibleConstructorReturn(this, _getPrototypeOf(Partial).call(this, options));\n    _this60.options = options;\n    _this60.yielder = options.template.t === YIELDER;\n    return _this60;\n  }\n\n  _createClass(Partial, [{\n    key: \"bind\",\n    value: function bind() {\n      var options = this.options;\n\n      if (this.yielder) {\n        this.container = options.parentFragment.ractive;\n        this.component = this.container.component;\n\n        if (this.component) {\n          this.containerFragment = options.parentFragment;\n          this.parentFragment = this.component.parentFragment; // {{yield}} is equivalent to {{yield content}}\n\n          if (!options.template.r && !options.template.rx && !options.template.x) options.template.r = 'content';\n        } else {\n          // this is a plain-ish instance that may be anchored at a later date\n          this.fragment = new Fragment({\n            template: [],\n            owner: this,\n            parentFragment: options.parentFragment,\n            ractive: options.parentFragment.ractive\n          });\n          this.containerFragment = options.parentFragment;\n          this.parentFragment = options.parentFragment;\n          this.fragment.bind();\n          return;\n        }\n      } // keep track of the reference name for future resets\n\n\n      this.refName = this.template.r; // name matches take priority over expressions\n\n      var template = this.refName ? getPartialTemplate(this.ractive, this.refName, this.parentFragment) || null : null;\n      var templateObj;\n\n      if (template) {\n        this.named = true;\n        this.setTemplate(this.template.r, template);\n      }\n\n      if (!template) {\n        _get(_getPrototypeOf(Partial.prototype), \"bind\", this).call(this);\n\n        if ((templateObj = this.model.get()) && _typeof(templateObj) === 'object' && (typeof templateObj.template === 'string' || Array.isArray(templateObj.t))) {\n          if (templateObj.template) {\n            this.source = templateObj.template;\n            templateObj = parsePartial(this.template.r, templateObj.template, this.ractive);\n          } else {\n            this.source = templateObj.t;\n          }\n\n          this.setTemplate(this.template.r, templateObj.t);\n        } else if (typeof this.model.get() !== 'string' && this.refName) {\n          this.setTemplate(this.refName, template);\n        } else {\n          this.setTemplate(this.model.get());\n        }\n      }\n\n      options = {\n        owner: this,\n        template: this.partialTemplate\n      };\n\n      if (this.template.c) {\n        options.template = [{\n          t: SECTION,\n          n: SECTION_WITH,\n          f: options.template\n        }];\n\n        for (var k in this.template.c) {\n          options.template[0][k] = this.template.c[k];\n        }\n      }\n\n      if (this.yielder) {\n        options.ractive = this.container.parent;\n      }\n\n      this.fragment = new Fragment(options);\n\n      if (this.template.z) {\n        this.fragment.aliases = resolveAliases(this.template.z, this.yielder ? this.containerFragment : this.parentFragment);\n      }\n\n      this.fragment.bind();\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      if (this.yielder && !this.dirty) {\n        this.containerFragment.bubble();\n        this.dirty = true;\n      } else {\n        _get(_getPrototypeOf(Partial.prototype), \"bubble\", this).call(this);\n      }\n    }\n  }, {\n    key: \"findNextNode\",\n    value: function findNextNode() {\n      return this.yielder ? this.containerFragment.findNextNode(this) : _get(_getPrototypeOf(Partial.prototype), \"findNextNode\", this).call(this);\n    }\n  }, {\n    key: \"forceResetTemplate\",\n    value: function forceResetTemplate() {\n      var _this61 = this;\n\n      this.partialTemplate = undefined; // on reset, check for the reference name first\n\n      if (this.refName) {\n        this.partialTemplate = getPartialTemplate(this.ractive, this.refName, this.parentFragment);\n      } // then look for the resolved name\n\n\n      if (!this.partialTemplate) {\n        this.partialTemplate = getPartialTemplate(this.ractive, this.name, this.parentFragment);\n      }\n\n      if (!this.partialTemplate) {\n        warnOnceIfDebug(\"Could not find template for partial '\".concat(this.name, \"'\"));\n        this.partialTemplate = [];\n      }\n\n      if (this.inAttribute) {\n        doInAttributes(function () {\n          return _this61.fragment.resetTemplate(_this61.partialTemplate);\n        });\n      } else {\n        this.fragment.resetTemplate(this.partialTemplate);\n      }\n\n      this.bubble();\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      return this.fragment.render(target, occupants);\n    }\n  }, {\n    key: \"setTemplate\",\n    value: function setTemplate(name, template) {\n      this.name = name;\n      if (!template && template !== null) template = getPartialTemplate(this.ractive, name, this.parentFragment);\n\n      if (!template) {\n        warnOnceIfDebug(\"Could not find template for partial '\".concat(name, \"'\"));\n      }\n\n      this.partialTemplate = template || [];\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      _get(_getPrototypeOf(Partial.prototype), \"unbind\", this).call(this);\n\n      this.fragment.aliases = {};\n      this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      this.fragment.unrender(shouldDestroy);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var template;\n\n      if (this.dirty) {\n        this.dirty = false;\n\n        if (!this.named) {\n          if (this.model) {\n            template = this.model.get();\n          }\n\n          if (template && typeof template === 'string' && template !== this.name) {\n            this.setTemplate(template);\n            this.fragment.resetTemplate(this.partialTemplate);\n          } else if (template && _typeof(template) === 'object' && (typeof template.template === 'string' || Array.isArray(template.t))) {\n            if (template.t !== this.source && template.template !== this.source) {\n              if (template.template) {\n                this.source = template.template;\n                template = parsePartial(this.name, template.template, this.ractive);\n              } else {\n                this.source = template.t;\n              }\n\n              this.setTemplate(this.name, template.t);\n              this.fragment.resetTemplate(this.partialTemplate);\n            }\n          }\n        }\n\n        this.fragment.update();\n      }\n    }\n  }]);\n\n  return Partial;\n}(MustacheContainer);\n\nfunction parsePartial(name, partial, ractive) {\n  var parsed;\n\n  try {\n    parsed = parser.parse(partial, parser.getParseOptions(ractive));\n  } catch (e) {\n    warnIfDebug(\"Could not parse partial from expression '\".concat(name, \"'\\n\").concat(e.message));\n  }\n\n  return parsed || {\n    t: []\n  };\n}\n\nvar RepeatedFragment =\n/*#__PURE__*/\nfunction () {\n  function RepeatedFragment(options) {\n    _classCallCheck(this, RepeatedFragment);\n\n    this.parent = options.owner.parentFragment; // bit of a hack, so reference resolution works without another\n    // layer of indirection\n\n    this.parentFragment = this;\n    this.owner = options.owner;\n    this.ractive = this.parent.ractive;\n    this.delegate = this.ractive.delegate !== false && (this.parent.delegate || findDelegate(findElement(options.owner))); // delegation disabled by directive\n\n    if (this.delegate && this.delegate.delegate === false) this.delegate = false; // let the element know it's a delegate handler\n\n    if (this.delegate) this.delegate.delegate = this.delegate; // encapsulated styles should be inherited until they get applied by an element\n\n    this.cssIds = 'cssIds' in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n    this.context = null;\n    this.rendered = false;\n    this.iterations = [];\n    this.template = options.template;\n    this.indexRef = options.indexRef;\n    this.keyRef = options.keyRef;\n    this.pendingNewIndices = null;\n    this.previousIterations = null; // track array versus object so updates of type rest\n\n    this.isArray = false;\n  }\n\n  _createClass(RepeatedFragment, [{\n    key: \"bind\",\n    value: function bind(context) {\n      var _this62 = this;\n\n      this.context = context;\n      this.bound = true;\n      var value = context.get(); // {{#each array}}...\n\n      if (this.isArray = Array.isArray(value)) {\n        // we can't use map, because of sparse arrays\n        this.iterations = [];\n        var max = value.length;\n\n        for (var _i33 = 0; _i33 < max; _i33 += 1) {\n          this.iterations[_i33] = this.createIteration(_i33, _i33);\n        }\n      } // {{#each object}}...\n      else if (isObject(value)) {\n          this.isArray = false; // TODO this is a dreadful hack. There must be a neater way\n\n          if (this.indexRef) {\n            var refs = this.indexRef.split(',');\n            this.keyRef = refs[0];\n            this.indexRef = refs[1];\n          }\n\n          this.iterations = Object.keys(value).map(function (key, index) {\n            return _this62.createIteration(key, index);\n          });\n        }\n\n      return this;\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble(index) {\n      if (!this.bubbled) this.bubbled = [];\n      this.bubbled.push(index);\n      this.owner.bubble();\n    }\n  }, {\n    key: \"createIteration\",\n    value: function createIteration(key, index) {\n      var fragment = new Fragment({\n        owner: this,\n        template: this.template\n      });\n      fragment.key = key;\n      fragment.index = index;\n      fragment.isIteration = true;\n      fragment.delegate = this.delegate;\n      var model = this.context.joinKey(key); // set up an iteration alias if there is one\n\n      if (this.owner.template.z) {\n        fragment.aliases = {};\n        fragment.aliases[this.owner.template.z[0].n] = model;\n      }\n\n      return fragment.bind(model);\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      this.iterations.forEach(_destroyed);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var docFrag = createDocumentFragment();\n      this.iterations.forEach(function (fragment) {\n        return docFrag.appendChild(fragment.detach());\n      });\n      return docFrag;\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector, options) {\n      return findMap(this.iterations, function (i) {\n        return i.find(selector, options);\n      });\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      return this.iterations.forEach(function (i) {\n        return i.findAll(selector, options);\n      });\n    }\n  }, {\n    key: \"findAllComponents\",\n    value: function findAllComponents(name, options) {\n      return this.iterations.forEach(function (i) {\n        return i.findAllComponents(name, options);\n      });\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent(name, options) {\n      return findMap(this.iterations, function (i) {\n        return i.findComponent(name, options);\n      });\n    }\n  }, {\n    key: \"findContext\",\n    value: function findContext() {\n      return this.context;\n    }\n  }, {\n    key: \"findNextNode\",\n    value: function findNextNode(iteration) {\n      if (iteration.index < this.iterations.length - 1) {\n        for (var _i34 = iteration.index + 1; _i34 < this.iterations.length; _i34++) {\n          var node = this.iterations[_i34].firstNode(true);\n\n          if (node) return node;\n        }\n      }\n\n      return this.owner.findNextNode();\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode(skipParent) {\n      return this.iterations[0] ? this.iterations[0].firstNode(skipParent) : null;\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next) {\n      var _this63 = this;\n\n      this.context = next;\n      this.iterations.forEach(function (fragment) {\n        var model = next ? next.joinKey(fragment.key) : undefined;\n        fragment.context = model;\n\n        if (_this63.owner.template.z) {\n          fragment.aliases = {};\n          fragment.aliases[_this63.owner.template.z[0].n] = model;\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      // TODO use docFrag.cloneNode...\n      var xs = this.iterations;\n\n      if (xs) {\n        var _len18 = xs.length;\n\n        for (var _i35 = 0; _i35 < _len18; _i35++) {\n          xs[_i35].render(target, occupants);\n        }\n      }\n\n      this.rendered = true;\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices) {\n      var _this64 = this;\n\n      if (!this.pendingNewIndices) this.previousIterations = this.iterations.slice();\n      if (!this.pendingNewIndices) this.pendingNewIndices = [];\n      this.pendingNewIndices.push(newIndices);\n      var iterations = [];\n      newIndices.forEach(function (newIndex, oldIndex) {\n        if (newIndex === -1) return;\n        var fragment = _this64.iterations[oldIndex];\n        iterations[newIndex] = fragment;\n        if (newIndex !== oldIndex && fragment) fragment.dirty = true;\n      });\n      this.iterations = iterations;\n      this.bubble();\n    }\n  }, {\n    key: \"shuffled\",\n    value: function shuffled() {\n      this.iterations.forEach(_shuffled);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(escape) {\n      return this.iterations ? this.iterations.map(escape ? toEscapedString : toString$1).join('') : '';\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.bound = false;\n      this.iterations.forEach(_unbind);\n      return this;\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      this.iterations.forEach(shouldDestroy ? unrenderAndDestroy : _unrender);\n\n      if (this.pendingNewIndices && this.previousIterations) {\n        this.previousIterations.forEach(function (fragment) {\n          if (fragment.rendered) shouldDestroy ? unrenderAndDestroy(fragment) : _unrender(fragment);\n        });\n      }\n\n      this.rendered = false;\n    } // TODO smart update\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this65 = this;\n\n      // skip dirty check, since this is basically just a facade\n      if (this.pendingNewIndices) {\n        this.bubbled.length = 0;\n        this.updatePostShuffle();\n        return;\n      }\n\n      if (this.updating) return;\n      this.updating = true;\n      var value = this.context.get();\n      var wasArray = this.isArray;\n      var toRemove;\n      var oldKeys;\n      var reset = true;\n      var i;\n\n      if (this.isArray = Array.isArray(value)) {\n        if (wasArray) {\n          reset = false;\n\n          if (this.iterations.length > value.length) {\n            toRemove = this.iterations.splice(value.length);\n          }\n        }\n      } else if (isObject(value) && !wasArray) {\n        reset = false;\n        toRemove = [];\n        oldKeys = {};\n        i = this.iterations.length;\n\n        while (i--) {\n          var _fragment = this.iterations[i];\n\n          if (_fragment.key in value) {\n            oldKeys[_fragment.key] = true;\n          } else {\n            this.iterations.splice(i, 1);\n            toRemove.push(_fragment);\n          }\n        }\n      }\n\n      if (reset) {\n        toRemove = this.iterations;\n        this.iterations = [];\n      }\n\n      if (toRemove) {\n        toRemove.forEach(function (fragment) {\n          fragment.unbind();\n          fragment.unrender(true);\n        });\n      } // update the remaining ones\n\n\n      if (!reset && this.isArray && this.bubbled && this.bubbled.length) {\n        var bubbled = this.bubbled;\n        this.bubbled = [];\n        bubbled.forEach(function (i) {\n          return _this65.iterations[i] && _this65.iterations[i].update();\n        });\n      } else {\n        this.iterations.forEach(_update);\n      } // add new iterations\n\n\n      var newLength = Array.isArray(value) ? value.length : isObject(value) ? Object.keys(value).length : 0;\n      var docFrag;\n      var fragment;\n\n      if (newLength > this.iterations.length) {\n        docFrag = this.rendered ? createDocumentFragment() : null;\n        i = this.iterations.length;\n\n        if (Array.isArray(value)) {\n          while (i < value.length) {\n            fragment = this.createIteration(i, i);\n            this.iterations.push(fragment);\n            if (this.rendered) fragment.render(docFrag);\n            i += 1;\n          }\n        } else if (isObject(value)) {\n          // TODO this is a dreadful hack. There must be a neater way\n          if (this.indexRef && !this.keyRef) {\n            var refs = this.indexRef.split(',');\n            this.keyRef = refs[0];\n            this.indexRef = refs[1];\n          }\n\n          Object.keys(value).forEach(function (key) {\n            if (!oldKeys || !(key in oldKeys)) {\n              fragment = _this65.createIteration(key, i);\n\n              _this65.iterations.push(fragment);\n\n              if (_this65.rendered) fragment.render(docFrag);\n              i += 1;\n            }\n          });\n        }\n\n        if (this.rendered) {\n          var parentNode = this.parent.findParentNode();\n          var anchor = this.parent.findNextNode(this.owner);\n          parentNode.insertBefore(docFrag, anchor);\n        }\n      }\n\n      this.updating = false;\n    }\n  }, {\n    key: \"updatePostShuffle\",\n    value: function updatePostShuffle() {\n      var _this66 = this;\n\n      var newIndices = this.pendingNewIndices[0]; // map first shuffle through\n\n      this.pendingNewIndices.slice(1).forEach(function (indices) {\n        newIndices.forEach(function (newIndex, oldIndex) {\n          newIndices[oldIndex] = indices[newIndex];\n        });\n      }); // This algorithm (for detaching incorrectly-ordered fragments from the DOM and\n      // storing them in a document fragment for later reinsertion) seems a bit hokey,\n      // but it seems to work for now\n\n      var len = this.context.get().length;\n      var oldLen = this.previousIterations.length;\n      var removed = {};\n      var i;\n      newIndices.forEach(function (newIndex, oldIndex) {\n        var fragment = _this66.previousIterations[oldIndex];\n        _this66.previousIterations[oldIndex] = null;\n\n        if (newIndex === -1) {\n          removed[oldIndex] = fragment;\n        } else if (fragment.index !== newIndex) {\n          var model = _this66.context.joinKey(newIndex);\n\n          fragment.index = fragment.key = newIndex;\n          fragment.context = model;\n\n          if (_this66.owner.template.z) {\n            fragment.aliases = {};\n            fragment.aliases[_this66.owner.template.z[0].n] = model;\n          }\n        }\n      }); // if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices\n\n      this.previousIterations.forEach(function (frag, i) {\n        if (frag) removed[i] = frag;\n      }); // create new/move existing iterations\n\n      var docFrag = this.rendered ? createDocumentFragment() : null;\n      var parentNode = this.rendered ? this.parent.findParentNode() : null;\n      var contiguous = 'startIndex' in newIndices;\n      i = contiguous ? newIndices.startIndex : 0;\n\n      for (i; i < len; i++) {\n        var frag = this.iterations[i];\n\n        if (frag && contiguous) {\n          // attach any built-up iterations\n          if (this.rendered) {\n            if (removed[i]) docFrag.appendChild(removed[i].detach());\n            if (docFrag.childNodes.length) parentNode.insertBefore(docFrag, frag.firstNode());\n          }\n\n          continue;\n        }\n\n        if (!frag) this.iterations[i] = this.createIteration(i, i);\n\n        if (this.rendered) {\n          if (removed[i]) docFrag.appendChild(removed[i].detach());\n          if (frag) docFrag.appendChild(frag.detach());else {\n            this.iterations[i].render(docFrag);\n          }\n        }\n      } // append any leftovers\n\n\n      if (this.rendered) {\n        for (i = len; i < oldLen; i++) {\n          if (removed[i]) docFrag.appendChild(removed[i].detach());\n        }\n\n        if (docFrag.childNodes.length) {\n          parentNode.insertBefore(docFrag, this.owner.findNextNode());\n        }\n      } // trigger removal on old nodes\n\n\n      Object.keys(removed).forEach(function (k) {\n        return removed[k].unbind().unrender(true);\n      });\n      this.iterations.forEach(_update);\n      this.pendingNewIndices = null;\n      this.shuffled();\n    }\n  }]);\n\n  return RepeatedFragment;\n}();\n\nRepeatedFragment.prototype.getContext = getContext; // find the topmost delegate\n\nfunction findDelegate(start) {\n  var el = start;\n  var delegate = start;\n\n  while (el) {\n    if (el.delegate) delegate = el;\n    el = el.parent;\n  }\n\n  return delegate;\n}\n\nfunction isEmpty(value) {\n  return !value || Array.isArray(value) && value.length === 0 || isObject(value) && Object.keys(value).length === 0;\n}\n\nfunction getType(value, hasIndexRef) {\n  if (hasIndexRef || Array.isArray(value)) return SECTION_EACH;\n  if (isObject(value) || typeof value === 'function') return SECTION_IF_WITH;\n  if (value === undefined) return null;\n  return SECTION_IF;\n}\n\nvar Section =\n/*#__PURE__*/\nfunction (_MustacheContainer2) {\n  _inherits(Section, _MustacheContainer2);\n\n  function Section(options) {\n    var _this67;\n\n    _classCallCheck(this, Section);\n\n    _this67 = _possibleConstructorReturn(this, _getPrototypeOf(Section).call(this, options));\n    _this67.sectionType = options.template.n || null;\n    _this67.templateSectionType = _this67.sectionType;\n    _this67.subordinate = options.template.l === 1;\n    _this67.fragment = null;\n    return _this67;\n  }\n\n  _createClass(Section, [{\n    key: \"bind\",\n    value: function bind() {\n      _get(_getPrototypeOf(Section.prototype), \"bind\", this).call(this);\n\n      if (this.subordinate) {\n        this.sibling = this.parentFragment.items[this.parentFragment.items.indexOf(this) - 1];\n        this.sibling.nextSibling = this;\n      } // if we managed to bind, we need to create children\n\n\n      if (this.model) {\n        this.dirty = true;\n        this.update();\n      } else if (this.sectionType && this.sectionType === SECTION_UNLESS && (!this.sibling || !this.sibling.isTruthy())) {\n        this.fragment = new Fragment({\n          owner: this,\n          template: this.template.f\n        }).bind();\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var frag = this.fragment || this.detached;\n      return frag ? frag.detach() : _get(_getPrototypeOf(Section.prototype), \"detach\", this).call(this);\n    }\n  }, {\n    key: \"isTruthy\",\n    value: function isTruthy() {\n      if (this.subordinate && this.sibling.isTruthy()) return true;\n      var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n      return !!value && (this.templateSectionType === SECTION_IF_WITH || !isEmpty(value));\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next, previous, safe) {\n      if (_get(_getPrototypeOf(Section.prototype), \"rebind\", this).call(this, next, previous, safe)) {\n        if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n          this.fragment.rebind(next);\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      this.rendered = true;\n      if (this.fragment) this.fragment.render(target, occupants);\n    }\n  }, {\n    key: \"shuffle\",\n    value: function shuffle(newIndices) {\n      if (this.fragment && this.sectionType === SECTION_EACH) {\n        this.fragment.shuffle(newIndices);\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      _get(_getPrototypeOf(Section.prototype), \"unbind\", this).call(this);\n\n      if (this.fragment) this.fragment.unbind();\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if (this.rendered && this.fragment) this.fragment.unrender(shouldDestroy);\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this68 = this;\n\n      if (!this.dirty) return;\n\n      if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n        this.fragment.context = this.model;\n      }\n\n      if (!this.model && this.sectionType !== SECTION_UNLESS) return;\n      this.dirty = false;\n      var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n      var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n      var lastType = this.sectionType; // watch for switching section types\n\n      if (this.sectionType === null || this.templateSectionType === null) this.sectionType = getType(value, this.template.i);\n\n      if (lastType && lastType !== this.sectionType && this.fragment) {\n        if (this.rendered) {\n          this.fragment.unbind().unrender(true);\n        }\n\n        this.fragment = null;\n      }\n\n      var newFragment;\n      var fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n      this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n      siblingFalsey && (this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy()); // if, unless, and if-with depend on siblings and the condition\n\n      if (fragmentShouldExist) {\n        if (!this.fragment) this.fragment = this.detached;\n\n        if (this.fragment) {\n          // check for detached fragment\n          if (this.detached) {\n            attach(this, this.fragment);\n            this.detached = false;\n            this.rendered = true;\n          }\n\n          if (!this.fragment.bound) this.fragment.bind(this.model);\n          this.fragment.update();\n        } else {\n          if (this.sectionType === SECTION_EACH) {\n            newFragment = new RepeatedFragment({\n              owner: this,\n              template: this.template.f,\n              indexRef: this.template.i\n            }).bind(this.model);\n          } else {\n            // only with and if-with provide context - if and unless do not\n            var context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;\n            newFragment = new Fragment({\n              owner: this,\n              template: this.template.f\n            }).bind(context);\n          }\n        }\n      } else {\n        if (this.fragment && this.rendered) {\n          if (keep !== true) {\n            this.fragment.unbind().unrender(true);\n          } else {\n            this.unrender(false);\n            this.detached = this.fragment;\n            runloop.promise().then(function () {\n              if (_this68.detached) _this68.detach();\n            });\n          }\n        } else if (this.fragment) {\n          this.fragment.unbind();\n        }\n\n        this.fragment = null;\n      }\n\n      if (newFragment) {\n        if (this.rendered) {\n          attach(this, newFragment);\n        }\n\n        this.fragment = newFragment;\n      }\n\n      if (this.nextSibling) {\n        this.nextSibling.dirty = true;\n        this.nextSibling.update();\n      }\n    }\n  }]);\n\n  return Section;\n}(MustacheContainer);\n\nfunction attach(section, fragment) {\n  var anchor = section.parentFragment.findNextNode(section);\n\n  if (anchor) {\n    var docFrag = createDocumentFragment();\n    fragment.render(docFrag);\n    anchor.parentNode.insertBefore(docFrag, anchor);\n  } else {\n    fragment.render(section.parentFragment.findParentNode());\n  }\n}\n\nvar Select =\n/*#__PURE__*/\nfunction (_Element4) {\n  _inherits(Select, _Element4);\n\n  function Select(options) {\n    var _this69;\n\n    _classCallCheck(this, Select);\n\n    _this69 = _possibleConstructorReturn(this, _getPrototypeOf(Select).call(this, options));\n    _this69.options = [];\n    return _this69;\n  }\n\n  _createClass(Select, [{\n    key: \"foundNode\",\n    value: function foundNode(node) {\n      if (this.binding) {\n        var selectedOptions = getSelectedOptions(node);\n\n        if (selectedOptions.length > 0) {\n          this.selectedOptions = selectedOptions;\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      _get(_getPrototypeOf(Select.prototype), \"render\", this).call(this, target, occupants);\n\n      this.sync();\n      var node = this.node;\n      var i = node.options.length;\n\n      while (i--) {\n        node.options[i].defaultSelected = node.options[i].selected;\n      }\n\n      this.rendered = true;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var _this70 = this;\n\n      var selectNode = this.node;\n      if (!selectNode) return;\n      var options = toArray(selectNode.options);\n\n      if (this.selectedOptions) {\n        options.forEach(function (o) {\n          if (_this70.selectedOptions.indexOf(o) >= 0) o.selected = true;else o.selected = false;\n        });\n        this.binding.setFromNode(selectNode);\n        delete this.selectedOptions;\n        return;\n      }\n\n      var selectValue = this.getAttribute('value');\n      var isMultiple = this.getAttribute('multiple');\n      var array = isMultiple && Array.isArray(selectValue); // If the <select> has a specified value, that should override\n      // these options\n\n      if (selectValue !== undefined) {\n        var optionWasSelected;\n        options.forEach(function (o) {\n          var optionValue = o._ractive ? o._ractive.value : o.value;\n          var shouldSelect = isMultiple ? array && _this70.valueContains(selectValue, optionValue) : _this70.compare(selectValue, optionValue);\n\n          if (shouldSelect) {\n            optionWasSelected = true;\n          }\n\n          o.selected = shouldSelect;\n        });\n\n        if (!optionWasSelected && !isMultiple) {\n          if (this.binding) {\n            this.binding.forceUpdate();\n          }\n        }\n      } // Otherwise the value should be initialised according to which\n      // <option> element is selected, if twoway binding is in effect\n      else if (this.binding) {\n          this.binding.forceUpdate();\n        }\n    }\n  }, {\n    key: \"valueContains\",\n    value: function valueContains(selectValue, optionValue) {\n      var i = selectValue.length;\n\n      while (i--) {\n        if (this.compare(optionValue, selectValue[i])) return true;\n      }\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(optionValue, selectValue) {\n      var comparator = this.getAttribute('value-comparator');\n\n      if (comparator) {\n        if (typeof comparator === 'function') {\n          return comparator(selectValue, optionValue);\n        }\n\n        if (selectValue && optionValue) {\n          return selectValue[comparator] == optionValue[comparator];\n        }\n      }\n\n      return selectValue == optionValue;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var dirty = this.dirty;\n\n      _get(_getPrototypeOf(Select.prototype), \"update\", this).call(this);\n\n      if (dirty) {\n        this.sync();\n      }\n    }\n  }]);\n\n  return Select;\n}(Element);\n\nvar Textarea =\n/*#__PURE__*/\nfunction (_Input) {\n  _inherits(Textarea, _Input);\n\n  function Textarea(options) {\n    var _this71;\n\n    _classCallCheck(this, Textarea);\n\n    var template = options.template;\n    options.deferContent = true;\n    _this71 = _possibleConstructorReturn(this, _getPrototypeOf(Textarea).call(this, options)); // check for single interpolator binding\n\n    if (!_this71.attributeByName.value) {\n      if (template.f && isBindable({\n        template: template\n      })) {\n        (_this71.attributes || (_this71.attributes = [])).push(createItem({\n          owner: _assertThisInitialized(_this71),\n          template: {\n            t: ATTRIBUTE,\n            f: template.f,\n            n: 'value'\n          },\n          parentFragment: _this71.parentFragment\n        }));\n      } else {\n        _this71.fragment = new Fragment({\n          owner: _assertThisInitialized(_this71),\n          cssIds: null,\n          template: template.f\n        });\n      }\n    }\n\n    return _this71;\n  }\n\n  _createClass(Textarea, [{\n    key: \"bubble\",\n    value: function bubble() {\n      var _this72 = this;\n\n      if (!this.dirty) {\n        this.dirty = true;\n\n        if (this.rendered && !this.binding && this.fragment) {\n          runloop.scheduleTask(function () {\n            _this72.dirty = false;\n            _this72.node.value = _this72.fragment.toString();\n          });\n        }\n\n        this.parentFragment.bubble(); // default behaviour\n      }\n    }\n  }]);\n\n  return Textarea;\n}(Input);\n\nvar Text =\n/*#__PURE__*/\nfunction (_Item9) {\n  _inherits(Text, _Item9);\n\n  function Text(options) {\n    var _this73;\n\n    _classCallCheck(this, Text);\n\n    _this73 = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, options));\n    _this73.type = TEXT;\n    return _this73;\n  }\n\n  _createClass(Text, [{\n    key: \"detach\",\n    value: function detach() {\n      return detachNode(this.node);\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode() {\n      return this.node;\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      if (inAttributes()) return;\n      this.rendered = true;\n      progressiveText(this, target, occupants, this.template);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(escape) {\n      return escape ? escapeHtml(this.template) : this.template;\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      if (this.rendered && shouldDestroy) this.detach();\n      this.rendered = false;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.template;\n    }\n  }]);\n\n  return Text;\n}(Item);\n\nvar proto$4 = Text.prototype;\nproto$4.bind = proto$4.unbind = proto$4.update = noop;\nvar visible;\nvar hidden = 'hidden';\n\nif (doc) {\n  var _prefix;\n  /* istanbul ignore next */\n\n\n  if (hidden in doc) {\n    _prefix = '';\n  } else {\n    var _i36 = vendors.length;\n\n    while (_i36--) {\n      var vendor = vendors[_i36];\n      hidden = vendor + 'Hidden';\n\n      if (hidden in doc) {\n        _prefix = vendor;\n        break;\n      }\n    }\n  }\n  /* istanbul ignore else */\n\n\n  if (_prefix !== undefined) {\n    doc.addEventListener(_prefix + 'visibilitychange', onChange);\n    onChange();\n  } else {\n    // gah, we're in an old browser\n    if ('onfocusout' in doc) {\n      doc.addEventListener('focusout', onHide);\n      doc.addEventListener('focusin', onShow);\n    } else {\n      win.addEventListener('pagehide', onHide);\n      win.addEventListener('blur', onHide);\n      win.addEventListener('pageshow', onShow);\n      win.addEventListener('focus', onShow);\n    }\n\n    visible = true; // until proven otherwise. Not ideal but hey\n  }\n}\n\nfunction onChange() {\n  visible = !doc[hidden];\n}\n/* istanbul ignore next */\n\n\nfunction onHide() {\n  visible = false;\n}\n/* istanbul ignore next */\n\n\nfunction onShow() {\n  visible = true;\n}\n\nvar prefix;\n/* istanbul ignore next */\n\nif (!isClient) {\n  prefix = null;\n} else {\n  var prefixCache = {};\n  var testStyle = createElement('div').style; // technically this also normalizes on hyphenated styles as well\n\n  prefix = function prefix(prop) {\n    if (!prefixCache[prop]) {\n      var _name5 = hyphenateCamel(prop);\n\n      if (testStyle[prop] !== undefined) {\n        prefixCache[prop] = _name5;\n      }\n      /* istanbul ignore next */\n      else {\n          // test vendors...\n          var _i37 = vendors.length;\n\n          while (_i37--) {\n            var _vendor = \"-\".concat(vendors[_i37], \"-\").concat(_name5);\n\n            if (testStyle[_vendor] !== undefined) {\n              prefixCache[prop] = _vendor;\n              break;\n            }\n          }\n        }\n    }\n\n    return prefixCache[prop];\n  };\n}\n\nvar prefix$1 = prefix;\nvar vendorPattern = new RegExp('^(?:' + vendors.join('|') + ')([A-Z])');\n\nvar hyphenate = function hyphenate(str) {\n  /* istanbul ignore next */\n  if (!str) return ''; // edge case\n\n  /* istanbul ignore next */\n\n  if (vendorPattern.test(str)) str = '-' + str;\n  return str.replace(/[A-Z]/g, function (match) {\n    return '-' + match.toLowerCase();\n  });\n};\n\nvar createTransitions;\n\nif (!isClient) {\n  createTransitions = null;\n} else {\n  var _testStyle = createElement('div').style;\n\n  var _linear = function _linear(x) {\n    return x;\n  };\n\n  var canUseCssTransitions = {};\n  var cannotUseCssTransitions = {}; // determine some facts about our environment\n\n  var _TRANSITION;\n\n  var TRANSITIONEND;\n  var CSS_TRANSITIONS_ENABLED;\n  var TRANSITION_DURATION;\n  var TRANSITION_PROPERTY;\n  var TRANSITION_TIMING_FUNCTION;\n\n  if (_testStyle.transition !== undefined) {\n    _TRANSITION = 'transition';\n    TRANSITIONEND = 'transitionend';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else if (_testStyle.webkitTransition !== undefined) {\n    _TRANSITION = 'webkitTransition';\n    TRANSITIONEND = 'webkitTransitionEnd';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else {\n    CSS_TRANSITIONS_ENABLED = false;\n  }\n\n  if (_TRANSITION) {\n    TRANSITION_DURATION = _TRANSITION + 'Duration';\n    TRANSITION_PROPERTY = _TRANSITION + 'Property';\n    TRANSITION_TIMING_FUNCTION = _TRANSITION + 'TimingFunction';\n  }\n\n  createTransitions = function createTransitions(t, to, options, changedProperties, resolve) {\n    // Wait a beat (otherwise the target styles will be applied immediately)\n    // TODO use a fastdom-style mechanism?\n    setTimeout(function () {\n      var jsTransitionsComplete;\n      var cssTransitionsComplete;\n      var cssTimeout; // eslint-disable-line prefer-const\n\n      function transitionDone() {\n        clearTimeout(cssTimeout);\n      }\n\n      function checkComplete() {\n        if (jsTransitionsComplete && cssTransitionsComplete) {\n          t.unregisterCompleteHandler(transitionDone); // will changes to events and fire have an unexpected consequence here?\n\n          t.ractive.fire(t.name + ':end', t.node, t.isIntro);\n          resolve();\n        }\n      } // this is used to keep track of which elements can use CSS to animate\n      // which properties\n\n\n      var hashPrefix = (t.node.namespaceURI || '') + t.node.tagName; // need to reset transition properties\n\n      var style = t.node.style;\n      var previous = {\n        property: style[TRANSITION_PROPERTY],\n        timing: style[TRANSITION_TIMING_FUNCTION],\n        duration: style[TRANSITION_DURATION]\n      };\n\n      function transitionEndHandler(event) {\n        var index = changedProperties.indexOf(event.propertyName);\n\n        if (index !== -1) {\n          changedProperties.splice(index, 1);\n        }\n\n        if (changedProperties.length) {\n          // still transitioning...\n          return;\n        }\n\n        clearTimeout(cssTimeout);\n        cssTransitionsDone();\n      }\n\n      function cssTransitionsDone() {\n        style[TRANSITION_PROPERTY] = previous.property;\n        style[TRANSITION_TIMING_FUNCTION] = previous.duration;\n        style[TRANSITION_DURATION] = previous.timing;\n        t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n        cssTransitionsComplete = true;\n        checkComplete();\n      }\n\n      t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false); // safety net in case transitionend never fires\n\n      cssTimeout = setTimeout(function () {\n        changedProperties = [];\n        cssTransitionsDone();\n      }, options.duration + (options.delay || 0) + 50);\n      t.registerCompleteHandler(transitionDone);\n      style[TRANSITION_PROPERTY] = changedProperties.join(',');\n      var easingName = hyphenate(options.easing || 'linear');\n      style[TRANSITION_TIMING_FUNCTION] = easingName;\n      var cssTiming = style[TRANSITION_TIMING_FUNCTION] === easingName;\n      style[TRANSITION_DURATION] = options.duration / 1000 + 's';\n      setTimeout(function () {\n        var i = changedProperties.length;\n        var hash;\n        var originalValue = null;\n        var index;\n        var propertiesToTransitionInJs = [];\n        var prop;\n        var suffix;\n        var interpolator;\n\n        while (i--) {\n          prop = changedProperties[i];\n          hash = hashPrefix + prop;\n\n          if (cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n            var initial = style[prop];\n            style[prop] = to[prop]; // If we're not sure if CSS transitions are supported for\n            // this tag/property combo, find out now\n\n            if (!(hash in canUseCssTransitions)) {\n              originalValue = t.getStyle(prop); // if this property is transitionable in this browser,\n              // the current style will be different from the target style\n\n              canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n              cannotUseCssTransitions[hash] = !canUseCssTransitions[hash]; // Reset, if we're going to use timers after all\n\n              if (cannotUseCssTransitions[hash]) {\n                style[prop] = initial;\n              }\n            }\n          }\n\n          if (!cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n            // we need to fall back to timer-based stuff\n            if (originalValue === null) originalValue = t.getStyle(prop); // need to remove this from changedProperties, otherwise transitionEndHandler\n            // will get confused\n\n            index = changedProperties.indexOf(prop);\n\n            if (index === -1) {\n              warnIfDebug('Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', {\n                node: t.node\n              });\n            } else {\n              changedProperties.splice(index, 1);\n            } // TODO Determine whether this property is animatable at all\n\n\n            suffix = /[^\\d]*$/.exec(originalValue)[0];\n            interpolator = interpolate(parseFloat(originalValue), parseFloat(to[prop])); // ...then kick off a timer-based transition\n\n            if (interpolator) {\n              propertiesToTransitionInJs.push({\n                name: prop,\n                interpolator: interpolator,\n                suffix: suffix\n              });\n            } else {\n              style[prop] = to[prop];\n            }\n\n            originalValue = null;\n          }\n        } // javascript transitions\n\n\n        if (propertiesToTransitionInJs.length) {\n          var _easing;\n\n          if (typeof options.easing === 'string') {\n            _easing = t.ractive.easing[options.easing];\n\n            if (!_easing) {\n              warnOnceIfDebug(missingPlugin(options.easing, 'easing'));\n              _easing = _linear;\n            }\n          } else if (typeof options.easing === 'function') {\n            _easing = options.easing;\n          } else {\n            _easing = _linear;\n          }\n\n          new Ticker({\n            duration: options.duration,\n            easing: _easing,\n            step: function step(pos) {\n              var i = propertiesToTransitionInJs.length;\n\n              while (i--) {\n                var _prop2 = propertiesToTransitionInJs[i];\n                style[_prop2.name] = _prop2.interpolator(pos) + _prop2.suffix;\n              }\n            },\n            complete: function complete() {\n              jsTransitionsComplete = true;\n              checkComplete();\n            }\n          });\n        } else {\n          jsTransitionsComplete = true;\n        }\n\n        if (changedProperties.length) {\n          style[TRANSITION_PROPERTY] = changedProperties.join(',');\n        } else {\n          style[TRANSITION_PROPERTY] = 'none'; // We need to cancel the transitionEndHandler, and deal with\n          // the fact that it will never fire\n\n          t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n          cssTransitionsComplete = true;\n          checkComplete();\n        }\n      }, 0);\n    }, options.delay || 0);\n  };\n}\n\nvar createTransitions$1 = createTransitions;\nvar getComputedStyle = win && win.getComputedStyle;\nvar resolved = Promise.resolve();\nvar names = {\n  t0: 'intro-outro',\n  t1: 'intro',\n  t2: 'outro'\n};\n\nvar Transition =\n/*#__PURE__*/\nfunction () {\n  function Transition(options) {\n    _classCallCheck(this, Transition);\n\n    this.owner = options.owner || options.parentFragment.owner || findElement(options.parentFragment);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.parentFragment);\n    this.ractive = this.owner.ractive;\n    this.template = options.template;\n    this.parentFragment = options.parentFragment;\n    this.options = options;\n    this.onComplete = [];\n  }\n\n  _createClass(Transition, [{\n    key: \"animateStyle\",\n    value: function animateStyle(style, value, options) {\n      var _this74 = this;\n\n      if (arguments.length === 4) {\n        throw new Error('t.animateStyle() returns a promise - use .then() instead of passing a callback');\n      } // Special case - page isn't visible. Don't animate anything, because\n      // that way you'll never get CSS transitionend events\n\n\n      if (!visible) {\n        this.setStyle(style, value);\n        return resolved;\n      }\n\n      var to;\n\n      if (typeof style === 'string') {\n        to = {};\n        to[style] = value;\n      } else {\n        to = style; // shuffle arguments\n\n        options = value;\n      }\n\n      return new Promise(function (fulfil) {\n        // Edge case - if duration is zero, set style synchronously and complete\n        if (!options.duration) {\n          _this74.setStyle(to);\n\n          fulfil();\n          return;\n        } // Get a list of the properties we're animating\n\n\n        var propertyNames = Object.keys(to);\n        var changedProperties = []; // Store the current styles\n\n        var computedStyle = getComputedStyle(_this74.node);\n        var i = propertyNames.length;\n\n        while (i--) {\n          var prop = propertyNames[i];\n\n          var _name6 = prefix$1(prop);\n\n          var current = computedStyle[prefix$1(prop)]; // record the starting points\n\n          var init = _this74.node.style[_name6];\n          if (!(_name6 in _this74.originals)) _this74.originals[_name6] = _this74.node.style[_name6];\n          _this74.node.style[_name6] = to[prop];\n          _this74.targets[_name6] = _this74.node.style[_name6];\n          _this74.node.style[_name6] = init; // we need to know if we're actually changing anything\n\n          if (current != to[prop]) {\n            // use != instead of !==, so we can compare strings with numbers\n            changedProperties.push(_name6); // if we happened to prefix, make sure there is a properly prefixed value\n\n            to[_name6] = to[prop]; // make the computed style explicit, so we can animate where\n            // e.g. height='auto'\n\n            _this74.node.style[_name6] = current;\n          }\n        } // If we're not actually changing anything, the transitionend event\n        // will never fire! So we complete early\n\n\n        if (!changedProperties.length) {\n          fulfil();\n          return;\n        }\n\n        createTransitions$1(_this74, to, options, changedProperties, fulfil);\n      });\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var options = this.options;\n      var type = options.template && options.template.v;\n\n      if (type) {\n        if (type === 't0' || type === 't1') this.element.intro = this;\n        if (type === 't0' || type === 't2') this.element.outro = this;\n        this.eventName = names[type];\n      }\n\n      var ractive = this.owner.ractive;\n      this.name = options.name || options.template.n;\n\n      if (options.params) {\n        this.params = options.params;\n      }\n\n      if (typeof this.name === 'function') {\n        this._fn = this.name;\n        this.name = this._fn.name;\n      } else {\n        this._fn = findInViewHierarchy('transitions', ractive, this.name);\n      }\n\n      if (!this._fn) {\n        warnOnceIfDebug(missingPlugin(this.name, 'transition'), {\n          ractive: ractive\n        });\n      }\n\n      setupArgsFn(this, options.template);\n    }\n  }, {\n    key: \"getParams\",\n    value: function getParams() {\n      if (this.params) return this.params; // get expression args if supplied\n\n      if (this.fn) {\n        var values = resolveArgs(this, this.template, this.parentFragment).map(function (model) {\n          if (!model) return undefined;\n          return model.get();\n        });\n        return this.fn.apply(this.ractive, values);\n      }\n    }\n  }, {\n    key: \"getStyle\",\n    value: function getStyle(props) {\n      var computedStyle = getComputedStyle(this.node);\n\n      if (typeof props === 'string') {\n        return computedStyle[prefix$1(props)];\n      }\n\n      if (!Array.isArray(props)) {\n        throw new Error('Transition$getStyle must be passed a string, or an array of strings representing CSS properties');\n      }\n\n      var styles = {};\n      var i = props.length;\n\n      while (i--) {\n        var prop = props[i];\n        var _value12 = computedStyle[prefix$1(prop)];\n        if (_value12 === '0px') _value12 = 0;\n        styles[prop] = _value12;\n      }\n\n      return styles;\n    }\n  }, {\n    key: \"processParams\",\n    value: function processParams(params, defaults) {\n      if (typeof params === 'number') {\n        params = {\n          duration: params\n        };\n      } else if (typeof params === 'string') {\n        if (params === 'slow') {\n          params = {\n            duration: 600\n          };\n        } else if (params === 'fast') {\n          params = {\n            duration: 200\n          };\n        } else {\n          params = {\n            duration: 400\n          };\n        }\n      } else if (!params) {\n        params = {};\n      }\n\n      return Object.assign({}, defaults, params);\n    }\n  }, {\n    key: \"registerCompleteHandler\",\n    value: function registerCompleteHandler(fn) {\n      addToArray(this.onComplete, fn);\n    }\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(style, value) {\n      if (typeof style === 'string') {\n        var _name7 = prefix$1(style);\n\n        if (!this.originals.hasOwnProperty(_name7)) this.originals[_name7] = this.node.style[_name7];\n        this.node.style[_name7] = value;\n        this.targets[_name7] = this.node.style[_name7];\n      } else {\n        var prop;\n\n        for (prop in style) {\n          if (style.hasOwnProperty(prop)) {\n            this.setStyle(prop, style[prop]);\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"shouldFire\",\n    value: function shouldFire(type) {\n      if (!this.ractive.transitionsEnabled) return false; // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively\n\n      if (type === 'intro' && this.ractive.rendering && nearestProp('noIntro', this.ractive, true)) return false;\n      if (type === 'outro' && this.ractive.unrendering && nearestProp('noOutro', this.ractive, false)) return false;\n      var params = this.getParams(); // this is an array, the params object should be the first member\n      // if there's not a parent element, this can't be nested, so roll on\n\n      if (!this.element.parent) return true; // if there is a local param, it takes precedent\n\n      if (params && params[0] && isObject(params[0]) && 'nested' in params[0]) {\n        if (params[0].nested !== false) return true;\n      } else {\n        // use the nearest instance setting\n        // find the nearest instance that actually has a nested setting\n        if (nearestProp('nestedTransitions', this.ractive) !== false) return true;\n      } // check to see if this is actually a nested transition\n\n\n      var el = this.element.parent;\n\n      while (el) {\n        if (el[type] && el[type].starting) return false;\n        el = el.parent;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this75 = this;\n\n      var node = this.node = this.element.node;\n      var originals = this.originals = {}; //= node.getAttribute( 'style' );\n\n      var targets = this.targets = {};\n      var completed;\n      var args = this.getParams(); // create t.complete() - we don't want this on the prototype,\n      // because we don't want `this` silliness when passing it as\n      // an argument\n\n      this.complete = function (noReset) {\n        _this75.starting = false;\n\n        if (completed) {\n          return;\n        }\n\n        _this75.onComplete.forEach(function (fn) {\n          return fn();\n        });\n\n        if (!noReset && _this75.isIntro) {\n          for (var k in targets) {\n            if (node.style[k] === targets[k]) node.style[k] = originals[k];\n          }\n        }\n\n        _this75._manager.remove(_this75);\n\n        completed = true;\n      }; // If the transition function doesn't exist, abort\n\n\n      if (!this._fn) {\n        this.complete();\n        return;\n      }\n\n      var promise = this._fn.apply(this.ractive, [this].concat(args));\n\n      if (promise) promise.then(this.complete);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '';\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      if (!this.element.attributes.unbinding) {\n        var type = this.options && this.options.template && this.options.template.v;\n        if (type === 't0' || type === 't1') this.element.intro = null;\n        if (type === 't0' || type === 't2') this.element.outro = null;\n      }\n    }\n  }, {\n    key: \"unregisterCompleteHandler\",\n    value: function unregisterCompleteHandler(fn) {\n      removeFromArray(this.onComplete, fn);\n    }\n  }]);\n\n  return Transition;\n}();\n\nvar proto$5 = Transition.prototype;\nproto$5.destroyed = proto$5.render = proto$5.unrender = proto$5.update = noop;\n\nfunction nearestProp(prop, ractive, rendering) {\n  var instance = ractive;\n\n  while (instance) {\n    if (instance.hasOwnProperty(prop) && (rendering === undefined || rendering ? instance.rendering : instance.unrendering)) return instance[prop];\n    instance = instance.component && instance.component.ractive;\n  }\n\n  return ractive[prop];\n}\n\nvar elementCache = {};\nvar ieBug;\nvar ieBlacklist;\n\ntry {\n  createElement('table').innerHTML = 'foo';\n} catch (\n/* istanbul ignore next */\nerr) {\n  ieBug = true;\n  ieBlacklist = {\n    TABLE: ['<table class=\"x\">', '</table>'],\n    THEAD: ['<table><thead class=\"x\">', '</thead></table>'],\n    TBODY: ['<table><tbody class=\"x\">', '</tbody></table>'],\n    TR: ['<table><tr class=\"x\">', '</tr></table>'],\n    SELECT: ['<select class=\"x\">', '</select>']\n  };\n}\n\nvar insertHtml = function insertHtml(html$$1, node) {\n  var nodes = []; // render 0 and false\n\n  if (html$$1 == null || html$$1 === '') return nodes;\n  var container;\n  var wrapper;\n  var selectedOption;\n  /* istanbul ignore if */\n\n  if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n    container = element('DIV');\n    container.innerHTML = wrapper[0] + html$$1 + wrapper[1];\n    container = container.querySelector('.x');\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  } else if (node.namespaceURI === svg$1) {\n    container = element('DIV');\n    container.innerHTML = '<svg class=\"x\">' + html$$1 + '</svg>';\n    container = container.querySelector('.x');\n  } else if (node.tagName === 'TEXTAREA') {\n    container = createElement('div');\n\n    if (typeof container.textContent !== 'undefined') {\n      container.textContent = html$$1;\n    } else {\n      container.innerHTML = html$$1;\n    }\n  } else {\n    container = element(node.tagName);\n    container.innerHTML = html$$1;\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  }\n\n  var child;\n\n  while (child = container.firstChild) {\n    nodes.push(child);\n    container.removeChild(child);\n  } // This is really annoying. Extracting <option> nodes from the\n  // temporary container <select> causes the remaining ones to\n  // become selected. So now we have to deselect them. IE8, you\n  // amaze me. You really do\n  // ...and now Chrome too\n\n\n  var i;\n\n  if (node.tagName === 'SELECT') {\n    i = nodes.length;\n\n    while (i--) {\n      if (nodes[i] !== selectedOption) {\n        nodes[i].selected = false;\n      }\n    }\n  }\n\n  return nodes;\n};\n\nfunction element(tagName) {\n  return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n}\n\nvar Triple =\n/*#__PURE__*/\nfunction (_Mustache2) {\n  _inherits(Triple, _Mustache2);\n\n  function Triple(options) {\n    _classCallCheck(this, Triple);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Triple).call(this, options));\n  }\n\n  _createClass(Triple, [{\n    key: \"detach\",\n    value: function detach() {\n      var docFrag = createDocumentFragment();\n      if (this.nodes) this.nodes.forEach(function (node) {\n        return docFrag.appendChild(node);\n      });\n      return docFrag;\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      var len = this.nodes.length;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        var node = this.nodes[i];\n        if (node.nodeType !== 1) continue;\n        if (matches(node, selector)) return node;\n        var queryResult = node.querySelector(selector);\n        if (queryResult) return queryResult;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      var result = options.result;\n      var len = this.nodes.length;\n      var i;\n\n      for (i = 0; i < len; i += 1) {\n        var node = this.nodes[i];\n        if (node.nodeType !== 1) continue;\n        if (matches(node, selector)) result.push(node);\n        var queryAllResult = node.querySelectorAll(selector);\n\n        if (queryAllResult) {\n          result.push.apply(result, queryAllResult);\n        }\n      }\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent() {\n      return null;\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode() {\n      return this.rendered && this.nodes[0];\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      var parentNode = this.parentFragment.findParentNode();\n\n      if (!this.nodes) {\n        var _html = this.model ? this.model.get() : '';\n\n        this.nodes = insertHtml(_html, this.parentFragment.findParentNode(), target);\n      }\n\n      var nodes = this.nodes;\n      var anchor = this.parentFragment.findNextNode(this); // progressive enhancement\n\n      if (occupants) {\n        var _i38 = -1;\n\n        var next; // start with the first node that should be rendered\n\n        while (occupants.length && (next = this.nodes[_i38 + 1])) {\n          var _n6 = void 0; // look through the occupants until a matching node is found\n\n\n          while (_n6 = occupants.shift()) {\n            var t = _n6.nodeType;\n\n            if (t === next.nodeType && (t === 1 && _n6.outerHTML === next.outerHTML || (t === 3 || t === 8) && _n6.nodeValue === next.nodeValue)) {\n              this.nodes.splice(++_i38, 1, _n6); // replace the generated node with the existing one\n\n              break;\n            } else {\n              target.removeChild(_n6); // remove the non-matching existing node\n            }\n          }\n        }\n\n        if (_i38 >= 0) {\n          // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes\n          nodes = this.nodes.slice(_i38);\n        } // update the anchor to be the next occupant\n\n\n        if (occupants.length) anchor = occupants[0];\n      } // attach any remainging nodes to the parent\n\n\n      if (nodes.length) {\n        var frag = createDocumentFragment();\n        nodes.forEach(function (n) {\n          return frag.appendChild(n);\n        });\n\n        if (anchor) {\n          anchor.parentNode.insertBefore(frag, anchor);\n        } else {\n          parentNode.appendChild(frag);\n        }\n      }\n\n      this.rendered = true;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var value = this.model && this.model.get();\n      value = value != null ? '' + value : '';\n      return inAttribute() ? decodeCharacterReferences(value) : value;\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender() {\n      if (this.nodes) this.nodes.forEach(function (node) {\n        // defer detachment until all relevant outros are done\n        runloop.detachWhenReady({\n          node: node,\n          detach: function detach() {\n            detachNode(node);\n          }\n        });\n      });\n      this.rendered = false;\n      this.nodes = null;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.rendered && this.dirty) {\n        this.dirty = false;\n        this.unrender();\n        this.render();\n      } else {\n        // make sure to reset the dirty flag even if not rendered\n        this.dirty = false;\n      }\n    }\n  }]);\n\n  return Triple;\n}(Mustache); // finds the component constructor in the registry or view hierarchy registries\n\n\nfunction getComponentConstructor(ractive, name) {\n  var instance = findInstance('components', ractive, name);\n  var Component;\n\n  if (instance) {\n    Component = instance.components[name]; // best test we have for not Ractive.extend\n\n    if (Component && !Component.Parent) {\n      // function option, execute and store for reset\n      var fn = Component.bind(instance);\n      fn.isOwner = instance.components.hasOwnProperty(name);\n      Component = fn();\n\n      if (!Component) {\n        warnIfDebug(noRegistryFunctionReturn, name, 'component', 'component', {\n          ractive: ractive\n        });\n        return;\n      }\n\n      if (typeof Component === 'string') {\n        // allow string lookup\n        Component = getComponentConstructor(ractive, Component);\n      }\n\n      Component._fn = fn;\n      instance.components[name] = Component;\n    }\n  }\n\n  return Component;\n} //import Yielder from './Yielder';\n\n\nvar constructors = {};\nconstructors[ALIAS] = Alias;\nconstructors[ANCHOR] = Component;\nconstructors[DOCTYPE] = Doctype;\nconstructors[INTERPOLATOR] = Interpolator;\nconstructors[PARTIAL] = Partial;\nconstructors[SECTION] = Section;\nconstructors[TRIPLE] = Triple;\nconstructors[YIELDER] = Partial;\nconstructors[ATTRIBUTE] = Attribute;\nconstructors[BINDING_FLAG] = BindingFlag;\nconstructors[DECORATOR] = Decorator;\nconstructors[EVENT] = EventDirective;\nconstructors[TRANSITION] = Transition;\nvar specialElements = {\n  doctype: Doctype,\n  form: Form,\n  input: Input,\n  option: Option,\n  select: Select,\n  textarea: Textarea\n};\n\nfunction createItem(options) {\n  if (typeof options.template === 'string') {\n    return new Text(options);\n  }\n\n  if (options.template.t === ELEMENT) {\n    // could be component or element\n    var ComponentConstructor = getComponentConstructor(options.parentFragment.ractive, options.template.e);\n\n    if (ComponentConstructor) {\n      return new Component(options, ComponentConstructor);\n    }\n\n    var tagName = options.template.e.toLowerCase();\n    var ElementConstructor = specialElements[tagName] || Element;\n    return new ElementConstructor(options);\n  }\n\n  var Item; // component mappings are a special case of attribute\n\n  if (options.template.t === ATTRIBUTE) {\n    var el = options.owner;\n\n    if (!el || el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT) {\n      el = findElement(options.parentFragment);\n    }\n\n    options.element = el;\n    Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;\n  } else {\n    Item = constructors[options.template.t];\n  }\n\n  if (!Item) throw new Error(\"Unrecognised item type \".concat(options.template.t));\n  return new Item(options);\n} // TODO all this code needs to die\n\n\nfunction processItems(items, values, guid) {\n  var counter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return items.map(function (item) {\n    if (item.type === TEXT) {\n      return item.template;\n    }\n\n    if (item.fragment) {\n      if (item.fragment.iterations) {\n        return item.fragment.iterations.map(function (fragment) {\n          return processItems(fragment.items, values, guid, counter);\n        }).join('');\n      } else {\n        return processItems(item.fragment.items, values, guid, counter);\n      }\n    }\n\n    var placeholderId = \"\".concat(guid, \"-\").concat(counter++);\n    var model = item.model || item.newModel;\n    values[placeholderId] = model ? model.wrapper ? model.wrapperValue : model.get() : undefined;\n    return '${' + placeholderId + '}';\n  }).join('');\n}\n\nfunction unrenderAndDestroy$1(item) {\n  item.unrender(true);\n}\n\nvar Fragment =\n/*#__PURE__*/\nfunction () {\n  function Fragment(options) {\n    _classCallCheck(this, Fragment);\n\n    this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n    this.isRoot = !options.owner.parentFragment;\n    this.parent = this.isRoot ? null : this.owner.parentFragment;\n    this.ractive = options.ractive || (this.isRoot ? options.owner : this.parent.ractive);\n    this.componentParent = this.isRoot && this.ractive.component ? this.ractive.component.parentFragment : null;\n    this.delegate = (this.parent ? this.parent.delegate : this.componentParent && this.componentParent.delegate) || this.owner.containerFragment && this.owner.containerFragment.delegate;\n    this.context = null;\n    this.rendered = false; // encapsulated styles should be inherited until they get applied by an element\n\n    if ('cssIds' in options) {\n      this.cssIds = options.cssIds && options.cssIds.length && options.cssIds;\n    } else {\n      this.cssIds = this.parent ? this.parent.cssIds : null;\n    }\n\n    this.dirty = false;\n    this.dirtyValue = true; // used for attribute values\n\n    this.template = options.template || [];\n    this.createItems();\n  }\n\n  _createClass(Fragment, [{\n    key: \"bind\",\n    value: function bind(context) {\n      this.context = context;\n      this.items.forEach(_bind2);\n      this.bound = true; // in rare cases, a forced resolution (or similar) will cause the\n      // fragment to be dirty before it's even finished binding. In those\n      // cases we update immediately\n\n      if (this.dirty) this.update();\n      return this;\n    }\n  }, {\n    key: \"bubble\",\n    value: function bubble() {\n      this.dirtyValue = true;\n\n      if (!this.dirty) {\n        this.dirty = true;\n\n        if (this.isRoot) {\n          // TODO encapsulate 'is component root, but not overall root' check?\n          if (this.ractive.component) {\n            this.ractive.component.bubble();\n          } else if (this.bound) {\n            runloop.addFragment(this);\n          }\n        } else {\n          this.owner.bubble(this.index);\n        }\n      }\n    }\n  }, {\n    key: \"createItems\",\n    value: function createItems() {\n      // this is a hot code path\n      var max = this.template.length;\n      this.items = [];\n\n      for (var _i39 = 0; _i39 < max; _i39++) {\n        this.items[_i39] = createItem({\n          parentFragment: this,\n          template: this.template[_i39],\n          index: _i39\n        });\n      }\n    }\n  }, {\n    key: \"destroyed\",\n    value: function destroyed() {\n      this.items.forEach(_destroyed);\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      var docFrag = createDocumentFragment();\n      var xs = this.items;\n      var len = xs.length;\n\n      for (var _i40 = 0; _i40 < len; _i40++) {\n        docFrag.appendChild(xs[_i40].detach());\n      }\n\n      return docFrag;\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector, options) {\n      return findMap(this.items, function (i) {\n        return i.find(selector, options);\n      });\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll(selector, options) {\n      if (this.items) {\n        this.items.forEach(function (i) {\n          return i.findAll && i.findAll(selector, options);\n        });\n      }\n    }\n  }, {\n    key: \"findComponent\",\n    value: function findComponent(name, options) {\n      return findMap(this.items, function (i) {\n        return i.findComponent(name, options);\n      });\n    }\n  }, {\n    key: \"findAllComponents\",\n    value: function findAllComponents(name, options) {\n      if (this.items) {\n        this.items.forEach(function (i) {\n          return i.findAllComponents && i.findAllComponents(name, options);\n        });\n      }\n    }\n  }, {\n    key: \"findContext\",\n    value: function findContext() {\n      var base = findParentWithContext(this);\n      if (!base || !base.context) return this.ractive.viewmodel;else return base.context;\n    }\n  }, {\n    key: \"findNextNode\",\n    value: function findNextNode(item) {\n      // search for the next node going forward\n      if (item) {\n        var it;\n\n        for (var _i41 = item.index + 1; _i41 < this.items.length; _i41++) {\n          it = this.items[_i41];\n          if (!it || !it.firstNode) continue;\n          var node = it.firstNode(true);\n          if (node) return node;\n        }\n      } // if this is the root fragment, and there are no more items,\n      // it means we're at the end...\n\n\n      if (this.isRoot) {\n        if (this.ractive.component) {\n          return this.ractive.component.parentFragment.findNextNode(this.ractive.component);\n        } // TODO possible edge case with other content\n        // appended to this.ractive.el?\n\n\n        return null;\n      }\n\n      if (this.parent) return this.owner.findNextNode(this); // the argument is in case the parent is a RepeatedFragment\n    }\n  }, {\n    key: \"findParentNode\",\n    value: function findParentNode() {\n      var fragment = this;\n\n      do {\n        if (fragment.owner.type === ELEMENT) {\n          return fragment.owner.node;\n        }\n\n        if (fragment.isRoot && !fragment.ractive.component) {\n          // TODO encapsulate check\n          return fragment.ractive.el;\n        }\n\n        if (fragment.owner.type === YIELDER) {\n          fragment = fragment.owner.containerFragment;\n        } else {\n          fragment = fragment.componentParent || fragment.parent; // TODO ugh\n        }\n      } while (fragment);\n\n      throw new Error('Could not find parent node'); // TODO link to issue tracker\n    }\n  }, {\n    key: \"findRepeatingFragment\",\n    value: function findRepeatingFragment() {\n      var fragment = this; // TODO better check than fragment.parent.iterations\n\n      while ((fragment.parent || fragment.componentParent) && !fragment.isIteration) {\n        fragment = fragment.parent || fragment.componentParent;\n      }\n\n      return fragment;\n    }\n  }, {\n    key: \"firstNode\",\n    value: function firstNode(skipParent) {\n      var node = findMap(this.items, function (i) {\n        return i.firstNode(true);\n      });\n      if (node) return node;\n      if (skipParent) return null;\n      return this.parent.findNextNode(this.owner);\n    }\n  }, {\n    key: \"rebind\",\n    value: function rebind(next) {\n      this.context = next;\n    }\n  }, {\n    key: \"render\",\n    value: function render(target, occupants) {\n      if (this.rendered) throw new Error('Fragment is already rendered!');\n      this.rendered = true;\n      var xs = this.items;\n      var len = xs.length;\n\n      for (var _i42 = 0; _i42 < len; _i42++) {\n        xs[_i42].render(target, occupants);\n      }\n    }\n  }, {\n    key: \"resetTemplate\",\n    value: function resetTemplate(template) {\n      var wasBound = this.bound;\n      var wasRendered = this.rendered; // TODO ensure transitions are disabled globally during reset\n\n      if (wasBound) {\n        if (wasRendered) this.unrender(true);\n        this.unbind();\n      }\n\n      this.template = template;\n      this.createItems();\n\n      if (wasBound) {\n        this.bind(this.context);\n\n        if (wasRendered) {\n          var parentNode = this.findParentNode();\n          var anchor = this.findNextNode();\n\n          if (anchor) {\n            var docFrag = createDocumentFragment();\n            this.render(docFrag);\n            parentNode.insertBefore(docFrag, anchor);\n          } else {\n            this.render(parentNode);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"shuffled\",\n    value: function shuffled() {\n      this.items.forEach(_shuffled);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(escape) {\n      return this.items.map(escape ? toEscapedString : toString$1).join('');\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.context = null;\n      this.items.forEach(_unbind);\n      this.bound = false;\n      return this;\n    }\n  }, {\n    key: \"unrender\",\n    value: function unrender(shouldDestroy) {\n      this.items.forEach(shouldDestroy ? unrenderAndDestroy$1 : _unrender);\n      this.rendered = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this.dirty) {\n        if (!this.updating) {\n          this.dirty = false;\n          this.updating = true;\n          this.items.forEach(_update);\n          this.updating = false;\n        } else if (this.isRoot) {\n          runloop.addFragmentToRoot(this);\n        }\n      }\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      if (this.items.length === 1) {\n        return this.items[0].valueOf();\n      }\n\n      if (this.dirtyValue) {\n        var values = {};\n        var source = processItems(this.items, values, this.ractive._guid);\n        var parsed = parseJSON(source, values);\n        this.value = parsed ? parsed.value : this.toString();\n        this.dirtyValue = false;\n      }\n\n      return this.value;\n    }\n  }]);\n\n  return Fragment;\n}();\n\nFragment.prototype.getContext = getContext;\n\nfunction getChildQueue(queue, ractive) {\n  return queue[ractive._guid] || (queue[ractive._guid] = []);\n}\n\nfunction fire(hookQueue, ractive) {\n  var childQueue = getChildQueue(hookQueue.queue, ractive);\n  hookQueue.hook.fire(ractive); // queue is \"live\" because components can end up being\n  // added while hooks fire on parents that modify data values.\n\n  while (childQueue.length) {\n    fire(hookQueue, childQueue.shift());\n  }\n\n  delete hookQueue.queue[ractive._guid];\n}\n\nvar HookQueue =\n/*#__PURE__*/\nfunction () {\n  function HookQueue(event) {\n    _classCallCheck(this, HookQueue);\n\n    this.hook = new Hook(event);\n    this.inProcess = {};\n    this.queue = {};\n  }\n\n  _createClass(HookQueue, [{\n    key: \"begin\",\n    value: function begin(ractive) {\n      this.inProcess[ractive._guid] = true;\n    }\n  }, {\n    key: \"end\",\n    value: function end(ractive) {\n      var parent = ractive.parent; // If this is *isn't* a child of a component that's in process,\n      // it should call methods or fire at this point\n\n      if (!parent || !this.inProcess[parent._guid]) {\n        fire(this, ractive);\n      } // elsewise, handoff to parent to fire when ready\n      else {\n          getChildQueue(this.queue, parent).push(ractive);\n        }\n\n      delete this.inProcess[ractive._guid];\n    }\n  }]);\n\n  return HookQueue;\n}();\n\nvar configHook = new Hook('config');\nvar initHook = new HookQueue('init');\n\nfunction initialise(ractive, userOptions, options) {\n  Object.keys(ractive.viewmodel.computations).forEach(function (key) {\n    var computation = ractive.viewmodel.computations[key];\n\n    if (ractive.viewmodel.value.hasOwnProperty(key)) {\n      computation.set(ractive.viewmodel.value[key]);\n    }\n  }); // init config from Parent and options\n\n  config.init(ractive.constructor, ractive, userOptions);\n  configHook.fire(ractive);\n  initHook.begin(ractive);\n  var fragment = ractive.fragment = createFragment(ractive, options);\n  if (fragment) fragment.bind(ractive.viewmodel);\n  initHook.end(ractive); // general config done, set up observers\n\n  subscribe(ractive, userOptions, 'observe');\n\n  if (fragment) {\n    // render automatically ( if `el` is specified )\n    var el = getElement(ractive.el || ractive.target);\n\n    if (el) {\n      var promise = ractive.render(el, ractive.append);\n\n      if (Ractive.DEBUG_PROMISES) {\n        promise[\"catch\"](function (err) {\n          warnOnceIfDebug('Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;');\n          warnIfDebug('An error happened during rendering', {\n            ractive: ractive\n          });\n          logIfDebug(err);\n          throw err;\n        });\n      }\n    }\n  }\n}\n\nfunction createFragment(ractive) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (ractive.template) {\n    var cssIds = [].concat(ractive.constructor._cssIds || [], options.cssIds || []);\n    return new Fragment({\n      owner: ractive,\n      template: ractive.template,\n      cssIds: cssIds\n    });\n  }\n}\n\nvar renderHook = new Hook('render');\nvar completeHook = new Hook('complete');\n\nfunction render$1(ractive, target, anchor, occupants) {\n  // set a flag to let any transitions know that this instance is currently rendering\n  ractive.rendering = true;\n  var promise = runloop.start();\n  runloop.scheduleTask(function () {\n    return renderHook.fire(ractive);\n  }, true);\n\n  if (ractive.fragment.rendered) {\n    throw new Error('You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first');\n  }\n\n  if (ractive.destroyed) {\n    ractive.destroyed = false;\n    ractive.fragment = createFragment(ractive).bind(ractive.viewmodel);\n  }\n\n  anchor = getElement(anchor) || ractive.anchor;\n  ractive.el = ractive.target = target;\n  ractive.anchor = anchor; // ensure encapsulated CSS is up-to-date\n\n  if (ractive.cssId) applyCSS();\n\n  if (target) {\n    (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(ractive);\n\n    if (anchor) {\n      var docFrag = doc.createDocumentFragment();\n      ractive.fragment.render(docFrag);\n      target.insertBefore(docFrag, anchor);\n    } else {\n      ractive.fragment.render(target, occupants);\n    }\n  }\n\n  runloop.end();\n  ractive.rendering = false;\n  return promise.then(function () {\n    if (ractive.torndown) return;\n    completeHook.fire(ractive);\n  });\n}\n\nfunction Ractive$render(target, anchor) {\n  if (this.torndown) {\n    warnIfDebug('ractive.render() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  target = getElement(target) || this.el;\n\n  if (!this.append && target) {\n    // Teardown any existing instances *before* trying to set up the new one -\n    // avoids certain weird bugs\n    var others = target.__ractive_instances__;\n    if (others) others.forEach(_teardown); // make sure we are the only occupants\n\n    if (!this.enhance) {\n      target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n    }\n  }\n\n  var occupants = this.enhance ? toArray(target.childNodes) : null;\n  var promise = render$1(this, target, anchor, occupants);\n\n  if (occupants) {\n    while (occupants.length) {\n      target.removeChild(occupants.pop());\n    }\n  }\n\n  return promise;\n}\n\nvar shouldRerender = ['template', 'partials', 'components', 'decorators', 'events'];\nvar completeHook$1 = new Hook('complete');\nvar resetHook = new Hook('reset');\nvar renderHook$1 = new Hook('render');\nvar unrenderHook = new Hook('unrender');\n\nfunction Ractive$reset(data) {\n  data = data || {};\n\n  if (_typeof(data) !== 'object') {\n    throw new Error('The reset method takes either no arguments, or an object containing new data');\n  } // TEMP need to tidy this up\n\n\n  data = dataConfigurator.init(this.constructor, this, {\n    data: data\n  });\n  var promise = runloop.start(); // If the root object is wrapped, try and use the wrapper's reset value\n\n  var wrapper = this.viewmodel.wrapper;\n\n  if (wrapper && wrapper.reset) {\n    if (wrapper.reset(data) === false) {\n      // reset was rejected, we need to replace the object\n      this.viewmodel.set(data);\n    }\n  } else {\n    this.viewmodel.set(data);\n  } // reset config items and track if need to rerender\n\n\n  var changes = config.reset(this);\n  var rerender;\n  var i = changes.length;\n\n  while (i--) {\n    if (shouldRerender.indexOf(changes[i]) > -1) {\n      rerender = true;\n      break;\n    }\n  }\n\n  if (rerender) {\n    unrenderHook.fire(this);\n    this.fragment.resetTemplate(this.template);\n    renderHook$1.fire(this);\n    completeHook$1.fire(this);\n  }\n\n  runloop.end();\n  resetHook.fire(this, data);\n  return promise;\n}\n\nfunction collect(source, name, attr, dest) {\n  source.forEach(function (item) {\n    // queue to rerender if the item is a partial and the current name matches\n    if (item.type === PARTIAL && (item.refName === name || item.name === name)) {\n      item.inAttribute = attr;\n      dest.push(item);\n      return; // go no further\n    } // if it has a fragment, process its items\n\n\n    if (item.fragment) {\n      collect(item.fragment.iterations || item.fragment.items, name, attr, dest);\n    } // or if it is itself a fragment, process its items\n    else if (Array.isArray(item.items)) {\n        collect(item.items, name, attr, dest);\n      } // or if it is a component, step in and process its items\n      else if (item.type === COMPONENT && item.instance) {\n          // ...unless the partial is shadowed\n          if (item.instance.partials[name]) return;\n          collect(item.instance.fragment.items, name, attr, dest);\n        } // if the item is an element, process its attributes too\n\n\n    if (item.type === ELEMENT) {\n      if (Array.isArray(item.attributes)) {\n        collect(item.attributes, name, true, dest);\n      }\n    }\n  });\n}\n\nfunction forceResetTemplate(partial) {\n  partial.forceResetTemplate();\n}\n\nvar resetPartial = function resetPartial(name, partial) {\n  var collection = [];\n  collect(this.fragment.items, name, false, collection);\n  var promise = runloop.start();\n  this.partials[name] = partial;\n  collection.forEach(forceResetTemplate);\n  runloop.end();\n  return promise;\n}; // TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\n\nfunction Ractive$resetTemplate(template) {\n  templateConfigurator.init(null, this, {\n    template: template\n  });\n  var transitionsEnabled = this.transitionsEnabled;\n  this.transitionsEnabled = false; // Is this is a component, we need to set the `shouldDestroy`\n  // flag, otherwise it will assume by default that a parent node\n  // will be detached, and therefore it doesn't need to bother\n  // detaching its own nodes\n\n  var component = this.component;\n  if (component) component.shouldDestroy = true;\n  this.unrender();\n  if (component) component.shouldDestroy = false;\n  var promise = runloop.start(); // remove existing fragment and create new one\n\n  this.fragment.unbind().unrender(true);\n  this.fragment = new Fragment({\n    template: this.template,\n    root: this,\n    owner: this\n  });\n  var docFrag = createDocumentFragment();\n  this.fragment.bind(this.viewmodel).render(docFrag); // if this is a component, its el may not be valid, so find a\n  // target based on the component container\n\n  if (component && !component.external) {\n    this.fragment.findParentNode().insertBefore(docFrag, component.findNextNode());\n  } else {\n    this.el.insertBefore(docFrag, this.anchor);\n  }\n\n  runloop.end();\n  this.transitionsEnabled = transitionsEnabled;\n  return promise;\n}\n\nvar reverse = makeArrayMethod('reverse').path;\n\nfunction Ractive$set(keypath, value, options) {\n  var ractive = this;\n  var opts = _typeof(keypath) === 'object' ? value : options;\n  return _set(build(ractive, keypath, value, opts && opts.isolated), opts);\n}\n\nvar shift = makeArrayMethod('shift').path;\nvar sort = makeArrayMethod('sort').path;\nvar splice = makeArrayMethod('splice').path;\n\nfunction Ractive$subtract(keypath, d, options) {\n  var num = typeof d === 'number' ? -d : -1;\n  var opts = _typeof(d) === 'object' ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction Ractive$toggle(keypath, options) {\n  if (typeof keypath !== 'string') {\n    throw new TypeError(badArguments);\n  }\n\n  return _set(gather(this, keypath, null, options && options.isolated).map(function (m) {\n    return [m, !m.get()];\n  }), options);\n}\n\nfunction Ractive$toCSS() {\n  var cssIds = [this.cssId].concat(_toConsumableArray(this.findAllComponents().map(function (c) {\n    return c.cssId;\n  })));\n  var uniqueCssIds = Object.keys(cssIds.reduce(function (ids, id) {\n    return ids[id] = true, ids;\n  }, {}));\n  return getCSS(uniqueCssIds);\n}\n\nfunction Ractive$toHTML() {\n  return this.fragment.toString(true);\n}\n\nfunction toText() {\n  return this.fragment.toString(false);\n}\n\nfunction Ractive$transition(name, node, params) {\n  if (node instanceof HTMLElement) {// good to go\n  } else if (isObject(node)) {\n    // omitted, use event node\n    params = node;\n  } // if we allow query selector, then it won't work\n  // simple params like \"fast\"\n  // else if ( typeof node === 'string' ) {\n  // \t// query selector\n  // \tnode = this.find( node )\n  // }\n\n\n  node = node || this.event.node;\n\n  if (!node || !node._ractive) {\n    fatal(\"No node was supplied for transition \".concat(name));\n  }\n\n  params = params || {};\n  var owner = node._ractive.proxy;\n  var transition = new Transition({\n    owner: owner,\n    parentFragment: owner.parentFragment,\n    name: name,\n    params: params\n  });\n  transition.bind();\n  var promise = runloop.start();\n  runloop.registerTransition(transition);\n  runloop.end();\n  promise.then(function () {\n    return transition.unbind();\n  });\n  return promise;\n}\n\nfunction unlink(here) {\n  var promise = runloop.start();\n  this.viewmodel.joinAll(splitKeypath(here), {\n    lastLink: false\n  }).unlink();\n  runloop.end();\n  return promise;\n}\n\nvar unrenderHook$1 = new Hook('unrender');\n\nfunction Ractive$unrender() {\n  if (!this.fragment.rendered) {\n    warnIfDebug('ractive.unrender() was called on a Ractive instance that was not rendered');\n    return Promise.resolve();\n  }\n\n  this.unrendering = true;\n  var promise = runloop.start(); // If this is a component, and the component isn't marked for destruction,\n  // don't detach nodes from the DOM unnecessarily\n\n  var shouldDestroy = !this.component || (this.component.anchor || {}).shouldDestroy || this.component.shouldDestroy || this.shouldDestroy;\n  this.fragment.unrender(shouldDestroy);\n  if (shouldDestroy) this.destroyed = true;\n  removeFromArray(this.el.__ractive_instances__, this);\n  unrenderHook$1.fire(this);\n  runloop.end();\n  this.unrendering = false;\n  return promise;\n}\n\nvar unshift = makeArrayMethod('unshift').path;\n\nfunction Ractive$updateModel(keypath, cascade) {\n  var promise = runloop.start();\n\n  if (!keypath) {\n    this.viewmodel.updateFromBindings(true);\n  } else {\n    this.viewmodel.joinAll(splitKeypath(keypath)).updateFromBindings(cascade !== false);\n  }\n\n  runloop.end();\n  return promise;\n}\n\nvar proto = {\n  add: Ractive$add,\n  animate: Ractive$animate,\n  attachChild: attachChild,\n  detach: Ractive$detach,\n  detachChild: detachChild,\n  find: Ractive$find,\n  findAll: Ractive$findAll,\n  findAllComponents: Ractive$findAllComponents,\n  findComponent: Ractive$findComponent,\n  findContainer: Ractive$findContainer,\n  findParent: Ractive$findParent,\n  fire: Ractive$fire,\n  get: Ractive$get,\n  getContext: getContext$1,\n  getNodeInfo: getNodeInfo$$1,\n  insert: Ractive$insert,\n  link: link,\n  observe: observe,\n  observeOnce: observeOnce,\n  off: Ractive$off,\n  on: Ractive$on,\n  once: Ractive$once,\n  pop: pop,\n  push: push,\n  readLink: readLink,\n  render: Ractive$render,\n  reset: Ractive$reset,\n  resetPartial: resetPartial,\n  resetTemplate: Ractive$resetTemplate,\n  reverse: reverse,\n  set: Ractive$set,\n  shift: shift,\n  sort: sort,\n  splice: splice,\n  subtract: Ractive$subtract,\n  teardown: Ractive$teardown,\n  toggle: Ractive$toggle,\n  toCSS: Ractive$toCSS,\n  toCss: Ractive$toCSS,\n  toHTML: Ractive$toHTML,\n  toHtml: Ractive$toHTML,\n  toText: toText,\n  transition: Ractive$transition,\n  unlink: unlink,\n  unrender: Ractive$unrender,\n  unshift: unshift,\n  update: Ractive$update,\n  updateModel: Ractive$updateModel\n};\nObject.defineProperty(proto, 'target', {\n  get: function get() {\n    return this.el;\n  }\n});\n\nfunction isInstance(object) {\n  return object && object instanceof this;\n}\n\nfunction sharedSet(keypath, value, options) {\n  var opts = _typeof(keypath) === 'object' ? value : options;\n  var model = SharedModel$1;\n  return _set(build({\n    viewmodel: model\n  }, keypath, value, true), opts);\n}\n\nvar callsSuper = /super\\s*\\(|\\.call\\s*\\(\\s*this/;\n\nfunction extend() {\n  for (var _len19 = arguments.length, options = new Array(_len19), _key18 = 0; _key18 < _len19; _key18++) {\n    options[_key18] = arguments[_key18];\n  }\n\n  if (!options.length) {\n    return extendOne(this);\n  } else {\n    return options.reduce(extendOne, this);\n  }\n}\n\nfunction extendWith(Class) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return extendOne(this, options, Class);\n}\n\nfunction extendOne(Parent) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var Target = arguments.length > 2 ? arguments[2] : undefined;\n  var proto;\n\n  var _Child = typeof Target === 'function' && Target;\n\n  if (options.prototype instanceof Ractive) {\n    throw new Error(\"Ractive no longer supports multiple inheritance.\");\n  }\n\n  if (_Child) {\n    if (!(_Child.prototype instanceof Parent)) {\n      throw new Error(\"Only classes that inherit the appropriate prototype may be used with extend\");\n    }\n\n    if (!callsSuper.test(_Child.toString())) {\n      throw new Error(\"Only classes that call super in their constructor may be used with extend\");\n    }\n\n    proto = _Child.prototype;\n  } else {\n    _Child = function Child(options) {\n      if (!(this instanceof _Child)) return new _Child(options);\n      construct(this, options || {});\n      initialise(this, options || {}, {});\n    };\n\n    proto = Object.create(Parent.prototype);\n    proto.constructor = _Child;\n    _Child.prototype = proto;\n  } // Static properties\n\n\n  Object.defineProperties(_Child, {\n    // alias prototype as defaults\n    defaults: {\n      value: proto\n    },\n    extend: {\n      value: extend,\n      writable: true,\n      configurable: true\n    },\n    extendWith: {\n      value: extendWith,\n      writable: true,\n      configurable: true\n    },\n    extensions: {\n      value: []\n    },\n    isInstance: {\n      value: isInstance\n    },\n    Parent: {\n      value: Parent\n    },\n    Ractive: {\n      value: Ractive\n    },\n    styleSet: {\n      value: setCSSData.bind(_Child),\n      configurable: true\n    }\n  }); // extend configuration\n\n  config.extend(Parent, proto, options, _Child); // store event and observer registries on the constructor when extending\n\n  _Child._on = (Parent._on || []).concat(toPairs(options.on));\n  _Child._observe = (Parent._observe || []).concat(toPairs(options.observe));\n  Parent.extensions.push(_Child); // attribute defs are not inherited, but they need to be stored\n\n  if (options.attributes) {\n    var _attrs; // allow an array of optional props or an object with arrays for optional and required props\n\n\n    if (Array.isArray(options.attributes)) {\n      _attrs = {\n        optional: options.attributes,\n        required: []\n      };\n    } else {\n      _attrs = options.attributes;\n    } // make sure the requisite keys actually store arrays\n\n\n    if (!Array.isArray(_attrs.required)) _attrs.required = [];\n    if (!Array.isArray(_attrs.optional)) _attrs.optional = [];\n    _Child.attributes = _attrs;\n  }\n\n  dataConfigurator.extend(Parent, proto, options, _Child);\n\n  if (options.computed) {\n    proto.computed = Object.assign(Object.create(Parent.prototype.computed), options.computed);\n  }\n\n  return _Child;\n} // styleSet for Ractive\n\n\nObject.defineProperty(Ractive, 'styleSet', {\n  configurable: true,\n  value: setCSSData.bind(Ractive)\n}); // sharedSet for Ractive\n\nObject.defineProperty(Ractive, 'sharedSet', {\n  value: sharedSet\n});\n\nfunction joinKeys() {\n  for (var _len20 = arguments.length, keys = new Array(_len20), _key19 = 0; _key19 < _len20; _key19++) {\n    keys[_key19] = arguments[_key19];\n  }\n\n  return keys.map(escapeKey).join('.');\n}\n\nfunction splitKeypath$1(keypath) {\n  return splitKeypath(keypath).map(unescapeKey);\n}\n\nfunction findPlugin(name, type, instance) {\n  return findInViewHierarchy(type, instance, name);\n}\n\nfunction Ractive(options) {\n  if (!(this instanceof Ractive)) return new Ractive(options);\n  construct(this, options || {});\n  initialise(this, options || {}, {});\n} // check to see if we're being asked to force Ractive as a global for some weird environments\n\n\nif (win && !win.Ractive) {\n  var opts = '';\n  var script = document.currentScript ||\n  /* istanbul ignore next */\n  document.querySelector('script[data-ractive-options]');\n  if (script) opts = script.getAttribute('data-ractive-options') || '';\n  /* istanbul ignore next */\n\n  if (~opts.indexOf('ForceGlobal')) win.Ractive = Ractive;\n}\n\nObject.assign(Ractive.prototype, proto, defaults);\nRactive.prototype.constructor = Ractive; // alias prototype as `defaults`\n\nRactive.defaults = Ractive.prototype; // share defaults with the parser\n\nshared.defaults = Ractive.defaults;\nshared.Ractive = Ractive; // static properties\n\nObject.defineProperties(Ractive, {\n  // debug flag\n  DEBUG: {\n    writable: true,\n    value: true\n  },\n  DEBUG_PROMISES: {\n    writable: true,\n    value: true\n  },\n  // static methods:\n  extend: {\n    value: extend\n  },\n  extendWith: {\n    value: extendWith\n  },\n  escapeKey: {\n    value: escapeKey\n  },\n  evalObjectString: {\n    value: parseJSON\n  },\n  findPlugin: {\n    value: findPlugin\n  },\n  getContext: {\n    value: getContext$2\n  },\n  getCSS: {\n    value: getCSS\n  },\n  getNodeInfo: {\n    value: getNodeInfo$1\n  },\n  isInstance: {\n    value: isInstance\n  },\n  joinKeys: {\n    value: joinKeys\n  },\n  normaliseKeypath: {\n    value: normalise\n  },\n  parse: {\n    value: _parse\n  },\n  splitKeypath: {\n    value: splitKeypath$1\n  },\n  // sharedSet and styleSet are in _extend because circular refs\n  unescapeKey: {\n    value: unescapeKey\n  },\n  // support\n  enhance: {\n    writable: true,\n    value: false\n  },\n  svg: {\n    value: svg\n  },\n  // version\n  VERSION: {\n    value: '0.9.4'\n  },\n  // plugins\n  adaptors: {\n    writable: true,\n    value: {}\n  },\n  components: {\n    writable: true,\n    value: {}\n  },\n  decorators: {\n    writable: true,\n    value: {}\n  },\n  easing: {\n    writable: true,\n    value: easing\n  },\n  events: {\n    writable: true,\n    value: {}\n  },\n  extensions: {\n    value: []\n  },\n  interpolators: {\n    writable: true,\n    value: interpolators\n  },\n  partials: {\n    writable: true,\n    value: {}\n  },\n  transitions: {\n    writable: true,\n    value: {}\n  },\n  // CSS variables\n  cssData: {\n    configurable: true,\n    value: {}\n  },\n  // access to @shared without an instance\n  sharedData: {\n    value: data\n  },\n  // for getting the source Ractive lib from a constructor\n  Ractive: {\n    value: Ractive\n  },\n  // to allow extending contexts\n  Context: {\n    value: extern.Context.prototype\n  }\n});\nObject.defineProperty(Ractive, '_cssModel', {\n  configurable: true,\n  value: new CSSModel(Ractive)\n});\nexport default Ractive;","map":null,"metadata":{},"sourceType":"module"}